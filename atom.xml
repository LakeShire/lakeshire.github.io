<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>湖畔镇</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://lakeshire.github.io/"/>
  <updated>2017-11-29T09:17:23.000Z</updated>
  <id>http://lakeshire.github.io/</id>
  
  <author>
    <name>刘晗</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Handler机制</title>
    <link href="http://lakeshire.github.io/2017/11/29//archivers/handler/"/>
    <id>http://lakeshire.github.io/2017/11/29//archivers/handler/</id>
    <published>2017-11-29T04:00:00.000Z</published>
    <updated>2017-11-29T09:17:23.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h2><p>Handler是Android中常用的线程间通信机制</p><p>Android是不允许在UI线程进行耗时的网络操作，所以一般会在工作线程中执行网络请求，得到返回数据后通知UI线程更新界面，这就可以通过Handler实现</p><p><img src="http://7xt3ho.com1.z0.glb.clouddn.com/e03907fead023dc753bf8777548d3bac_b.png" alt=""></p><a id="more"></a><h3 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h3><h4 id="Handler-1"><a href="#Handler-1" class="headerlink" title="Handler"></a>Handler</h4><p>首先需要创建一个Handler，所以先看一下Handler的构造函数，Handler有几个版本的构造函数</p><p><em>Handler.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Looper looper, Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">  mLooper = looper;</span><br><span class="line">  mQueue = looper.mQueue;</span><br><span class="line">  mCallback = callback;</span><br><span class="line">  mAsynchronous = async;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个构造函数接受三个参数，第一个指定对应的Looper，第二个指定全局的回调函数，第三个指定是同步还是异步</p><p><em>Handler.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">  mLooper = Looper.myLooper();</span><br><span class="line">  <span class="keyword">if</span> (mLooper == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Can't create handler inside thread that has not called Looper.prepare()"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  mQueue = mLooper.mQueue;</span><br><span class="line">  mCallback = callback;</span><br><span class="line">  mAsynchronous = async;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个构造函数接受两个参数，没有传入Looper，Looper在构造函数中由<code>Looper.myLooper()</code>创建</p><p>当mLooper为空时会抛出一个常见的异常，说明在创建Handler之前必须调用<code>Looper.prepare()</code></p><p>由此我们获得了消息循环mLooper，消息队列mQueue，全局回调mCallback</p><h4 id="Looper"><a href="#Looper" class="headerlink" title="Looper"></a>Looper</h4><p><em>Looper.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="meta">@Nullable</span> <span class="function">Looper <span class="title">myLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> sThreadLocal.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>myLooper()</code>返回了当前线程的一个Looper</p><p><em>Looper.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个线程本地变量Looper是在<code>prepare()</code>里创建的，如果反复调用则会抛异常，意思是一个线程只能有一个Looper</p><p><em>Looper.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Looper</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">  mQueue = <span class="keyword">new</span> MessageQueue(quitAllowed);</span><br><span class="line">  mThread = Thread.currentThread();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Looper的构造函数里，创建了一个消息队列mQueue，并把当前的线程设置给mThread</p><h4 id="MessageQueue"><a href="#MessageQueue" class="headerlink" title="MessageQueue"></a>MessageQueue</h4><p><em>MessageQueue.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MessageQueue(<span class="keyword">boolean</span> quitAllowed) &#123;</span><br><span class="line">  mQuitAllowed = quitAllowed;</span><br><span class="line">  mPtr = nativeInit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消息队列的构造函数，可见调用了Native层的相关函数<code>nativeInit()</code></p><h4 id="Message"><a href="#Message" class="headerlink" title="Message"></a>Message</h4><p>定义了一个消息，包含了描述和可被发送给Handler的数据对象，这个对象包含两个额外的int域和一个额外的object域，允许你在很多场合不用做内存分配</p><p>尽管构造函数是public的，最好的方式是<code>obtain()</code>或者<code>obtainMessage()</code>，将从一个回收对象的池中获得对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (sPoolSync) &#123;</span><br><span class="line">    <span class="keyword">if</span> (sPool != <span class="keyword">null</span>) &#123;</span><br><span class="line">      Message m = sPool;</span><br><span class="line">      sPool = m.next;</span><br><span class="line">      m.next = <span class="keyword">null</span>;</span><br><span class="line">      m.flags = <span class="number">0</span>;</span><br><span class="line">      sPoolSize--;</span><br><span class="line">      <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Message();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Message里面有一个<code>next</code>的Message域，整个就是一个链式结构<br>所以<code>sPool</code>也是一个消息池的链，在从池中取出<code>sPool</code>这个消息时，<code>sPool</code>本身被赋值为<code>sPool.next</code>，池大小减1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_POOL_SIZE = <span class="number">50</span>;</span><br></pre></td></tr></table></figure><h4 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h4><p>一般通过<code>sendMessage()</code>这系列的函数发送消息，都要获得一个Message，设置消息类型和内容，立即或延时发送消息，最终是调用<code>sendMessageAtTime()</code></p><p><em>Handler.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessageAtTime</span><span class="params">(Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">  MessageQueue queue = mQueue;</span><br><span class="line">  <span class="keyword">if</span> (queue == <span class="keyword">null</span>) &#123;</span><br><span class="line">    RuntimeException e = <span class="keyword">new</span> RuntimeException(<span class="keyword">this</span> + <span class="string">" sendMessageAtTime() called with no mQueue"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>检查是否有消息队列，没有的话会抛异常，然后调用<code>enqueueMessage()</code>把消息放入队列</p><p><em>Handler.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(MessageQueue queue, Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">  msg.target = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">if</span> (mAsynchronous) &#123;</span><br><span class="line">    msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先设置了消息的<code>target</code>字段为本Handler，然后调用MessageQueue的<code>queueMessage()</code>方法</p><p>从<code>enqueueMessage()</code>放进队列的消息的<code>target</code>都被设置了值，而后面有判断<code>target</code>为空的地方</p><p><code>MessageQueue</code>里有一个<code>postSyncBarrier()</code>方法，用来添加一个同步屏障</p><p>消息分为同步和异步，同步屏障说明之后的同步消息不被处理，异步消息就不会被影响，Handler的默认构造设置<code>mAsynchronous</code>为<code>false</code>，即都是同步消息</p><p><em>MessageQueue.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">postSyncBarrier</span><span class="params">(<span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> token = mNextBarrierToken++;</span><br><span class="line">    <span class="keyword">final</span> Message msg = Message.obtain();</span><br><span class="line">    msg.markInUse();</span><br><span class="line">    msg.when = when;</span><br><span class="line">    msg.arg1 = token;</span><br><span class="line"></span><br><span class="line">    Message prev = <span class="keyword">null</span>;</span><br><span class="line">    Message p = mMessages;</span><br><span class="line">    <span class="keyword">if</span> (when != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; p.when &lt;= when) &#123;</span><br><span class="line">        prev = p;</span><br><span class="line">        p = p.next;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123;</span><br><span class="line">      msg.next = p;</span><br><span class="line">      prev.next = msg;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      msg.next = p;</span><br><span class="line">      mMessages = msg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> token;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现没有设置消息的<code>target</code>字段，即为空，</p><p><em>MessageQueue.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(Message msg, <span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 检查Message，目标不能为空，也不能在使用中</span></span><br><span class="line">  <span class="keyword">if</span> (msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Message must have a target."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (msg.isInUse()) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(msg + <span class="string">" This message is already in use."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果正在退出 就回收掉Message并返回</span></span><br><span class="line">    <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">      IllegalStateException e = <span class="keyword">new</span> IllegalStateException(msg.target + <span class="string">" sending message to a Handler on a dead thread"</span>);</span><br><span class="line">      msg.recycle();</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 标记Message为使用中 设置触发时间字段when</span></span><br><span class="line">    msg.markInUse();</span><br><span class="line">    msg.when = when;</span><br><span class="line">    Message p = mMessages;</span><br><span class="line">    <span class="keyword">boolean</span> needWake;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="keyword">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</span><br><span class="line">      <span class="comment">// 新的队列头，立即执行，最先执行</span></span><br><span class="line">      <span class="comment">// 如果队列被阻塞则唤醒</span></span><br><span class="line">      msg.next = p;</span><br><span class="line">      mMessages = msg;</span><br><span class="line">      needWake = mBlocked;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 把Message插入到队列里合适的地方</span></span><br><span class="line">      needWake = mBlocked &amp;&amp; p.target == <span class="keyword">null</span> &amp;&amp; msg.isAsynchronous();</span><br><span class="line">      Message prev;</span><br><span class="line">      <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        prev = p;</span><br><span class="line">        p = p.next;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> || when &lt; p.when) &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">          needWake = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      msg.next = p;</span><br><span class="line">      prev.next = msg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如有必要则唤醒</span></span><br><span class="line">    <span class="keyword">if</span> (needWake) &#123;</span><br><span class="line">      nativeWake(mPtr);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="处理消息"><a href="#处理消息" class="headerlink" title="处理消息"></a>处理消息</h4><p>Looper在<code>prepare()</code>之后，需要调用<code>loop()</code>来开始消息循环</p><p><em>Looper.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Looper me = myLooper();</span><br><span class="line">  <span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"No Looper; Looper.prepare() wasn't called on this thread."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">final</span> MessageQueue queue = me.mQueue;</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    Message msg = queue.next(); <span class="comment">// might block</span></span><br><span class="line">    <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    msg.target.dispatchMessage(msg);</span><br><span class="line">    msg.recycleUnchecked();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开始一个无限循环，调用<code>next()</code>获得消息队列的下一条消息，这里可能阻塞，如果取得的消息为空则退出循环，否则获得<code>target</code>字段，调用其<code>dispatchMessage()</code>方法</p><p><em>Handler.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">    handleCallback(msg);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    handleMessage(msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按如下顺序调用回调处理消息：</p><p>1.消息中设置的回调</p><p>2.全局回调的<code>handleMessage()</code></p><p>3.<code>Handler.handleMessage()</code>，由子类实现</p><p><em>MessageQueue.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Message <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// mPtr是Native层中用到的，通过nativeInit()获得，应是队列头</span></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">long</span> ptr = mPtr;</span><br><span class="line">  <span class="keyword">if</span> (ptr == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> pendingIdleHandlerCount = -<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 然后开始一个无限循环，通过nativePollOnce()取一个消息</span></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nextPollTimeoutMillis != <span class="number">0</span>) &#123;</span><br><span class="line">      Binder.flushPendingCommands();</span><br><span class="line">    &#125;</span><br><span class="line">    nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">      Message prevMsg = <span class="keyword">null</span>;</span><br><span class="line">      Message msg = mMessages;</span><br><span class="line">      <span class="comment">// 如果消息的target为空 则寻找下一个异步消息</span></span><br><span class="line">      <span class="comment">// 说明这是一个同步屏障 不会继续处理同步消息</span></span><br><span class="line">      <span class="keyword">if</span> (msg != <span class="keyword">null</span> &amp;&amp; msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">          prevMsg = msg;</span><br><span class="line">          msg = msg.next;</span><br><span class="line">        &#125; <span class="keyword">while</span> (msg != <span class="keyword">null</span> &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (msg != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (now &lt; msg.when) &#123;</span><br><span class="line">          <span class="comment">// 消息的触发时间还没到 设置一个超时当它就绪时唤醒</span></span><br><span class="line">          nextPollTimeoutMillis = (<span class="keyword">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 消息就绪 标记为没有阻塞</span></span><br><span class="line">          <span class="comment">// 从队列中取出这个消息并返回</span></span><br><span class="line">          mBlocked = <span class="keyword">false</span>;</span><br><span class="line">          <span class="keyword">if</span> (prevMsg != <span class="keyword">null</span>) &#123;</span><br><span class="line">            prevMsg.next = msg.next;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mMessages = msg.next;</span><br><span class="line">          &#125;</span><br><span class="line">          msg.next = <span class="keyword">null</span>;</span><br><span class="line">          msg.markInUse();</span><br><span class="line">          <span class="keyword">return</span> msg;        </span><br><span class="line">        &#125; </span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        nextPollTimeoutMillis = -<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">        dispose();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 消息队列为空或者第一条消息还没就绪 就会执行空闲Handler</span></span><br><span class="line">      <span class="keyword">if</span> (pendingIdleHandlerCount &lt; <span class="number">0</span> &amp;&amp; (mMessages == <span class="keyword">null</span> || now &lt; mMessages.when)) &#123;</span><br><span class="line">        pendingIdleHandlerCount = mIdleHandlers.size();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (pendingIdleHandlerCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 没有空闲Handler 继续循环 并设置为阻塞</span></span><br><span class="line">        mBlocked = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (mPendingIdleHandlers == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mPendingIdleHandlers = <span class="keyword">new</span> IdleHandler[Math.max(pendingIdleHandlerCount, <span class="number">4</span>)];</span><br><span class="line">      &#125;</span><br><span class="line">      mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 运行空闲Handler 只在第一次循环的时候执行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;</span><br><span class="line">      <span class="keyword">final</span> IdleHandler idler = mPendingIdleHandlers[i];</span><br><span class="line">      mPendingIdleHandlers[i] = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">boolean</span> keep = <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        keep = idler.queueIdle();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        Log.wtf(TAG, <span class="string">"IdleHandler threw exception"</span>, t);</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (!keep) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">          mIdleHandlers.remove(idler);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pendingIdleHandlerCount = <span class="number">0</span>;</span><br><span class="line">    nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Native层实现"><a href="#Native层实现" class="headerlink" title="Native层实现"></a><em>Native层实现</em></h3><p>MessageQueue通过<code>mPtr</code>变量保存NativeMessageQueue对象，从而使得MessageQueue成为Java层和Native层的枢纽，既能处理上层消息，也能处理Native层消息</p><p>Handler/Looper/Message这三大类Java层与Native层并没有任何的真正关联，只是分别在Java层和Native层的Handler消息模型中具有相似的功能。都是彼此独立的，各自实现相应的逻辑</p><p><a href="http://www.programering.com/a/MjM2QDMwATc.html" target="_blank" rel="noopener">Native层分析参见这篇博客</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Handler&quot;&gt;&lt;a href=&quot;#Handler&quot; class=&quot;headerlink&quot; title=&quot;Handler&quot;&gt;&lt;/a&gt;Handler&lt;/h2&gt;&lt;p&gt;Handler是Android中常用的线程间通信机制&lt;/p&gt;
&lt;p&gt;Android是不允许在UI线程进行耗时的网络操作，所以一般会在工作线程中执行网络请求，得到返回数据后通知UI线程更新界面，这就可以通过Handler实现&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xt3ho.com1.z0.glb.clouddn.com/e03907fead023dc753bf8777548d3bac_b.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://lakeshire.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://lakeshire.github.io/tags/Android/"/>
    
      <category term="Handler" scheme="http://lakeshire.github.io/tags/Handler/"/>
    
  </entry>
  
  <entry>
    <title>Binder机制</title>
    <link href="http://lakeshire.github.io/2017/11/27//archivers/binder/"/>
    <id>http://lakeshire.github.io/2017/11/27//archivers/binder/</id>
    <published>2017-11-27T09:00:00.000Z</published>
    <updated>2017-11-28T02:21:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>Binder是Android的一种安全且高效的进程间通信机制，安全是因为其发起通信时会写入PID/UID信息，高效是因为传输过程只需要一次内存拷贝</p><a id="more"></a><h2 id="Binder机制"><a href="#Binder机制" class="headerlink" title="Binder机制"></a>Binder机制</h2><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Binder通信模型包含四个角色Client，Service，ServiceManager和Binder驱动，通信过程为：</p><ol><li>Server进程需要先向ServiceManager进程注册服务，该过程本身是跨进程的，首先获得ServiceManager服务，然后调用注册方法</li><li>Client进程使用服务时需要向ServiceManager获得对应Service</li><li>调用服务中提供的方法</li></ol><p>整个过程类似于从电话本上查到对应名字的电话并拨打过去……</p><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p>进程是CPU上运行的单个任务，Linux系统是多进程的，使用虚拟内存实现了进程的隔离，进程都认为独占了整个系统，进程之间数据不共享，需要借助某种机制进行进程间通信</p><p>Linux将内存划分为内核空间和用户空间，内核空间不允许应用程序随便访问，应用程序可以通过系统调用进入内核态访问内核空间</p><p>一个进程的用户空间如果想要访问别的进程的用户空间，需要借助进程间通信机制，如Linux的Socket，管道，共享内存等，Android则使用了Binder机制，通过Binder驱动实现</p><h3 id="Binder跨进程通信原理"><a href="#Binder跨进程通信原理" class="headerlink" title="Binder跨进程通信原理"></a>Binder跨进程通信原理</h3><p>Android系统使用代理模式完成Binder通信，Client进程持有Server端的代理，代理对象协助驱动完成了跨进程通信</p><h4 id="Java层数据结构"><a href="#Java层数据结构" class="headerlink" title="Java层数据结构"></a>Java层数据结构</h4><ul><li>IBinder 代表跨进程传输能力的接口，驱动会识别IBinder类型的数据，完成本地对象和代理对象的转换</li><li>IInterface 代表远程服务能力的接口</li><li>Binder 代表Binder本地对象，BinderProxy是Binder的内部类，是Binder的本地代理，它们都实现了IBinder，Binder驱动会完成这两种对象的转换</li><li>Stub 使用AIDL的时候会自动生成Stub类，它继承了Binder，实现了IInterface，是一个抽象类，需要被具体实现</li></ul><p>AIDL生成的代码可以看到这几个结构，Android的很多服务基本都是这个样子，比如<code>ActivityManagerService</code></p><p><code>IActivityManager</code>是具有Activity管理能力的远程接口，<code>ActivityManagerNative</code>实现了该接口，它是一个Binder本地对象，它的内部类<code>ActivityManagerProxy</code>是Binder代理对象，<code>ActivityManagerService</code>继承了<code>ActivityManagerNative</code>，是服务的具体实现类</p><h4 id="以ActivityManagerService为例的原理分析"><a href="#以ActivityManagerService为例的原理分析" class="headerlink" title="以ActivityManagerService为例的原理分析"></a>以ActivityManagerService为例的原理分析</h4><p>以<code>startActivity()</code>为例</p><p><em>Instrumentation.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ActivityManagerNative.getDefault().startActivity()</span><br></pre></td></tr></table></figure><p>首先获得ActivityManager服务，然后调用<code>startActivity()</code></p><p><em>ActivityManagerNative.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IBinder b = ServiceManager.getService(<span class="string">"activity"</span>);</span><br><span class="line">IActivityManager am = asInterface(b);</span><br><span class="line"><span class="keyword">return</span> am;</span><br></pre></td></tr></table></figure><p>通过<code>ServiceManager</code>获得名为<code>activity</code>的服务，它是一个<code>IBinder</code></p><p>通过<code>asInterface()</code>方法转化成<code>IActivityManager</code>接口，这个对象具有Activity管理能力，显然在应用进程里它应该是一个Binder代理对象</p><p><em>ActivityManagerNative.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">public</span> IActivityManager <span class="title">asInterface</span><span class="params">(IBinder obj)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (obj == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  IActivityManager in = (IActivityManager) obj.queryLocalInterface(descriptor);</span><br><span class="line">  <span class="keyword">if</span> (in != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> in;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ActivityManagerProxy(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>queryLocalInterface()</code>获取本地接口，如果获取不到则用此Binder创建一个代理对象</p><p><em>Binder.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> IInterface <span class="title">queryLocalInterface</span><span class="params">(String descriptor)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (mDescriptor.equals(descriptor)) &#123;</span><br><span class="line">    <span class="keyword">return</span> mOwner;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BinderProxy</span> <span class="keyword">implements</span> <span class="title">IBinder</span> </span>&#123;</span><br><span class="line">  ......</span><br><span class="line">  <span class="function"><span class="keyword">public</span> IInterface <span class="title">queryLocalInterface</span><span class="params">(String descriptor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法在<code>Binder</code>和<code>BinderProxy</code>中都有实现，<code>Binder</code>中返回了本地对象，而<code>BinderProxy</code>中返回了<code>null</code>，所以在服务端和客户端拿到的IBinder不同</p><p>获得<code>IActivityManager</code>之后就可以调用<code>startActivity()</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">startActivity</span><span class="params">(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, <span class="keyword">int</span> requestCode, <span class="keyword">int</span> startFlags, ProfilerInfo profilerInfo, Bundle options)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">  Parcel data = Parcel.obtain();</span><br><span class="line">  Parcel reply = Parcel.obtain();</span><br><span class="line">  data.writeInterfaceToken(IActivityManager.descriptor);</span><br><span class="line">  data.writeStrongBinder(caller != <span class="keyword">null</span> ? caller.asBinder() : <span class="keyword">null</span>);</span><br><span class="line">  data.writeString(callingPackage);</span><br><span class="line">  intent.writeToParcel(data, <span class="number">0</span>);</span><br><span class="line">  data.writeString(resolvedType);</span><br><span class="line">  data.writeStrongBinder(resultTo);</span><br><span class="line">  data.writeString(resultWho);</span><br><span class="line">  data.writeInt(requestCode);</span><br><span class="line">  data.writeInt(startFlags);</span><br><span class="line">  <span class="keyword">if</span> (profilerInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">    data.writeInt(<span class="number">1</span>);</span><br><span class="line">    profilerInfo.writeToParcel(data, Parcelable.PARCELABLE_WRITE_RETURN_VALUE);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    data.writeInt(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (options != <span class="keyword">null</span>) &#123;</span><br><span class="line">    data.writeInt(<span class="number">1</span>);</span><br><span class="line">    options.writeToParcel(data, <span class="number">0</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    data.writeInt(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  mRemote.transact(START_ACTIVITY_TRANSACTION, data, reply, <span class="number">0</span>);</span><br><span class="line">  reply.readException();</span><br><span class="line">  <span class="keyword">int</span> result = reply.readInt();</span><br><span class="line">  reply.recycle();</span><br><span class="line">  data.recycle();</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按顺序填入参数，然后调用<code>mRemote</code>的<code>transact()</code>方法，这个<code>mRemote</code>就是一个<code>IBinder</code>，最后等待返回值</p><p>服务端在<code>onTransact()</code>里面收到客户端发来的命令</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">int</span> code, Parcel data, Parcel reply, <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (code) &#123;</span><br><span class="line">    <span class="keyword">case</span> START_ACTIVITY_TRANSACTION: &#123;</span><br><span class="line">      data.enforceInterface(IActivityManager.descriptor);</span><br><span class="line">      IBinder b = data.readStrongBinder();</span><br><span class="line">      IApplicationThread app = ApplicationThreadNative.asInterface(b);</span><br><span class="line">      String callingPackage = data.readString();</span><br><span class="line">      Intent intent = Intent.CREATOR.createFromParcel(data);</span><br><span class="line">      String resolvedType = data.readString();</span><br><span class="line">      IBinder resultTo = data.readStrongBinder();</span><br><span class="line">      String resultWho = data.readString();</span><br><span class="line">      <span class="keyword">int</span> requestCode = data.readInt();</span><br><span class="line">      <span class="keyword">int</span> startFlags = data.readInt();</span><br><span class="line">      ProfilerInfo profilerInfo = data.readInt() != <span class="number">0</span> ? ProfilerInfo.CREATOR.createFromParcel(data) : <span class="keyword">null</span>;</span><br><span class="line">      Bundle options = data.readInt() != <span class="number">0</span> ? Bundle.CREATOR.createFromParcel(data) : <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">int</span> result = startActivity(app, callingPackage, intent, resolvedType, resultTo, resultWho, requestCode, startFlags, profilerInfo, options);</span><br><span class="line">      reply.writeNoException();</span><br><span class="line">      reply.writeInt(result);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      ......</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">super</span>.onTransact(code, data, reply, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据命令号走对应的条件分支，取出参数，调用服务端中实际的<code>startActivity()</code>方法，最后写回返回值</p><h4 id="ServiceManager"><a href="#ServiceManager" class="headerlink" title="ServiceManager"></a>ServiceManager</h4><p><code>ServiceManager</code>是整个Binder机制的守护进程，来管理各种Server，并像Client提供查询Server远程接口的功能</p><p><code>ServiceManager</code>做了三件事：</p><p>1.打开Binder设备文件并建立内存映射</p><p>2.告诉Binder驱动自己是上下文管理者即守护进程</p><p>3.进入无限循环，等待Client的请求</p><p>ServiceManager也是一个Server，然而它又与一般的Server不一样。对于普通的Server来说，Client如果想要获得Server的远程接口，那么必须通过ServiceManager远程接口提供的<code>getService</code>接口来获得，这本身就是一个使用Binder机制来进行进程间通信的过程。而对于ServiceManager这个Server来说，Client如果想要获得ServiceManager远程接口，却不必通过进程间通信机制来获得，因为ServiceManager远程接口是一个特殊的Binder引用，它的引用句柄一定是0</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Binder是Android的一种安全且高效的进程间通信机制，安全是因为其发起通信时会写入PID/UID信息，高效是因为传输过程只需要一次内存拷贝&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://lakeshire.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://lakeshire.github.io/tags/Android/"/>
    
      <category term="Binder" scheme="http://lakeshire.github.io/tags/Binder/"/>
    
      <category term="跨进程通信" scheme="http://lakeshire.github.io/tags/%E8%B7%A8%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>Gradle插件</title>
    <link href="http://lakeshire.github.io/2017/08/15//archivers/gradle-plugin/"/>
    <id>http://lakeshire.github.io/2017/08/15//archivers/gradle-plugin/</id>
    <published>2017-08-15T09:00:00.000Z</published>
    <updated>2017-11-28T03:10:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>Gradle插件是一组任务，几乎所有的任务，如编译任务，设置域对象，设置源文件等都由插件处理</p><a id="more"></a><h2 id="编写Gradle插件"><a href="#编写Gradle插件" class="headerlink" title="编写Gradle插件"></a>编写Gradle插件</h2><ol><li><p>创建一个模块（假设模块名叫<code>library</code>），清空除build.gradle以外的文件，清空build.gradle的内容</p></li><li><p>新建src文件夹，在src下新建main文件夹，在main下新建groovy和resources文件夹</p></li><li><p>groovy下新建包名文件夹，在里面创建类，创建一个<code>PluginImpl.groovy</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package com.github.lakeshire</span><br><span class="line">import org.gradle.api.Plugin</span><br><span class="line">import org.gradle.api.Project</span><br><span class="line"></span><br><span class="line">public class PluginImpl implements Plugin&lt;Project&gt; &#123;</span><br><span class="line">  void apply(Project project) &#123;</span><br><span class="line">    project.task(&apos;TestTask&apos;) &#123;</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>resources下创建META-INF文件夹，META-INF下创建gradle-plugins文件夹，gradle-plugins下新建属性文件，文件命名就是插件的名字，如<code>plugin.test.properties</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation-class=com.github.lakeshire.PluginImpl</span><br></pre></td></tr></table></figure><p>这样就创建了一个叫<code>plugin.test</code>的插件，插件里有一个<code>TestTask</code>任务</p></li><li><p>发布到本地仓库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">  mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line">group=&apos;com.github.lakeshire&apos;</span><br><span class="line">version=&apos;1.0.0&apos;</span><br><span class="line"></span><br><span class="line">uploadArchives &#123;</span><br><span class="line">  repositories &#123;</span><br><span class="line">    mavenDeployer &#123;</span><br><span class="line">      repository(url : uri(&apos;../repo&apos;))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Sync之后会出现一个<code>uploadArchives</code>任务，运行就在<code>repo</code>目录下出现我们的插件</p></li><li><p>使用插件，在使用到的<code>gradle.build</code>中加入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">  repositories &#123;</span><br><span class="line">    maven &#123;</span><br><span class="line">      url uri(&apos;../repo&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  dependencies &#123;</span><br><span class="line">    classpath &apos;com.github.lakeshire:library:1.0.0&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 就是模块名</span><br><span class="line">apply plugin: &apos;library&apos;</span><br></pre></td></tr></table></figure><p>​</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Gradle插件是一组任务，几乎所有的任务，如编译任务，设置域对象，设置源文件等都由插件处理&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://lakeshire.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://lakeshire.github.io/tags/Android/"/>
    
      <category term="Gradle" scheme="http://lakeshire.github.io/tags/Gradle/"/>
    
  </entry>
  
  <entry>
    <title>Activity相关</title>
    <link href="http://lakeshire.github.io/2017/04/11//archivers/activity-launch-mode/"/>
    <id>http://lakeshire.github.io/2017/04/11//archivers/activity-launch-mode/</id>
    <published>2017-04-11T09:00:00.000Z</published>
    <updated>2017-11-28T03:11:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍一些与Activity相关的小知识</p><a id="more"></a><h2 id="启动模式"><a href="#启动模式" class="headerlink" title="启动模式"></a>启动模式</h2><p><code>Activity</code>可以设置<code>android:launchMode</code>指定启动模式</p><ul><li><p><code>standard</code><br>标准</p></li><li><p><code>singleTop</code><br>唯一栈顶，启动的Activity如果在栈顶，将不再新建，而是调用原Activity的<code>onNewIntent()</code><br>比如点击搜索按钮进入搜索结果页面，一般而言还是会有搜索框可以再次搜索，如果反复生成新搜索页面，回退的时候非常麻烦而且很怪异，这个时候适合用这个</p></li><li><p><code>singleTask</code><br>如果栈内已经有一个标记为<code>singleTask</code>的Activity A，再次启动一个这样的Activity时将不会新建，而是会残忍的销毁A之上的所有Activity，使A显示在栈顶，并调用它的<code>onNewIntent()</code><br>文档里提到然而并不是这样，如果想达到这样的效果即新开一个Task，这个Activity作为根，你需要配置清单的<code>android:taskAffinity</code>属性为空</p></li></ul><blockquote><p>The system creates a new task and instantiates the activity at the root of the new task</p></blockquote><ul><li><code>singleInstance</code><br>栈内只有这么一个Activity，再次启动一个这样的Acitivity会启动一个新的Task</li></ul><h2 id="标志位"><a href="#标志位" class="headerlink" title="标志位"></a>标志位</h2><p>比较常用的有下面这些</p><ul><li><p><code>FLAG_ACTIVITY_SINGLE_TOP</code><br>唯一栈顶，启动的Activity如果在栈顶，将不再新建，而是调用原Activity的<code>onNewIntent()</code></p></li><li><p><code>FLAG_ACTIVITY_NEW_TASK</code><br>启动一个新的Task，通常用于表现启动器行为，提供用户一组可以做的事，然后运行在完全独立的Task里</p></li><li><p><code>FLAG_ACTIVITY_MULTIPLE_TASK</code><br>用来启动一个新的Task，通常与<code>FLAG_ACTIVITY_NEW_TASK</code>或<code>FLAG_ACTIVITY_NEW_DOCUMENT</code>一起使用（不一起使用该标记会被忽略），因为单独使用这些标记时，如果能在现存的Task里找到匹配的，就不会再新建，加上这个标记则会跳过搜索匹配Task的过程，无条件的创建一个新的Task</p></li><li><p><code>FLAG_ACTIVITY_CLEAR_TOP</code><br>可以和<code>FLAG_ACTIVITY_NEW_TASK</code>很好的搭配，用来启动一个Task的根Activity，将把那个Task当前正在运行的任何实例都调到前台，然后清除到根，在从通知里启动Activity这种场景尤其有用</p></li><li><p><code>FLAG_ACTIVITY_REORDER_TO_FRONT</code><br>如果已经运行，就调到栈顶，如果<code>FLAG_ACTIVITY_CLEAR_TOP</code>也被设置了会被忽略</p></li><li><p><code>FLAG_ACTIVITY_CLEAR_TASK</code><br>清空Task，Activity成为根</p></li></ul><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>Activity有三种重要状态：</p><ul><li><code>resumed</code><br>Activity在前台，拥有用户焦点</li><li><code>paused</code><br>别的Activity在前台并且拥有焦点，但是这个Activity仍然可见，内存中保存有Activity对象，维持着所有状态，保持附着于WindowManager，在极度低内存时可能被销毁</li><li><code>stopped</code><br>完全被其他Activity覆盖，处于后台不可见，内存中保存有Activity对象，维持着所有状态，但是未附着于WindowManager，当其他地方需要内存时可能被销毁</li></ul><p>当Activity是<code>paused</code>或<code>stopped</code>时，系统可能调用<code>finish()</code>或直接杀死进程来回收内存，当Activity再次被打开时，必须被重新创建</p><p>生命周期</p><ul><li>全部阶段<br>从<code>onCreate()</code>到<code>onDestroy()</code>，在前者初始化，在后者释放所有资源，比如停止后台下载线程</li><li>可见阶段<br>从<code>onStart()</code>到<code>onStop()</code>，可以在前者注册<code>BroadcastReceiver</code>监视UI变化，在后者注销</li><li>前台阶段<br>从<code>onResume()</code>到<code>onPause()</code>，获得焦点用户可交互，可能频繁切换，所以其中的代码需要轻量，<code>onPause()</code>是Activity可能被销毁之前调用的最后方法，所以要在这里做关键数据保存</li></ul><p>假设A启动B，执行顺序是A.onPause() -&gt; B.onCreate() -&gt; B.onStart() -&gt; B.onResume() -&gt; A.onStop()，所以如果A需要写入数据供B读取，应该发生在<code>onPause()</code>中</p><h2 id="配置变化"><a href="#配置变化" class="headerlink" title="配置变化"></a>配置变化</h2><p>如果配置变化，UI都需要更新，Activity有特殊的支持处理配置变化<br>除非特别指定，配置变化将会导致当前Activity被销毁，如果Activity当前可见，之后会重新实例化，使用<code>savedInstanceState</code>，这是之前实例通过<code>onSaveInstanceState()</code>保存的</p><p>某些特殊情况，你可能想跳过重建，通过清单里的<code>android:configChanges</code>配置，对于你要处理的任意配置变化类型，将会调用<code>onConfigurationChanged()</code>而不是重启，如果一个配置变化你不处理，仍然会重建而且这个函数不会被调用</p><p>要做以下几点：</p><ol><li>添加权限<code>&lt;uses-permission android:name=&quot;android.permission.CHANGE_CONFIGURATION&quot; /&gt;</code></li><li>指定<code>android:configChanges</code>属性，用<code>|</code>连接多个变化项</li><li>重写<code>onConfigurationChanged()</code></li></ol><blockquote><p>从API13后转屏时<code>screenSize</code>也会改变，这时仅写<code>orientation</code>是不会生效的，而要写<code>orientation|srceenSize</code>，小于API13则不需要，此为一坑</p></blockquote><h2 id="保存状态"><a href="#保存状态" class="headerlink" title="保存状态"></a>保存状态</h2><p>Activity可能被销毁，重建时需要之前的信息，可以通过<code>onSaveInstanceState()</code>保存信息，在<code>onCreate()</code>或<code>onRestoreInstanceState()</code>中获得信息恢复</p><p><code>onSaveInstanceState()</code>是不保证被调用的，因为当用户主动关闭Activity时没有必要保存状态，如果系统调用这个方法，会在<code>onStop()</code>之前调用，可能在<code>onPause()</code>之前</p><p>然而即使你没有实现<code>onSaveInstanceState()</code>，一些Activity状态仍然被默认实现保存了，默认会调用所有视图的<code>onSaveInstanceState()</code>，保存所有视图的状态，几乎所有视图都实现了这个方法，所以能保存和恢复状态，不过你需要提供一个<code>android:id</code>，否则不会保存状态</p><p>重写这些方法的时候不要忘了调用父类方法</p><p><code>onSaveInstanceState()</code>不保证被调用，所以应该只用来保存UI状态，不要用它保存数据，这应该在<code>onPause()</code>中做</p><h2 id="进程生命周期"><a href="#进程生命周期" class="headerlink" title="进程生命周期"></a>进程生命周期</h2><p>同一个应用的所有组件都在同一个进程下，可以通过组件的<code>android:process</code>属性指定不同的进程，也可以指定<code>application</code>的这个属性为所有组件指定默认的进程</p><p>Android系统尽可能保持应用进程的运行，当内存很低时也会移除旧的进程，有五种进程状态，按重要程度排列：</p><ul><li><code>前台进程</code>   </li></ul><ol><li>进程中包含处于前台的正与用户交互的Activity</li><li>进程中包含与前台Activity绑定的Service</li><li>进程中包含调用了<code>startForeground()</code>方法的Service</li><li>进程中包含正在执行<code>onCreate()</code>, <code>onStart()</code>, 或<code>onDestroy()</code>方法的Service</li><li>进程中包含正在执行<code>onReceive()</code>方法的<code>BroadcastReceiver</code><br>系统中前台进程的数量很少, 前台进程几乎不会被杀死，只有当内存低到无法保证所有的前台进程同时运行时才会选择杀死某个前台进程（系统也差不多挂了）</li></ol><ul><li><code>可见进程</code>  </li></ul><ol><li>进程中包含未处于前台但仍然可见的Activity（调用了<code>onPause()</code>方法, 但没有调用<code>onStop()</code>方法），典型的情况是运行Activity时弹出对话框, 此时的Activity虽然不是前台Activity, 但其仍然可见</li><li>进程中包含与可见Activity绑定的Service</li></ol><ul><li><p><code>服务进程</code><br>包含已启动的Service</p></li><li><p><code>后台进程</code><br>不可见，暂停</p></li><li><p><code>空进程</code><br>不持有Activity和其他组件，当系统内存低时会被很快杀掉，空进程存在的唯一理由是为了缓存一些启动数据，以便下次可以更快的启动</p></li></ul><blockquote><p>由于服务进程的优先级高于后台进程，因此如果Activity需要执行耗时操作，最好还是启动一个Service来完成，当然在Activity中启动子线程完成耗时操作也可以，但是这样做的缺点在于，一旦Activity不再可见，Activity所在的进程成为后台进程，而内存不足时后台进程随时都有可能被系统杀死。基于同样的考虑，在BroadcastReceiver中也不应该执行耗时操作，而应该启动Service来完成(当然, BroadcastReceiver的生命周期过于短暂，也决定了不能在其中执行耗时操作)</p></blockquote><h2 id="有用的方法"><a href="#有用的方法" class="headerlink" title="有用的方法"></a>有用的方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFinishing</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>检查Activity是不是结束了，可能是你手动调用了<code>finish()</code>，也可能是其他地方请求结束<br>经常在<code>onPause()</code>中检查Acitivity只是暂停还是彻底结束</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">moveTaskToBack</span> <span class="params">(<span class="keyword">boolean</span> nonRoot)</span></span></span><br></pre></td></tr></table></figure><p>把包含此Activity的Task移动到Activity栈的后面，Task内的Activity顺序不变，<code>nonRoot</code>是<code>true</code>对所有Activity有效，<code>false</code>只对根Activity有效</p><p>测试：比如A1-&gt;A2-&gt;A3，A3调用<code>moveTaskToBack()</code>，参数为<code>true</code>时”退出”应用，实际栈维持不变，再回到应用还是一样的，参数为<code>false</code>时在这个页面无效，只在A有效</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">navigateUpTo</span> <span class="params">(Intent upIntent)</span></span></span><br></pre></td></tr></table></figure><p>类似目标Activity有<code>singleTask</code>的效果，在复杂导航的APP里可能有用<br>应该用于同Task里的向上操作，如果跨Task，参见<code>shouldUpRecreateTask()</code></p><p>测试：比如A1-&gt;A2-&gt;A3-&gt;A4，A4调用<code>navigateUpTo()</code>到A1，A2/A3/A4都会出栈，A1再按后退键就会退出应用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldUpRecreateTask</span> <span class="params">(Intent targetIntent)</span></span></span><br></pre></td></tr></table></figure><p>当向上导航时是否要重建Task</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> PendingIntent <span class="title">createPendingResult</span> <span class="params">(<span class="keyword">int</span> requestCode, Intent data, <span class="keyword">int</span> flags)</span></span></span><br></pre></td></tr></table></figure><p>创建<code>PendingIntent</code>，你能够传给其他组件，它们可以用来发送数据回来到<code>onActivityResult()</code>，可以是一次性的也可以是多次使用的</p><p>这个方法可以用来Activity与Service交互，也可以应用于跨Activity传递数据，比如A、B、C三个Activity，A打开B，B打开C，然后B自动关掉，A接收C的结果，就可以使用这种方式传递PendingIntent实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PendingIntent pendingResult = createPendingResult(<span class="number">100</span>, <span class="keyword">new</span> Intent(), <span class="number">0</span>);  </span><br><span class="line">Intent i = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, MyService.class);  </span><br><span class="line">i.putExtra(PENDING__RESULT, pendingResult);  </span><br><span class="line">startService(i);</span><br></pre></td></tr></table></figure><p>先启动一个service，PendingIntent也传过去</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PendingIntent pendingIntent = intent.getParcelableExtra(MainActivity.PENDING__RESULT);  </span><br><span class="line"><span class="keyword">try</span> &#123;  </span><br><span class="line">    pendingIntent.send(MyService.<span class="keyword">this</span>, <span class="number">101</span>, <span class="keyword">new</span> Intent().putExtra(<span class="string">"data"</span>, <span class="string">"some data"</span>));  </span><br><span class="line">&#125; <span class="keyword">catch</span> (CanceledException e) &#123;  </span><br><span class="line">    e.printStackTrace();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用<code>PendingIntent</code>的<code>send()</code>方法，发送结果给调用的Activity，让其<code>onActivityResult()</code>响应</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">finishAffinity</span> <span class="params">()</span></span></span><br></pre></td></tr></table></figure><p>可以关闭当前Activity所属的Activity栈中所有的Activity，如果所有Activity都保存在默认栈中，则使用该方法会直接退出程序</p><p>如果要回到程序的主界面，则可以在清单文件中将主界面的Activity设置为单独的栈保存，设置<code>android:taskAffinity=&quot;:[name]</code>“</p><h2 id="清空任务栈"><a href="#清空任务栈" class="headerlink" title="清空任务栈"></a>清空任务栈</h2><p>用户离开Task很长时间，系统清理Task里的除了根Activity以外的所有Activity，当用户回来，只有根Activity会恢复<br>有一些Activity属性可以用来改变这种行为</p><ul><li><code>alwaysRetainTaskState</code><br>如果根Activity的这个属性是<code>true</code>，则总是保留Activity</li><li><code>clearTaskOnLaunch</code><br>如果根<code>Activity</code>的这个属性是<code>true</code>，则总是清空Activity</li><li><code>finishOnTaskLaunch</code><br>类似<code>clearTaskOnLaunch</code>，但是不是对整个Task，而是对单个Activity</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍一些与Activity相关的小知识&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://lakeshire.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://lakeshire.github.io/tags/Android/"/>
    
      <category term="Activity" scheme="http://lakeshire.github.io/tags/Activity/"/>
    
  </entry>
  
  <entry>
    <title>EventBus总结</title>
    <link href="http://lakeshire.github.io/2017/04/11//archivers/event-bus/"/>
    <id>http://lakeshire.github.io/2017/04/11//archivers/event-bus/</id>
    <published>2017-04-11T04:00:00.000Z</published>
    <updated>2017-11-28T01:45:13.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>EventBus</code>是为Android定制的发布/订阅总线</p><p>它可以简化组件之间的通信，解耦事件发送者和接受者，可以很好的与Activity、Fragment、后台线程协同工作，避免了复杂的依赖和生命周期相关的问题</p><a id="more"></a><blockquote><p>广播稍显麻烦，并且传递对象时需要序列化</p></blockquote><p><img src="http://7xt3ho.com1.z0.glb.clouddn.com/EventBus-Publish-Subscribe.png" alt=""></p><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><h3 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h3><h4 id="自定义事件类"><a href="#自定义事件类" class="headerlink" title="自定义事件类"></a>自定义事件类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageEvent</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="注册和注销订阅者"><a href="#注册和注销订阅者" class="headerlink" title="注册和注销订阅者"></a>注册和注销订阅者</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EventBus.getDefault().register(<span class="keyword">this</span>);</span><br><span class="line">EventBus.getDefault().unregister(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><h4 id="添加处理函数"><a href="#添加处理函数" class="headerlink" title="添加处理函数"></a>添加处理函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Subscribe</span>(threadMode = ThreadMode.MAIN)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessageEvent</span><span class="params">(MessageEvent event)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>EventBus3</code>中处理函数可以任意取名，通过<code>@Subscribe</code>注解标记  </p><p><code>threadMode</code>：线程模式：</p><ul><li><code>ThreadMode.POSTING</code> 发送事件和接收事件在同一个线程</li><li><code>ThreadMode.MAIN</code> 事件处理在UI线程进行</li><li><code>ThreadMode.BACKGROUND</code> 如果是UI线程发送，则新建子线程执行，如果本身是后台线程发送，就在该线程执行</li><li><code>ThreadMode.ASYNC</code> 无论从哪个线程发送，都在新线程执行</li></ul><p><code>sticky</code>：粘性事件，表示在订阅之前发布的事件订阅后也能收到</p><p><code>priority</code>：优先级，默认为0，越大优先级越高</p><h4 id="发送事件"><a href="#发送事件" class="headerlink" title="发送事件"></a>发送事件</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventBus.getDefault().post(<span class="keyword">new</span> MessageEvent());</span><br></pre></td></tr></table></figure><p>发送粘性事件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventBus.getDefault().postSticky(<span class="keyword">new</span> MessageEvent());</span><br></pre></td></tr></table></figure><h3 id="配置注解处理器获得索引"><a href="#配置注解处理器获得索引" class="headerlink" title="配置注解处理器获得索引"></a>配置注解处理器获得索引</h3><p>修改<code>build.gradle</code></p><pre><code>buildscript {    dependencies {        classpath &apos;com.neenbedankt.gradle.plugins:android-apt:1.8&apos;    }}apply plugin: &apos;com.neenbedankt.android-apt&apos;dependencies {    apt &apos;org.greenrobot:eventbus-annotation-processor:3.0.1&apos;}apt {    arguments {        // 这个就是生成的索引类的名字        eventBusIndex &apos;com.github.lakeshire.eventbusdemo.MyEventBusIndex&apos;    }}</code></pre><p>编译期生成的类是这样的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** This class is generated by EventBus, do not edit. */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyEventBusIndex</span> <span class="keyword">implements</span> <span class="title">SubscriberInfoIndex</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, SubscriberInfo&gt; SUBSCRIBER_INDEX;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        SUBSCRIBER_INDEX = <span class="keyword">new</span> HashMap&lt;Class&lt;?&gt;, SubscriberInfo&gt;();</span><br><span class="line"></span><br><span class="line">        putIndex(<span class="keyword">new</span> SimpleSubscriberInfo(MainActivity.class, <span class="keyword">true</span>, <span class="keyword">new</span> SubscriberMethodInfo[] &#123;</span><br><span class="line">            <span class="keyword">new</span> SubscriberMethodInfo(<span class="string">"onMessageEvent"</span>, MessageEvent.class, ThreadMode.MAIN, <span class="number">100</span>, <span class="keyword">false</span>),</span><br><span class="line">            <span class="keyword">new</span> SubscriberMethodInfo(<span class="string">"onMessageEventAlt"</span>, Misc.class, ThreadMode.MAIN, <span class="number">100</span>, <span class="keyword">false</span>),</span><br><span class="line">        &#125;));</span><br><span class="line"></span><br><span class="line">        putIndex(<span class="keyword">new</span> SimpleSubscriberInfo(ReceiveActivity.class, <span class="keyword">true</span>, <span class="keyword">new</span> SubscriberMethodInfo[] &#123;</span><br><span class="line">            <span class="keyword">new</span> SubscriberMethodInfo(<span class="string">"onMessageEvent"</span>, MessageEvent.class, ThreadMode.MAIN, <span class="number">0</span>, <span class="keyword">true</span>),</span><br><span class="line">        &#125;));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">putIndex</span><span class="params">(SubscriberInfo info)</span> </span>&#123;</span><br><span class="line">        SUBSCRIBER_INDEX.put(info.getSubscriberClass(), info);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SubscriberInfo <span class="title">getSubscriberInfo</span><span class="params">(Class&lt;?&gt; subscriberClass)</span> </span>&#123;</span><br><span class="line">        SubscriberInfo info = SUBSCRIBER_INDEX.get(subscriberClass);</span><br><span class="line">        <span class="keyword">if</span> (info != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> info;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后设置默认的EventBus</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventBus.builder().addIndex(<span class="keyword">new</span> MyEventBusIndex()).installDefaultEventBus();</span><br></pre></td></tr></table></figure><p>用下来，注册时间用反射时是8ms，用索引时是2ms，再次注册是1ms，区别很明显</p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><h3 id="EventBus"><a href="#EventBus" class="headerlink" title="EventBus"></a>EventBus</h3><p>提供一个默认的单例实现，也可以通过Builder自定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  事件类型缓存</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, List&lt;Class&lt;?&gt;&gt;&gt; eventTypesCache = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//  事件类型-订阅者表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, CopyOnWriteArrayList&lt;Subscription&gt;&gt; subscriptionsByEventType;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  订阅者-事件类型表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Object, List&lt;Class&lt;?&gt;&gt;&gt; typesBySubscriber;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  粘性事件列表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, Object&gt; stickyEvents;</span><br></pre></td></tr></table></figure><p>有几个重要的数据容器</p><h4 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Object subscriber)</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt; subscriberClass = subscriber.getClass();</span><br><span class="line">    List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (SubscriberMethod subscriberMethod : subscriberMethods) &#123;</span><br><span class="line">            subscribe(subscriber, subscriberMethod);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先通过一个订阅方法查找器找到对应这个订阅者的一组方法，查找器内部会保存一份方法缓存表，如果已存在直接返回，没有的话就要实际查找，有反射和索引两种查找方式，索引在编译期通过注解处理器获得，速度要比反射快</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(Object subscriber, SubscriberMethod subscriberMethod)</span> </span>&#123;</span><br></pre></td></tr></table></figure><ol><li>查看<code>subscriptionsByEventType</code>中对应<code>EventType</code>的列表，根据优先级把新的订阅者添加进去</li><li>查看<code>typesBySubscriber</code>中对应<code>Subscriber</code>的列表，添加新的<code>EventType</code></li><li>处理粘性事件，从粘性事件列表中获取对应<code>EventType</code>的事件，做一次发送<br>这里就是发送粘性事件的时机，所以注册前发送的粘性事件再注册后可以接收到，粘性事件列表维护的是事件类型-事件（不是列表）对，发送后不会主动移除掉，所以再次注册还是会发送</li></ol><h4 id="注销"><a href="#注销" class="headerlink" title="注销"></a>注销</h4><p>就是清理<code>subscriptionsByEventType</code>和<code>typesBySubscriber</code>这两个列表</p><h4 id="发送事件-1"><a href="#发送事件-1" class="headerlink" title="发送事件"></a>发送事件</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">post</span><span class="params">(Object event)</span> </span>&#123;</span><br><span class="line">    PostingThreadState postingState = currentPostingThreadState.get();</span><br><span class="line">    List&lt;Object&gt; eventQueue = postingState.eventQueue;</span><br><span class="line">    eventQueue.add(event);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!postingState.isPosting) &#123;</span><br><span class="line">        postingState.isMainThread = Looper.getMainLooper() == Looper.myLooper();</span><br><span class="line">        postingState.isPosting = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (postingState.canceled) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Internal error. Abort state was not reset"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!eventQueue.isEmpty()) &#123;</span><br><span class="line">                postSingleEvent(eventQueue.remove(<span class="number">0</span>), postingState);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            postingState.isPosting = <span class="keyword">false</span>;</span><br><span class="line">            postingState.isMainThread = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发送是向线程本地变量里维护的队列中添加一个事件，如果没有在发送则发送队列头的事件</p><p><code>postSingleEventForEventType()</code>里在<code>subscriptionsByEventType</code>中查找对应<code>EventType</code>的订阅者，有的话就对每个订阅者发送</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postToSubscription</span><span class="params">(Subscription subscription, Object event, <span class="keyword">boolean</span> isMainThread)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (subscription.subscriberMethod.threadMode) &#123;</span><br><span class="line">        <span class="keyword">case</span> POSTING:</span><br><span class="line">            invokeSubscriber(subscription, event);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MAIN:</span><br><span class="line">            <span class="keyword">if</span> (isMainThread) &#123;</span><br><span class="line">                invokeSubscriber(subscription, event);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mainThreadPoster.enqueue(subscription, event);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> BACKGROUND:</span><br><span class="line">            <span class="keyword">if</span> (isMainThread) &#123;</span><br><span class="line">                backgroundPoster.enqueue(subscription, event);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                invokeSubscriber(subscription, event);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ASYNC:</span><br><span class="line">            asyncPoster.enqueue(subscription, event);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unknown thread mode: "</span> + subscription.subscriberMethod.threadMode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个就是发送的核心部分，根据线程模式决定做法，跟线程模式的定义匹配：</p><ul><li><code>POSTING</code>直接调用订阅者的方法</li><li><code>MAIN</code>判断是否在主线程，在主线程直接调用，否则放进主线程的消息队列</li><li><code>BACKGROUND</code>判断是否在主线程，在主线程则放进后台线程的消息队列，否则直接调用</li><li><code>ASYNC</code>直接放进后台线程的队列</li></ul><p><code>EventBus</code>内有三个<code>Handler</code>：</p><ul><li><code>mainThreadPoster</code>持有UI线程的消息循环，发消息给UI线程并在上面处理</li><li><code>backgroundPoster</code>和<code>asyncPoster</code>都是在<code>EventBus</code>内的线程池上执行</li></ul><p><code>invokeSubscriber</code>就是调用订阅方法</p><h4 id="发送粘性事件"><a href="#发送粘性事件" class="headerlink" title="发送粘性事件"></a>发送粘性事件</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postSticky</span><span class="params">(Object event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (stickyEvents) &#123;</span><br><span class="line">        stickyEvents.put(event.getClass(), event);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Should be posted after it is putted, in case the subscriber wants to remove immediately</span></span><br><span class="line">    post(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很简单，把事件设置到粘性事件列表的对应项，然后正常发送</p><h4 id="事件继承"><a href="#事件继承" class="headerlink" title="事件继承"></a>事件继承</h4><p><code>postSingleEvent()</code>中出现的代码段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (eventInheritance) &#123;</span><br><span class="line">    List&lt;Class&lt;?&gt;&gt; eventTypes = lookupAllEventTypes(eventClass);</span><br><span class="line">    <span class="keyword">int</span> countTypes = eventTypes.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> h = <span class="number">0</span>; h &lt; countTypes; h++) &#123;</span><br><span class="line">        Class&lt;?&gt; clazz = eventTypes.get(h);</span><br><span class="line">        subscriptionFound |= postSingleEventForEventType(event, postingState, clazz);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    subscriptionFound = postSingleEventForEventType(event, postingState, eventClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果支持事件继承的话，需要查找对应事件类的所有<code>EventType</code>，包括接口类和基类，然后全部发送一遍（可能某些场景有用）</p><h4 id="注解处理器"><a href="#注解处理器" class="headerlink" title="注解处理器"></a>注解处理器</h4><p>参见生成的类，就是收集所有订阅者的处理函数并结构化形成索引</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;EventBus&lt;/code&gt;是为Android定制的发布/订阅总线&lt;/p&gt;
&lt;p&gt;它可以简化组件之间的通信，解耦事件发送者和接受者，可以很好的与Activity、Fragment、后台线程协同工作，避免了复杂的依赖和生命周期相关的问题&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://lakeshire.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://lakeshire.github.io/tags/Android/"/>
    
      <category term="开源库" scheme="http://lakeshire.github.io/tags/%E5%BC%80%E6%BA%90%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>JNI初学</title>
    <link href="http://lakeshire.github.io/2017/03/22//archivers/jni-init/"/>
    <id>http://lakeshire.github.io/2017/03/22//archivers/jni-init/</id>
    <published>2017-03-22T04:00:00.000Z</published>
    <updated>2017-11-28T03:12:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>JNI是<code>Java Native Interface</code>的缩写，它提供了若干的API实现了Java和其他语言的通信（主要是C/C++）</p><a id="more"></a><p>参考<a href="http://www.cnblogs.com/icejoywoo/archive/2012/02/24/2367116.html" target="_blank" rel="noopener">使用JNI进行Java与C/C++语言混合编程</a></p><h2 id="JNI"><a href="#JNI" class="headerlink" title="JNI"></a>JNI</h2><p>JNI（Java Native Interface，Java本地接口），用于打通Java层与Native(C/C++)层。这不是Android系统所独有的，而是Java所有。众所周知，Java语言是跨平台的语言，而这跨平台的背后都是依靠Java虚拟机，虚拟机采用C/C++编写，适配各个系统，通过JNI为上层Java提供各种服务，保证跨平台性。</p><h3 id="JNI注册"><a href="#JNI注册" class="headerlink" title="JNI注册"></a>JNI注册</h3><p>Android系统在启动过程中，先启动Kernel创建init进程，紧接着由init进程fork第一个横穿Java和C/C++的进程，即<code>Zygote</code>进程。Zygote启动过程中会AndroidRuntime.cpp中的<code>startVm</code>创建虚拟机，VM创建完成后，紧接着调用<code>startReg</code>完成虚拟机中的JNI方法注册。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> AndroidRuntime::startReg(JNIEnv* env) &#123;</span><br><span class="line">    androidSetCreateThreadFunc((android_create_thread_fn) javaCreateThreadEtc);</span><br><span class="line">    env-&gt;PushLocalFrame(<span class="number">200</span>);</span><br><span class="line">    <span class="keyword">if</span> (register_jni_procs(gRegJNI, NELEM(gRegJNI), env) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        env-&gt;PopLocalFrame(NULL);</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    env-&gt;PopLocalFrame(NULL);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">register_jni_procs</span><span class="params">(<span class="keyword">const</span> RegJNIRec array[], size_t count, JNIEnv* env)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array[i].mProc(env) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  该数组的每个成员都代表一个类文件的JNI映射，其中REG_JNI是一个宏定义，该宏的作用就是调用相应的方法</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> RegJNIRec gRegJNI[] = &#123;</span><br><span class="line">    REG_JNI(register_android_os_MessageQueue),</span><br><span class="line">    REG_JNI(register_android_os_Binder),</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="JNI查找"><a href="#JNI查找" class="headerlink" title="JNI查找"></a>JNI查找</h3><h4 id="系统方法"><a href="#系统方法" class="headerlink" title="系统方法"></a>系统方法</h4><p>以<code>MessageQueue</code>为例：</p><ul><li><code>android.os.MessageQueue.nativePollOnce</code>的本地方法是<code>android_os_MessageQueue_nativePollOnce</code></li><li><code>MessageQueue</code>对应的注册方法是<code>register_android_os_MessageQueue</code>，存在于<code>gRegJNI</code>数组中，在启动时就完成了注册</li><li>对应的本地文件是<code>android_os_MessageQueue.cpp</code></li></ul><h4 id="自定义方法"><a href="#自定义方法" class="headerlink" title="自定义方法"></a>自定义方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MediaPlayer</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.loadLibrary(<span class="string">"media_jni"</span>);</span><br><span class="line">        native_init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">native_init</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过static静态代码块中<code>System.loadLibrary</code>方法来加载动态库，库名为<code>media_jni</code>, Android平台则会自动扩展成所对应的<code>libmedia_jni.so</code>库</p><p>一般都是通过Android.mk文件定义<code>LOCAL_MODULE:= libmedia_jni</code></p><h3 id="JNI原理"><a href="#JNI原理" class="headerlink" title="JNI原理"></a>JNI原理</h3><p>System.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loadLibrary</span><span class="params">(String libName)</span> </span>&#123;</span><br><span class="line">    Runtime.getRuntime().loadLibrary(libName, VMStack.getCallingClassLoader());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Runtime.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loadLibrary</span><span class="params">(String libraryName, ClassLoader loader)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (loader != <span class="keyword">null</span>) &#123;</span><br><span class="line">        String filename = loader.findLibrary(libraryName);</span><br><span class="line">        <span class="keyword">if</span> (filename == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnsatisfiedLinkError(loader + <span class="string">" couldn't find \""</span> + System.mapLibraryName(libraryName) + <span class="string">"\""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        String error = doLoad(filename, loader);</span><br><span class="line">        <span class="keyword">if</span> (error != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnsatisfiedLinkError(error);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String filename = System.mapLibraryName(libraryName);</span><br><span class="line">    List&lt;String&gt; candidates = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    String lastError = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (String directory : mLibPaths) &#123;</span><br><span class="line">        String candidate = directory + filename;</span><br><span class="line">        candidates.add(candidate);</span><br><span class="line">        <span class="keyword">if</span> (IoUtils.canOpenReadOnly(candidate)) &#123;</span><br><span class="line">            String error = doLoad(candidate, loader);</span><br><span class="line">            <span class="keyword">if</span> (error == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            lastError = error;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (lastError != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsatisfiedLinkError(lastError);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsatisfiedLinkError(<span class="string">"Library "</span> + libraryName + <span class="string">" not found; tried "</span> + candidates);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">doLoad</span><span class="params">(String name, ClassLoader loader)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> nativeLoad(name, loader, ldLibraryPath);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用本地方法<code>nativeLoad</code>，其中会调用<code>dlopen</code>函数，打开一个so文件并创建一个handle；调用<code>dlsym</code>函数，查看相应so文件的<code>JNI_OnLoad()</code>函数指针，并执行相应函数。</p><p>android_media_MediaPlayer.cpp</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">jint <span class="title">JNI_OnLoad</span><span class="params">(JavaVM* vm, <span class="keyword">void</span>* reserved)</span> </span>&#123;</span><br><span class="line">    JNIEnv* env = NULL;</span><br><span class="line">    <span class="keyword">if</span> (register_android_media_MediaPlayer(env) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        goto bail;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">register_android_media_MediaPlayer</span><span class="params">(JNIEnv *env)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> AndroidRuntime::registerNativeMethods(env, <span class="string">"android/media/MediaPlayer"</span>, gMethods, NELEM(gMethods));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  gMethods，记录Java层和C/C++层方法的一一映射关系</span></span><br><span class="line"><span class="keyword">static</span> JNINativeMethod gMethods[] = &#123;</span><br><span class="line">    &#123;<span class="string">"prepare"</span>,      <span class="string">"()V"</span>,  (<span class="keyword">void</span> *)android_media_MediaPlayer_prepare&#125;,</span><br><span class="line">    &#123;<span class="string">"_start"</span>,       <span class="string">"()V"</span>,  (<span class="keyword">void</span> *)android_media_MediaPlayer_start&#125;,</span><br><span class="line">    &#123;<span class="string">"_stop"</span>,        <span class="string">"()V"</span>,  (<span class="keyword">void</span> *)android_media_MediaPlayer_stop&#125;,</span><br><span class="line">    &#123;<span class="string">"seekTo"</span>,       <span class="string">"(I)V"</span>, (<span class="keyword">void</span> *)android_media_MediaPlayer_seekTo&#125;,</span><br><span class="line">    &#123;<span class="string">"_release"</span>,     <span class="string">"()V"</span>,  (<span class="keyword">void</span> *)android_media_MediaPlayer_release&#125;,</span><br><span class="line">    &#123;<span class="string">"native_init"</span>,  <span class="string">"()V"</span>,  (<span class="keyword">void</span> *)android_media_MediaPlayer_native_init&#125;,</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>jni.h</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    <span class="comment">//  Java层native函数名</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* name; </span><br><span class="line">    <span class="comment">//  Java函数签名，记录参数类型和个数，以及返回值类型</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* signature;</span><br><span class="line">    <span class="comment">//  Native层对应的函数指针</span></span><br><span class="line">    <span class="keyword">void</span>* fnPtr; </span><br><span class="line">&#125; JNINativeMethod;</span><br></pre></td></tr></table></figure><p>AndroidRuntime.cpp</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> AndroidRuntime::registerNativeMethods(JNIEnv* env, <span class="keyword">const</span> <span class="keyword">char</span>* className, <span class="keyword">const</span> JNINativeMethod* gMethods, <span class="keyword">int</span> numMethods) &#123;</span><br><span class="line">    <span class="keyword">return</span> jniRegisterNativeMethods(env, className, gMethods, numMethods);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JNIHelper.cpp</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">extern <span class="string">"C"</span> <span class="function"><span class="keyword">int</span> <span class="title">jniRegisterNativeMethods</span><span class="params">(C_JNIEnv* env, <span class="keyword">const</span> <span class="keyword">char</span>* className, <span class="keyword">const</span> JNINativeMethod* gMethods, <span class="keyword">int</span> numMethods)</span> </span>&#123;</span><br><span class="line">    JNIEnv* e = reinterpret_cast&lt;JNIEnv*&gt;(env);</span><br><span class="line">    <span class="function">scoped_local_ref&lt;jclass&gt; <span class="title">c</span><span class="params">(env, findClass(env, className)</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span> (c.get() == NULL) &#123;</span><br><span class="line">        e-&gt;FatalError(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((*env)-&gt;RegisterNatives(e, c.get(), gMethods, numMethods) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        e-&gt;FatalError(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>jni.h</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct _JNIEnv &#123;</span><br><span class="line">    <span class="keyword">const</span> struct JNINativeInterface* functions;</span><br><span class="line"></span><br><span class="line">    <span class="function">jint <span class="title">RegisterNatives</span><span class="params">(jclass clazz, <span class="keyword">const</span> JNINativeMethod* methods, jint nMethods)</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> functions-&gt;RegisterNatives(<span class="keyword">this</span>, clazz, methods, nMethods); &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虚拟机相关的变量中有两个非常重要的量<code>JavaVM</code>和<code>JNIEnv</code><br><code>JavaVM</code>是指进程虚拟机环境，每个进程有且只有一个JavaVM实例<br><code>JNIEnv</code>是指线程上下文环境，每个线程有且只有一个JNIEnv实例</p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><h4 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h4><table><thead><tr><th style="text-align:center">Signature格式</th><th style="text-align:center">Java</th><th style="text-align:left">Native</th></tr></thead><tbody><tr><td style="text-align:center">B</td><td style="text-align:center">byte</td><td style="text-align:left">jbyte</td></tr><tr><td style="text-align:center">C</td><td style="text-align:center">char</td><td style="text-align:left">jchar</td></tr><tr><td style="text-align:center">D</td><td style="text-align:center">double</td><td style="text-align:left">jdouble</td></tr><tr><td style="text-align:center">F</td><td style="text-align:center">float</td><td style="text-align:left">jfloat</td></tr><tr><td style="text-align:center">I</td><td style="text-align:center">int</td><td style="text-align:left">jint</td></tr><tr><td style="text-align:center">S</td><td style="text-align:center">short</td><td style="text-align:left">jshort</td></tr><tr><td style="text-align:center">J</td><td style="text-align:center">long</td><td style="text-align:left">jlong</td></tr><tr><td style="text-align:center">Z</td><td style="text-align:center">boolean</td><td style="text-align:left">jboolean</td></tr><tr><td style="text-align:center">V</td><td style="text-align:center">void</td><td style="text-align:left">void</td></tr></tbody></table><h4 id="数组数据类型"><a href="#数组数据类型" class="headerlink" title="数组数据类型"></a>数组数据类型</h4><table><thead><tr><th style="text-align:center">Signature格式</th><th style="text-align:center">Java</th><th style="text-align:center">Native</th></tr></thead><tbody><tr><td style="text-align:center">[B</td><td style="text-align:center">byte[]</td><td style="text-align:center">jbyteArray</td></tr><tr><td style="text-align:center">[C</td><td style="text-align:center">char[]</td><td style="text-align:center">jcharArray</td></tr><tr><td style="text-align:center">[D</td><td style="text-align:center">double[]</td><td style="text-align:center">jdoubleArray</td></tr><tr><td style="text-align:center">[F</td><td style="text-align:center">float[]</td><td style="text-align:center">jfloatArray</td></tr><tr><td style="text-align:center">[I</td><td style="text-align:center">int[]</td><td style="text-align:center">jintArray</td></tr><tr><td style="text-align:center">[S</td><td style="text-align:center">short[]</td><td style="text-align:center">jshortArray</td></tr><tr><td style="text-align:center">[J</td><td style="text-align:center">long[]</td><td style="text-align:center">jlongArray</td></tr><tr><td style="text-align:center">[Z</td><td style="text-align:center">boolean[]</td><td style="text-align:center">jbooleanArray</td></tr></tbody></table><h4 id="复杂数据类型"><a href="#复杂数据类型" class="headerlink" title="复杂数据类型"></a>复杂数据类型</h4><table><thead><tr><th style="text-align:center">Signature格式</th><th style="text-align:center">Java</th><th style="text-align:center">Native</th></tr></thead><tbody><tr><td style="text-align:center">Ljava/lang/String;</td><td style="text-align:center">String</td><td style="text-align:center">jstring</td></tr><tr><td style="text-align:center">L+classname +;</td><td style="text-align:center">所有对象</td><td style="text-align:center">jobject</td></tr><tr><td style="text-align:center">[L+classname +;</td><td style="text-align:center">Object[]</td><td style="text-align:center">jobjectArray</td></tr><tr><td style="text-align:center">Ljava.lang.Class;</td><td style="text-align:center">Class</td><td style="text-align:center">jclass</td></tr><tr><td style="text-align:center">Ljava.lang.Throwable;</td><td style="text-align:center">Throwable</td><td style="text-align:center">jthrowable</td></tr></tbody></table><h4 id="签名实例"><a href="#签名实例" class="headerlink" title="签名实例"></a>签名实例</h4><table><thead><tr><th style="text-align:center">Java函数</th><th style="text-align:center">对应的签名</th></tr></thead><tbody><tr><td style="text-align:center">void foo()</td><td style="text-align:center">()V</td></tr><tr><td style="text-align:center">float foo(int i)</td><td style="text-align:center">(I)F</td></tr><tr><td style="text-align:center">long foo(int[] i)</td><td style="text-align:center">([I)J</td></tr><tr><td style="text-align:center">double foo(Class c)</td><td style="text-align:center">(Ljava/lang/Class;)D</td></tr><tr><td style="text-align:center">boolean foo(int[] i,String s)</td><td style="text-align:center">([ILjava/lang/String;)Z</td></tr><tr><td style="text-align:center">String foo(int i)</td><td style="text-align:center">(I)Ljava/lang/String;</td></tr></tbody></table><h2 id="Java调用C-C"><a href="#Java调用C-C" class="headerlink" title="Java调用C/C++"></a>Java调用C/C++</h2><ul><li><p>新建一个<code>Sample.java</code>源文件</p></li><li><p>获得<code>Sample.class</code>类文件</p></li></ul><pre><code>javac Sample.java</code></pre><ul><li>获得头文件</li></ul><pre><code>javah Sample</code></pre><ul><li>通过C或者C++来实现这些函数，然后生成<code>dll</code>或者<code>so</code>，在mac上，需要生成<code>libSample.jnilib</code></li></ul><pre><code>gcc -I$JAVA_HOME/include -I$JAVA_HOME/include/darwin -c Sample.c  gcc -dynamiclib -o libSample.jnilib Samplie.o</code></pre><ul><li>运行</li></ul><pre><code>java Sample</code></pre><p>Sample.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">JNIEXPORT jint JNICALL Java_Sample_intMethod</span><br><span class="line">  (JNIEnv *env, jobject obj, jint num)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> num * num;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">JNIEXPORT jboolean JNICALL Java_Sample_booleanMethod</span><br><span class="line">  (JNIEnv *env, jobject obj, jboolean boolean)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> !boolean;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">JNIEXPORT jstring JNICALL Java_Sample_stringMethod</span><br><span class="line">  (JNIEnv *env, jobject obj, jstring <span class="built_in">string</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* str = (*env)-&gt;GetStringUTFChars(env, <span class="built_in">string</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">char</span> cap[<span class="number">128</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(cap, str);</span><br><span class="line">    (*env)-&gt;ReleaseStringUTFChars(env, <span class="built_in">string</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> (*env)-&gt;NewStringUTF(env, strupr(cap));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">JNIEXPORT jint JNICALL Java_Sample_intArrayMethod</span><br><span class="line">  (JNIEnv *env, jobject obj, jintArray <span class="built_in">array</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i, sum = <span class="number">0</span>;</span><br><span class="line">    jsize len = (*env)-&gt;GetArrayLength(env, <span class="built_in">array</span>);</span><br><span class="line">    jint *body = (*env)-&gt;GetIntArrayElements(env, <span class="built_in">array</span>, <span class="number">0</span>);</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += body[i];</span><br><span class="line">    &#125;</span><br><span class="line">    (*env)-&gt;ReleaseIntArrayElements(env, <span class="built_in">array</span>, body, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>(*env)-&gt;GetStringUTFChars()</code>这个方法，是用来在Java和C之间转换字符串的，因为Java本身都使用了双字节的字符， 而C语言本身都是单字节的字符，所以需要进行转换</p><p><code>JNIEnv*</code>是每个函数都有的参数, 它包含了很多有用的方法， 使用起来类似Java的反射，也提供了这样一个编码转换的函数</p><p><code>GetStringUTFChars()</code>和<code>NewStringUTF()</code>， 第一个是从UTF8转换为C的编码格式， 第二个是根据C的字符串返回一个UTF8字符串</p><p><code>ReleaseStringUTFChars()</code>是用来释放对象的， 在Java中有虚拟机进行垃圾回收，但是在C语言中，这些对象必须手动回收，否则可能造成内存泄漏</p><h2 id="C-C-调用Java"><a href="#C-C-调用Java" class="headerlink" title="C/C++调用Java"></a>C/C++调用Java</h2><p>Sample.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello, "</span> + name + <span class="string">"!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello, "</span> + name + <span class="string">"!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SampleTest.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;jni.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 环境变量PATH在windows下和linux下的分割符定义</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _WIN32</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PATH_SEPARATOR <span class="meta-string">';'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PATH_SEPARATOR <span class="meta-string">':'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    JavaVMOption options[<span class="number">1</span>];</span><br><span class="line">    JNIEnv *env;</span><br><span class="line">    JavaVM *jvm;</span><br><span class="line">    JavaVMInitArgs vm_args;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">long</span> status;</span><br><span class="line">    jclass cls;</span><br><span class="line">    jmethodID mid;</span><br><span class="line">    jfieldID fid;</span><br><span class="line">    jobject obj;</span><br><span class="line">     </span><br><span class="line">    options[<span class="number">0</span>].optionString = <span class="string">"-Djava.class.path=."</span>;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;vm_args, <span class="number">0</span>, <span class="keyword">sizeof</span>(vm_args));</span><br><span class="line">    vm_args.version = JNI_VERSION_1_4;</span><br><span class="line">    vm_args.nOptions = <span class="number">1</span>;</span><br><span class="line">    vm_args.options = options;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// 启动虚拟机</span></span><br><span class="line">    status = JNI_CreateJavaVM(&amp;jvm, (<span class="keyword">void</span>**)&amp;env, &amp;vm_args);</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span> (status != JNI_ERR) &#123;</span><br><span class="line">        <span class="comment">// 先获得class对象</span></span><br><span class="line">        cls = (*env)-&gt;FindClass(env, <span class="string">"Sample2"</span>);</span><br><span class="line">        <span class="keyword">if</span> (cls != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取方法ID, 通过方法名和签名, 调用静态方法</span></span><br><span class="line">            mid = (*env)-&gt;GetStaticMethodID(env, cls, <span class="string">"sayHello"</span>, <span class="string">"(Ljava/lang/String;)Ljava/lang/String;"</span>);</span><br><span class="line">            <span class="keyword">if</span> (mid != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">char</span>* name = <span class="string">"World"</span>;</span><br><span class="line">                jstring arg = (*env)-&gt;NewStringUTF(env, name);</span><br><span class="line">                jstring result = (jstring)(*env)-&gt;CallStaticObjectMethod(env, cls, mid, arg);</span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">char</span>* str = (*env)-&gt;GetStringUTFChars(env, result, <span class="number">0</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Result of sayHello: %s\n"</span>, str);</span><br><span class="line">                (*env)-&gt;ReleaseStringUTFChars(env, result, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">             </span><br><span class="line">            <span class="comment">// 调用指定的构造函数, 构造函数的名字叫做&lt;init&gt;</span></span><br><span class="line">            mid = (*env)-&gt;GetMethodID(env, cls, <span class="string">"&lt;init&gt;"</span>, <span class="string">"()V"</span>);</span><br><span class="line">            obj = (*env)-&gt;NewObject(env, cls, mid);</span><br><span class="line">            <span class="keyword">if</span> (obj == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Create object failed!\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取属性ID, 通过属性名和签名</span></span><br><span class="line">            fid = (*env)-&gt;GetFieldID(env, cls, <span class="string">"name"</span>, <span class="string">"Ljava/lang/String;"</span>);</span><br><span class="line">            <span class="keyword">if</span> (fid != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">char</span>* name = <span class="string">"Tom"</span>;</span><br><span class="line">                jstring arg = (*env)-&gt;NewStringUTF(env, name);</span><br><span class="line">                (*env)-&gt;SetObjectField(env, obj, fid, arg); <span class="comment">// 修改属性</span></span><br><span class="line">            &#125;</span><br><span class="line">             </span><br><span class="line">            <span class="comment">// 调用成员方法</span></span><br><span class="line">            mid = (*env)-&gt;GetMethodID(env, cls, <span class="string">"sayHello"</span>, <span class="string">"()Ljava/lang/String;"</span>);</span><br><span class="line">            <span class="keyword">if</span> (mid != <span class="number">0</span>) &#123;</span><br><span class="line">                jstring result = (jstring)(*env)-&gt;CallObjectMethod(env, obj, mid);</span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">char</span>* str = (*env)-&gt;GetStringUTFChars(env, result, <span class="number">0</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Result of sayHello: %s\n"</span>, str);</span><br><span class="line">                (*env)-&gt;ReleaseStringUTFChars(env, result, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        (*jvm)-&gt;DestroyJavaVM(jvm);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"JVM Created failed!\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码比较好理解，做了这些事：</p><ul><li>创建虚拟机JVM, 在程序结束的时候销毁虚拟机JVM</li><li>寻找class对象</li><li>创建class对象的实例</li><li>调用方法和修改属性</li></ul><p><code>JavaVM</code>就是我们需要创建的虚拟机实例<br><code>JavaVMOption</code>相当于在命令行里传入的参数<br><code>JNIEnv</code>在Java调用C/C++中每个方法都会有的一个参数, 拥有一个JNI的环境<br><code>JavaVMInitArgs</code>就是虚拟机创建的初始化参数，这个参数里面会包含JavaVMOption</p><blockquote><p>在MAC下用<code>gcc</code>编译遇到找不到JVM库的问题，还不知道怎么解决</p></blockquote><h2 id="AIDL"><a href="#AIDL" class="headerlink" title="AIDL"></a>AIDL</h2><p><code>AIDL（Android 接口定义语言）</code>与您可能使用过的其他IDL类似。 您可以利用它定义客户端与服务使用进程间通信(IPC)进行相互通信时都认可的编程接口。 在Android上，一个进程通常无法访问另一个进程的内存。 尽管如此，进程需要将其对象分解成操作系统能够识别的原语，并将对象编组成跨越边界的对象。编写执行这一编组操作的代码是一项繁琐的工作，因此Android会使用AIDL来处理。</p><blockquote><p>只有允许不同应用的客户端用IPC 方式访问服务，并且想要在服务中处理多线程时，才有必要使用AIDL。 如果您不需要执行跨越不同应用的并发IPC，就应该通过实现一个<code>Binder</code>创建接口；或者，如果您想执行IPC，但根本不需要处理多线程，则使用<code>Messenger</code>类来实现接口。无论如何，在实现AIDL之前，请您务必理解绑定服务。</p></blockquote><h3 id="定义AIDL接口"><a href="#定义AIDL接口" class="headerlink" title="定义AIDL接口"></a>定义AIDL接口</h3><p>您必须使用Java编程语言语法在<code>.aidl</code>文件中定义AIDL接口，然后将它保存在托管服务的应用以及任何其他绑定到服务的应用的源代码内。</p><p>您开发每个包含.aidl文件的应用时，Android SDK工具都会生成一个基于该.aidl文件的<code>IBinder</code>接口，并将其保存在项目的<code>gen/</code>目录中。服务必须视情况实现<code>IBinder</code>接口。然后客户端应用便可绑定到该服务，并调用<code>IBinder</code>中的方法来执行IPC。</p><p>如需使用 AIDL 创建绑定服务，请执行以下步骤：</p><ol><li>创建 .aidl 文件<br>此文件定义带有方法签名的编程接口。</li><li>实现接口<br>Android SDK工具基于您的.aidl文件，使用Java编程语言生成一个接口。此接口具有一个名为<code>Stub</code>的内部抽象类，用于扩展<code>Binder</code>类并实现AIDL接口中的方法。您必须扩展<code>Stub</code>类并实现方法。</li><li>向客户端公开该接口<br>实现<code>Service</code>并重写<code>onBind()</code>以返回Stub类的实现。</li></ol><h4 id="创建AIDL文件"><a href="#创建AIDL文件" class="headerlink" title="创建AIDL文件"></a>创建AIDL文件</h4><p>AIDL使用简单语法，使您能通过可带参数和返回值的一个或多个方法来声明接口。 参数和返回值可以是任意类型，甚至可以是其他AIDL生成的接口。</p><p>您必须使用Java编程语言构建.aidl文件。每个.aidl文件都必须定义单个接口，并且只需包含接口声明和方法签名。</p><p>默认情况下，AIDL支持下列数据类型：</p><ul><li>Java编程语言中的所有原语类型（如<code>int</code>、<code>long</code>、<code>char</code>、<code>boolean</code> 等等）</li><li><code>String</code></li><li><code>CharSequence</code></li><li><code>List</code><br><code>List</code>中的所有元素都必须是以上列表中支持的数据类型、其他AIDL生成的接口或您声明的可打包类型。可选择将<code>List</code>用作通用类（例如，<code>List&lt;String&gt;</code>）。另一端实际接收的具体类始终是<code>ArrayList</code>，但生成的方法使用的是<code>List</code>接口。</li><li><code>Map</code><br><code>Map</code>中的所有元素都必须是以上列表中支持的数据类型、其他AIDL生成的接口或您声明的可打包类型。不支持通用<code>Map</code>（如<code>Map&lt;String,Integer&gt;</code>形式的<code>Map</code>）。另一端实际接收的具体类始终是<code>HashMap</code>，但生成的方法使用的是<code>Map</code>接口。</li></ul><p>您必须为以上未列出的每个附加类型加入一个import语句，即使这些类型是在与您的接口相同的软件包中定义。</p><p>定义服务接口时，请注意：</p><ul><li>方法可带零个或多个参数，返回值或空值。</li><li>所有非原语参数都需要指示数据走向的方向标记。可以是<code>in</code>、<code>out</code>或<code>inout</code>。原语默认为<code>in</code>，不能是其他方向。<blockquote><p>注意：您应该将方向限定为真正需要的方向，因为编组参数的开销极大。</p></blockquote></li><li>.aidl 文件中包括的所有代码注释都包含在生成的<code>IBinder接口中</code>（import 和 package 语句之前的注释除外）</li><li>只支持方法；您不能公开AIDL中的静态字段。</li></ul><p>示例aidl文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.android;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IRemoteService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getPid</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">basicTypes</span><span class="params">(<span class="keyword">int</span> anInt, <span class="keyword">long</span> aLong, <span class="keyword">boolean</span> aBoolean, <span class="keyword">float</span> aFloat, <span class="keyword">double</span> aDouble, String aString)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h4><p>示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> IRemoteService.Stub mBinder = <span class="keyword">new</span> IRemoteService.Stub() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPid</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Process.myPid();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">basicTypes</span><span class="params">(<span class="keyword">int</span> anInt, <span class="keyword">long</span> aLong, <span class="keyword">boolean</span> aBoolean, <span class="keyword">float</span> aFloat, <span class="keyword">double</span> aDouble, String aString)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在实现 AIDL 接口时应注意遵守以下这几个规则：</p><ul><li>由于不能保证在主线程上执行传入调用，因此您一开始就需要做好多线程处理准备，并将您的服务正确地编译为线程安全服务。</li><li>默认情况下，RPC调用是同步调用。如果您明知服务完成请求的时间不止几毫秒，就不应该从Activity的主线程调用服务，因为这样做可能会使应用挂起。您通常应该从客户端内的单独线程调用服务。</li><li>您引发的任何异常都不会回传给调用方。</li></ul><h4 id="向客户端公开接口"><a href="#向客户端公开接口" class="headerlink" title="向客户端公开接口"></a>向客户端公开接口</h4><p>示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoteService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mBinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> IRemoteService.Stub mBinder = <span class="keyword">new</span> IRemoteService.Stub() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPid</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Process.myPid();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">basicTypes</span><span class="params">(<span class="keyword">int</span> anInt, <span class="keyword">long</span> aLong, <span class="keyword">boolean</span> aBoolean, <span class="keyword">float</span> aFloat, <span class="keyword">double</span> aDouble, String aString)</span> </span>&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当客户端（如Activity）调用<code>bindService()</code>以连接此服务时，客户端的<code>onServiceConnected()</code>回调会接收服务的<code>onBind()</code>方法返回的mBinder实例。</p><p>客户端还必须具有对接口类的访问权限，因此如果客户端和服务在不同的应用内，则客户端的应用<code>src/</code> 目录内必须包含.aidl文件（它生成 <code>android.os.Binder</code>接口 — 为客户端提供对AIDL方法的访问权限）的副本。</p><p>当客户端在<code>onServiceConnected()</code>回调中收到IBinder时，它必须调用<code>asInterface(service)</code>以将返回的参数转换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">IRemoteService mIRemoteService;</span><br><span class="line"><span class="keyword">private</span> ServiceConnection mConnection = <span class="keyword">new</span> ServiceConnection() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName className, IBinder service)</span> </span>&#123;</span><br><span class="line">        mIRemoteService = IRemoteService.Stub.asInterface(service);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName className)</span> </span>&#123;</span><br><span class="line">        mIRemoteService = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="通过IPC传递对象"><a href="#通过IPC传递对象" class="headerlink" title="通过IPC传递对象"></a>通过IPC传递对象</h3><p>通过IPC接口把某个类从一个进程发送到另一个进程是可以实现的。不过，您必须确保该类的代码对IPC通道的另一端可用，并且该类必须支持<code>Parcelable</code>接口。支持<code>Parcelable</code>接口很重要，因为Android系统可通过它将对象分解成可编组到各进程的原语。</p><p>如需创建支持<code>Parcelable</code>协议的类，您必须执行以下操作：</p><ul><li>让您的类实现<code>Parcelable</code>接口  </li><li>实现<code>writeToParcel</code>，它会获取对象的当前状态并将其写入Parcel。</li><li>为您的类添加一个名为<code>CREATOR</code>的静态字段，这个字段是一个实现<code>Parcelable.Creator</code>接口的对象。</li><li>最后，创建一个声明可打包类的.aidl 文件<br>如果您使用的是自定义编译进程，切勿在您的编译中添加.aidl文件。 此.aidl文件与C语言中的头文件类似，并未编译。<br>AIDL在它生成的代码中使用这些方法和字段将您的对象编组和取消编组。</li></ul><p>Rect.aidl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> android.graphics;</span><br><span class="line"></span><br><span class="line">parcelable Rect;</span><br></pre></td></tr></table></figure><p>Rect.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> android.os.Parcel;</span><br><span class="line"><span class="keyword">import</span> android.os.Parcelable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Rect</span> <span class="keyword">implements</span> <span class="title">Parcelable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> left;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> top;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> right;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> bottom;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Parcelable.Creator&lt;Rect&gt; CREATOR = <span class="keyword">new</span></span><br><span class="line">Parcelable.Creator&lt;Rect&gt;() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Rect <span class="title">createFromParcel</span><span class="params">(Parcel in)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Rect(in);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Rect[] newArray(<span class="keyword">int</span> size) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Rect[size];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Rect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Rect</span><span class="params">(Parcel in)</span> </span>&#123;</span><br><span class="line">        readFromParcel(in);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeToParcel</span><span class="params">(Parcel out)</span> </span>&#123;</span><br><span class="line">        out.writeInt(left);</span><br><span class="line">        out.writeInt(top);</span><br><span class="line">        out.writeInt(right);</span><br><span class="line">        out.writeInt(bottom);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFromParcel</span><span class="params">(Parcel in)</span> </span>&#123;</span><br><span class="line">        left = in.readInt();</span><br><span class="line">        top = in.readInt();</span><br><span class="line">        right = in.readInt();</span><br><span class="line">        bottom = in.readInt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="调用IPC方法"><a href="#调用IPC方法" class="headerlink" title="调用IPC方法"></a>调用IPC方法</h3><p>调用类必须执行以下步骤，才能调用使用AIDL定义的远程接口：</p><ul><li>在项目<code>src/</code>目录中加入.aidl文件</li><li>声明一个<code>IBinder</code>接口实例（基于AIDL生成）</li><li>实现<code>ServiceConnection</code></li><li>调用<code>Context.bindService()</code>，以传入您的<code>ServiceConnection</code>实现</li><li>在您的<code>onServiceConnected()</code>实现中，您将收到一个<code>IBinder实例</code>（名为 <code>service</code>）。调用<code>asInterface((IBinder)service)</code>，以将返回的参数转换类型</li><li>调用您在接口上定义的方法。您应该始终捕获<code>DeadObjectException</code>异常，它们是在连接中断时引发的；这将是远程方法引发的唯一异常。</li><li>如需断开连接，请使用您的接口实例调用<code>Context.unbindService()</code>。</li></ul><p>有关调用IPC服务的几点说明：</p><ul><li>对象是跨进程计数的引用</li><li>您可以将匿名对象作为方法参数发送</li></ul><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ol><li><p>传递对象<br>.aidl文件和实现文件都放在系统创建的<code>aidl</code>目录下，编译时可能出现找不到符号的问题，需要对<code>build.gradle</code>做修改，增加源码集</p><pre><code>sourceSets {    main {        java.srcDirs = [&apos;src/main/java&apos;, &apos;src/main/aidl&apos;]    }}</code></pre></li></ol><p>另外注意要指定对象的<code>in</code>/<code>out</code>/<code>inout</code>类型，否则会报错</p><ol><li>绑定远程服务<br>可能出现服务必须为显示调用的错误，这样解决，通过指定包名</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">intent.setAction(<span class="string">"android.intent.action.RemoteService"</span>);</span><br><span class="line">intent.setPackage(<span class="string">"lakeshire.gitlab.com.aidlserver"</span>);</span><br><span class="line">bindService(intent, mConnectionRemote, Context.BIND_AUTO_CREATE);</span><br></pre></td></tr></table></figure><p>服务端的AndroidManifest.xml注册一下这个服务</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;service android:name=<span class="string">".RemoteService"</span> android:exported=<span class="string">"true"</span>&gt;</span><br><span class="line">    &lt;intent-filter&gt;</span><br><span class="line">        &lt;action android:name=<span class="string">"android.intent.action.RemoteService"</span> /&gt;</span><br><span class="line">        &lt;category android:name=<span class="string">"android.intent.category.DEFAULT"</span> /&gt;</span><br><span class="line">    &lt;/intent-filter&gt;</span><br><span class="line">&lt;/service&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JNI是&lt;code&gt;Java Native Interface&lt;/code&gt;的缩写，它提供了若干的API实现了Java和其他语言的通信（主要是C/C++）&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://lakeshire.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://lakeshire.github.io/tags/Android/"/>
    
      <category term="JNI" scheme="http://lakeshire.github.io/tags/JNI/"/>
    
      <category term="C/C++" scheme="http://lakeshire.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>Git相关</title>
    <link href="http://lakeshire.github.io/2017/03/20//archivers/git-related/"/>
    <id>http://lakeshire.github.io/2017/03/20//archivers/git-related/</id>
    <published>2017-03-20T04:00:00.000Z</published>
    <updated>2017-11-28T03:12:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>Git是目前世界上最先进的分布式版本控制系统</p><a id="more"></a><p>参考<a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">Git教程</a></p><h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><p>Git是目前世界上最先进的分布式版本控制系统</p><h2 id="版本管理"><a href="#版本管理" class="headerlink" title="版本管理"></a>版本管理</h2><h3 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h3><p>选择一个空目录</p><pre><code>git init</code></pre><h3 id="添加文件"><a href="#添加文件" class="headerlink" title="添加文件"></a>添加文件</h3><pre><code>git add [filename]</code></pre><p>将文件修改从工作区添加到暂存区</p><h3 id="提交修改"><a href="#提交修改" class="headerlink" title="提交修改"></a>提交修改</h3><pre><code>git commit -m [filename]</code></pre><p>将文件修改从暂存区提交到当前分支</p><h3 id="版本历史"><a href="#版本历史" class="headerlink" title="版本历史"></a>版本历史</h3><pre><code>git log --pretty=oneline</code></pre><h3 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h3><pre><code>git reset --hard HEAD^</code></pre><p><code>HEAD</code>表示当前版本，<code>^</code>表示上个版本，<code>^^</code>表示上上个版本</p><p>也可以直接指定版本序列号</p><pre><code>git reflog</code></pre><p>可以查看每一次命令</p><h3 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h3><pre><code>git checkout -- [filename]</code></pre><p>把文件在工作区的修改全部撤销，这里有两种情况：</p><p>一种是文件自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</p><p>一种是文件已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</p><p>总之，就是让这个文件回到最近一次提交或添加时的状态</p><p>如果添加到暂存区了或已经提交到分支，可以这样撤销：</p><pre><code>git reset HEAD [filename]</code></pre><h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><pre><code>git rm [filename]</code></pre><h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><h3 id="添加远程库"><a href="#添加远程库" class="headerlink" title="添加远程库"></a>添加远程库</h3><p>把本地仓库推送到远程</p><pre><code>git remote add origin [url]</code></pre><p>先在远程添加一个</p><pre><code>git push -u origin master</code></pre><p>然后推送，<code>-u</code>可以把本地的<code>master</code>分支和远程<code>master</code>关联  </p><p>之后的推送可以用</p><pre><code>git push origin master</code></pre><h3 id="从远程库克隆"><a href="#从远程库克隆" class="headerlink" title="从远程库克隆"></a>从远程库克隆</h3><pre><code>git clone [url]</code></pre><h3 id="同步远程库信息"><a href="#同步远程库信息" class="headerlink" title="同步远程库信息"></a>同步远程库信息</h3><pre><code>git fetch origin</code></pre><h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><h3 id="创建和合并分支"><a href="#创建和合并分支" class="headerlink" title="创建和合并分支"></a>创建和合并分支</h3><p>创建分支</p><pre><code>git checkout -b dev</code></pre><p>查看分支</p><pre><code>git branch</code></pre><p>合并分支，如在<code>master</code>分支合并<code>dev</code>的修改</p><pre><code>git merge dev</code></pre><p>删除分支</p><pre><code>git branch -d dev</code></pre><p>获取远程分支</p><pre><code>git checkout -b dev origin/dev</code></pre><h3 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h3><h3 id="分支管理策略"><a href="#分支管理策略" class="headerlink" title="分支管理策略"></a>分支管理策略</h3><h2 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h2><h3 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h3><pre><code>git tag [tag]</code></pre><h3 id="操作标签"><a href="#操作标签" class="headerlink" title="操作标签"></a>操作标签</h3><p>删除标签</p><pre><code>git tag -d [tag]</code></pre><p>推送标签到远程</p><pre><code>git push origin [tag]</code></pre><h2 id="自定义Git"><a href="#自定义Git" class="headerlink" title="自定义Git"></a>自定义Git</h2><h3 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h3><p>填写<code>.gitignore</code>文件</p><h3 id="配置别名"><a href="#配置别名" class="headerlink" title="配置别名"></a>配置别名</h3><pre><code>git config --global alias.co checkout</code></pre><h3 id="显示颜色"><a href="#显示颜色" class="headerlink" title="显示颜色"></a>显示颜色</h3><pre><code>git config --global color.ui true</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Git是目前世界上最先进的分布式版本控制系统&lt;/p&gt;
    
    </summary>
    
      <category term="Git" scheme="http://lakeshire.github.io/categories/Git/"/>
    
    
      <category term="Git" scheme="http://lakeshire.github.io/tags/Git/"/>
    
      <category term="版本管理" scheme="http://lakeshire.github.io/tags/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Gradle相关资料</title>
    <link href="http://lakeshire.github.io/2017/03/15//archivers/gradle-related/"/>
    <id>http://lakeshire.github.io/2017/03/15//archivers/gradle-related/</id>
    <published>2017-03-15T04:00:00.000Z</published>
    <updated>2017-11-28T03:12:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文罗列一些Gradle的资料</p><a id="more"></a><h2 id="深入理解Gradle"><a href="#深入理解Gradle" class="headerlink" title="深入理解Gradle"></a><a href="http://blog.csdn.net/innost/article/details/48228651" target="_blank" rel="noopener">深入理解Gradle</a></h2><p>这篇文章是从API的角度做的教程，可以更清楚的了解Gradle</p><h2 id="Gradle脚本基础全攻略"><a href="#Gradle脚本基础全攻略" class="headerlink" title="Gradle脚本基础全攻略"></a><a href="http://blog.csdn.net/yanbober/article/details/49314255" target="_blank" rel="noopener">Gradle脚本基础全攻略</a></h2><p>这个基本就是官方文档的翻译版，讲述了实现一些特性的方法</p><h2 id="Groovy脚本基础全攻略"><a href="#Groovy脚本基础全攻略" class="headerlink" title="Groovy脚本基础全攻略"></a><a href="http://blog.csdn.net/yanbober/article/details/49047515" target="_blank" rel="noopener">Groovy脚本基础全攻略</a></h2><p>Gradle是基于Groovy的DSL，可以通过这篇文章简单学习一下，更多参见<a href="http://www.groovy-lang.org/index.html" target="_blank" rel="noopener">Groovy官方网站</a></p><h2 id="Gradle-User-Guide"><a href="#Gradle-User-Guide" class="headerlink" title="Gradle User Guide"></a><a href="https://docs.gradle.org/3.4.1/userguide/userguide.html" target="_blank" rel="noopener">Gradle User Guide</a></h2><p>很详细的用户指南，就是看起来比较累</p><h2 id="Gradle-API"><a href="#Gradle-API" class="headerlink" title="Gradle API"></a><a href="https://docs.gradle.org/3.4.1/javadoc/" target="_blank" rel="noopener">Gradle API</a></h2><p>Gradle的API手册</p><h2 id="Gradle-DSL"><a href="#Gradle-DSL" class="headerlink" title="Gradle DSL"></a><a href="https://docs.gradle.org/3.4.1/dsl/" target="_blank" rel="noopener">Gradle DSL</a></h2><p>Gradle的DSL，差不多脚本块里面会用到的东西都可以这里查</p><h2 id="Gradle-Android-DSL"><a href="#Gradle-Android-DSL" class="headerlink" title="Gradle Android DSL"></a><a href="http://google.github.io/android-gradle-dsl/current/index.html" target="_blank" rel="noopener">Gradle Android DSL</a></h2><p>Gradle Android插件的DSL</p><h2 id="一个模板脚本"><a href="#一个模板脚本" class="headerlink" title="一个模板脚本"></a>一个模板脚本</h2><p>提供了很多特性，可以参考和直接使用，参见<a href="https://developer.android.google.cn/studio/build/gradle-tips.html" target="_blank" rel="noopener">Gradle Tips and Recipes</a></p><pre><code>apply plugin: &apos;com.android.application&apos;//  配置阶段清空结果文件夹def init() {    def outputDir = new File(project.rootDir, &apos;output&apos;)    outputDir.listFiles().each {        it.delete()    }}init()//  只能写为顶层工程的属性rootProject.ext {    compileSdkVersion = 25}android {    //  访问工程范围的属性    compileSdkVersion rootProject.ext.compileSdkVersion    buildToolsVersion &quot;25.0.2&quot;    defaultConfig {        applicationId &quot;lakeshire.gitlab.com.myapplication&quot;        minSdkVersion 14        targetSdkVersion 25        //  manifest可以使用这些        def filesAuthorityValue = applicationId + &apos;.files&apos;        manifestPlaceholders = [ filesAuthority : filesAuthorityValue ]        //  标识版本        versionCode 1        //  用户可见的版本号        versionName &quot;1.0&quot;        testInstrumentationRunner &quot;android.support.test.runner.AndroidJUnitRunner&quot;    }    signingConfigs {        //  发布版的签名配置        release {            storeFile file(&quot;../my-release-key.jks&quot;)            storePassword &quot;password&quot;            keyAlias &quot;alias&quot;            keyPassword &quot;password&quot;        }    }    buildTypes {        release {            signingConfig signingConfigs.release            minifyEnabled false            proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos;        }    }    //  指定两个产品风味的维度    flavorDimensions &apos;mode&apos;, &apos;api&apos;    productFlavors {        free {            dimension &apos;mode&apos;            versionNameSuffix &apos;-free&apos;        }        pay {            dimension &apos;mode&apos;            versionNameSuffix &apos;-pay&apos;        }        minApi24 {            dimension &quot;api&quot;            minSdkVersion &apos;24&apos;            versionCode 30000 + android.defaultConfig.versionCode            versionNameSuffix &quot;-minApi24&quot;        }        minApi21 {            dimension &quot;api&quot;            minSdkVersion &apos;21&apos;            versionCode 10000  + android.defaultConfig.versionCode            versionNameSuffix &quot;-minApi21&quot;        }    }    sourceSets {        //  改变文件的位置        main {            java.srcDirs = [&apos;other/java&apos;]            //  不能包含冲突的文件            res.srcDirs = [&apos;src/other/res&apos;]            manifest.srcFile &apos;src/main/AndroidManifest.xml&apos;            //  最常见的Eclipse工程转化为AS工程SO文件在这里找            jniLibs.srcDirs = [&apos;libs&apos;]        }        androidTest {            setRoot &apos;src/tests&apos;        }    }    //  产生分离的apk 可用来减小安装包 对应的包只包含相关的资源什么的    splits {        density {            enable true            exclude &quot;ldpi&quot;, &quot;mdpi&quot;            //  默认是排除，也可以先清理再包括            //  reset()            //  include &quot;hdpi&quot;, &quot;xhdpi&quot;, &quot;xxhdpi&quot;, &quot;xxxhdpi&quot;            compatibleScreens &apos;normal&apos;, &apos;large&apos;, &apos;xlarge&apos;        }        abi {            enable true            //  默认所有ABI都包括，清理            reset()            include &quot;x86&quot;, &quot;armeabi-v7a&quot;, &quot;mips&quot;            //  需要生成一个包括所有ABI的APK            universalApk true        }    }    //  过滤变体    variantFilter { variant -&gt;        def names = variant.flavors*.name        if (names.contains(&quot;minApi21&quot;) || names.contains(&quot;free&quot;)) {            setIgnore(true)        }    }    dexOptions {        maxProcessCount 8        javaMaxHeapSize &quot;2g&quot;        preDexLibraries true    }}dependencies {    compile fileTree(include: [&apos;*.jar&apos;], dir: &apos;libs&apos;)    androidTestCompile(&apos;com.android.support.test.espresso:espresso-core:2.2.2&apos;, {        exclude group: &apos;com.android.support&apos;, module: &apos;support-annotations&apos;    })    //  仓库    compile &apos;com.android.support:appcompat-v7:25.1.1&apos;    compile &apos;com.android.support:design:25.1.1&apos;    testCompile &apos;junit:junit:4.12&apos;    //  本地模块    compile project(&apos;:mylibrary&apos;)    //  AAR    compile(name: &apos;play-services-7.8.87&apos;, ext: &apos;aar&apos;)}//  对每个变体 找出对应任务 在任务完成后拷贝安装包到最终目录afterEvaluate {    project.android.applicationVariants.each { variant -&gt;        def assembleTaskName = &quot;assemble${variant.name.capitalize()}&quot;        def assembleTask = project.tasks.findByName(assembleTaskName)        if (assembleTask != null) {            assembleTask.doLast {                copyApk(variant)            }        }    }}//  拷贝安装包 只拷贝release版本 并重命名def copyApk(def variant) {    variant.outputs.each { output -&gt;        if (output.outputFile.name.contains(&apos;release&apos;) &amp;&amp; output.outputFile.name.endsWith(&apos;apk&apos;)) {            println &apos;================ Copy Release APK ================&apos;            println output.outputFile.name            def time = new Date().format(&quot;yyyyMMddHHmmss&quot;)            def mainName = output.outputFile.name.split(&quot;\\.&quot;)[0]            def dstName =  mainName + &apos;-&apos; + output.versionCode + &apos;-&apos; + time + &apos;.apk&apos;            def src = output.outputFile            def dst = new File(&quot;${project.rootDir}/output&quot;, dstName)            dst.withOutputStream { os -&gt;                src.withOutputStream { is -&gt;                    os &lt;&lt; is                }            }        }    }}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文罗列一些Gradle的资料&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://lakeshire.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://lakeshire.github.io/tags/Android/"/>
    
      <category term="Gradle" scheme="http://lakeshire.github.io/tags/Gradle/"/>
    
  </entry>
  
  <entry>
    <title>Android性能优化典范</title>
    <link href="http://lakeshire.github.io/2017/03/13//archivers/android-performance/"/>
    <id>http://lakeshire.github.io/2017/03/13//archivers/android-performance/</id>
    <published>2017-03-13T02:00:00.000Z</published>
    <updated>2017-11-28T03:12:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍一些Android的性能优化技巧</p><a id="more"></a><h2 id="绘制"><a href="#绘制" class="headerlink" title="绘制"></a>绘制</h2><h3 id="分析工具"><a href="#分析工具" class="headerlink" title="分析工具"></a>分析工具</h3><h4 id="开发者选项-过度绘制"><a href="#开发者选项-过度绘制" class="headerlink" title="开发者选项-过度绘制"></a><a href="https://developer.android.google.cn/studio/profile/dev-options-overdraw.html" target="_blank" rel="noopener">开发者选项-过度绘制</a></h4><p>过度绘制描述的是屏幕上的某个像素在同一帧的时间内被绘制了多次。在多层次的UI结构里面，如果不可见的UI也在做绘制的操作，这就会导致某些像素区域被绘制了多次。这就浪费大量的CPU以及GPU资源。</p><h4 id="开发者选项-GPU渲染"><a href="#开发者选项-GPU渲染" class="headerlink" title="开发者选项-GPU渲染"></a><a href="https://developer.android.google.cn/studio/profile/dev-options-rendering.html" target="_blank" rel="noopener">开发者选项-GPU渲染</a></h4><p>我们需要确保每一帧花费的总时间都低于这条横线（16ms），这样才能够避免出现卡顿的问题。</p><h4 id="HierarchyViewer"><a href="#HierarchyViewer" class="headerlink" title="HierarchyViewer"></a><a href="https://developer.android.google.cn/studio/profile/optimize-ui.html" target="_blank" rel="noopener">HierarchyViewer</a></h4><p>调整布局，去除过深的布局</p><h3 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h3><h4 id="优化过度绘制"><a href="#优化过度绘制" class="headerlink" title="优化过度绘制"></a>优化过度绘制</h4><ul><li>移除<code>Window</code>默认的背景</li><li>移除XML布局文件中非必需的背景</li><li>按需显示占位背景图片</li></ul><h4 id="使用API优化"><a href="#使用API优化" class="headerlink" title="使用API优化"></a>使用API优化</h4><p>Android系统会通过避免绘制那些完全不可见的组件来尽量减少重绘，但对自定义View无效，因为他们重写了<code>onDraw()</code></p><p>可以通过<code>Canvas.clipRect()</code>来帮助系统识别那些可见的区域。这个方法可以指定一块矩形区域，只有在这个区域内才会被绘制，其他的区域会被忽视。这个API可以很好的帮助那些有多组重叠组件的自定义View来控制显示的区域。同时还可以帮助节约CPU与GPU资源，区域之外的绘制指令都不会被执行，那些部分内容在矩形区域内的组件，仍然会得到绘制。</p><p>还可以使用<code>Canvas.quickReject()</code>来判断是否没和某个矩形相交，从而跳过那些非矩形区域内的绘制操作。</p><h4 id="减少绘制区域"><a href="#减少绘制区域" class="headerlink" title="减少绘制区域"></a>减少绘制区域</h4><p>在Android里面一个相对操作比较繁重的事情是对Bitmap进行旋转，缩放，裁剪等等。例如在一个圆形的钟表图上，我们把时钟的指针抠出来当做单独的图片进行旋转会比旋转一张完整的圆形图的所形成的帧率要高56%。</p><p>尽量减少每次重绘的元素可以极大的提升性能，假如某个钟表界面上有很多需要显示的复杂组件，我们可以把这些组件做拆分处理，例如把背景图片单独拎出来设置为一个独立的View，通过<code>setLayerType()</code>方法使得这个View强制用硬件来进行渲染。至于界面上哪些元素需要做拆分，他们各自的更新频率是多少，需要有针对性的单独讨论。</p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="http://mrpeak.cn//android/2016/01/11/android-performance-ui/" target="_blank" rel="noopener">UI性能优化详解</a></p><h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><h3 id="分析工具-1"><a href="#分析工具-1" class="headerlink" title="分析工具"></a>分析工具</h3><h4 id="Memory-Monitor"><a href="#Memory-Monitor" class="headerlink" title="Memory Monitor"></a><a href="https://developer.android.google.cn/studio/profile/am-memory.html" target="_blank" rel="noopener">Memory Monitor</a></h4><p>查看整个应用所占用的内存，以及发生GC的时刻，短时间内发生大量的GC操作是一个危险的信号</p><h4 id="Allocation-Tracker"><a href="#Allocation-Tracker" class="headerlink" title="Allocation Tracker"></a><a href="https://developer.android.google.cn/studio/profile/am-allocation.html" target="_blank" rel="noopener">Allocation Tracker</a></h4><p>使用此工具来追踪内存的分配</p><h4 id="Heap-Tool"><a href="#Heap-Tool" class="headerlink" title="Heap Tool"></a><a href="https://developer.android.google.cn/studio/profile/am-hprof.html" target="_blank" rel="noopener">Heap Tool</a></h4><p>查看当前内存快照，便于对比分析哪些对象有可能是泄漏了的</p><h3 id="优化方案-1"><a href="#优化方案-1" class="headerlink" title="优化方案"></a>优化方案</h3><h4 id="对象池"><a href="#对象池" class="headerlink" title="对象池"></a>对象池</h4><p>在程序里面经常会遇到的一个问题是短时间内创建大量的对象，导致内存紧张，从而触发GC导致性能问题。对于这个问题，我们可以使用对象池技术来解决它。通常对象池中的对象可能是Bitmap，View，Paint等等。</p><p>使用对象池技术有很多好处，它可以避免内存抖动，提升性能，但是在使用的时候有一些内容是需要特别注意的。通常情况下，初始化的对象池里面都是空白的，当使用某个对象的时候先去对象池查询是否存在，如果不存在则创建这个对象然后加入对象池，但是我们也可以在程序刚启动的时候就事先为对象池填充一些即将要使用到的数据，这样可以在需要使用到这些对象的时候提供更快的首次加载速度，这种行为就叫做预分配。使用对象池也有不好的一面，程序员需要手动管理这些对象的分配与释放，所以我们需要慎重地使用这项技术，避免发生对象的内存泄漏。为了确保所有的对象能够正确被释放，我们需要保证加入对象池的对象和其他外部对象没有互相引用的关系。</p><h5 id="图片的对象池应用"><a href="#图片的对象池应用" class="headerlink" title="图片的对象池应用"></a>图片的对象池应用</h5><p>Android在解码图片的时候引进了<code>inBitmap</code>属性，使用<code>inBitmap</code>属性可以告知Bitmap解码器去尝试使用已经存在的内存区域，新解码的Bitmap会尝试去使用之前那张Bitmap在Heap中所占据的内存区域，而不是去问内存重新申请一块区域来存放Bitmap。利用这种特性，即使是上千张的图片，也只会仅仅只需要占用屏幕所能够显示的图片数量的内存大小。</p><p>用<code>inBitmap</code>需要注意几个限制条件：</p><ul><li>在SDK 11 -&gt; 18之间，重用的Bitmap大小必须是一致的，例如给<code>inBitmap</code>赋值的图片大小为100-100，那么新申请的Bitmap必须也为100-100才能够被重用。从SDK 19开始，新申请的Bitmap大小必须小于或者等于已经赋值过的Bitmap大小。<br>新申请的bitmap与旧的bitmap必须有相同的解码格式，例如大家都是8888的，如</li></ul><p>我们可以创建一个包含多种典型可重用Bitmap的对象池，这样后续的Bitmap创建都能够找到合适的“模板”去进行重用。</p><h2 id="电量"><a href="#电量" class="headerlink" title="电量"></a>电量</h2><h3 id="优化措施"><a href="#优化措施" class="headerlink" title="优化措施"></a>优化措施</h3><ul><li>我们应该尽量减少唤醒屏幕的次数与持续的时间，使用<code>WakeLock</code>来处理唤醒的问题，能够正确执行唤醒操作并根据设定及时关闭操作进入睡眠状态。</li><li>某些非必须马上执行的操作，例如上传歌曲，图片处理等，可以等到设备处于充电状态或者电量充足的时候才进行。</li><li>触发网络请求的操作，每次都会保持无线信号持续一段时间，我们可以把零散的网络请求打包进行一次操作，避免过多的无线信号引起的电量消耗。关于网络请求引起无线信号的电量消耗，参考<a href="http://hukai.me/android-training-course-in-chinese/connectivity/efficient-downloads/efficient-network-access.html" target="_blank" rel="noopener">优化下载以高效访问网络</a></li><li>如果发现我们的App有电量消耗过多的问题，我们可以使用<code>JobScheduler API</code>来对一些任务进行定时处理，例如我们可以把那些任务重的操作等到手机处于充电状态，或者是连接到WiFi的时候来处理，参见<a href="http://hukai.me/android-training-course-in-chinese/background-jobs/scheduling/index.html" target="_blank" rel="noopener">管理设备的唤醒状态</a></li></ul><p>Android 5.0开始发布了<code>Battery History Tool</code>，它可以查看程序被唤醒的频率，又谁唤醒的，持续了多长的时间，这些信息都可以获取到。</p><h3 id="Networking-Traffic-Tool"><a href="#Networking-Traffic-Tool" class="headerlink" title="Networking Traffic Tool"></a>Networking Traffic Tool</h3><p>Android DDMS包含了一个查看网络使用详情的栏目来允许跟踪App 的网络请求。使用这个工具，可以监测App 是在何时，如何传输数据的，从而进行代码的优化。</p><h2 id="编码技巧"><a href="#编码技巧" class="headerlink" title="编码技巧"></a>编码技巧</h2><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p>数据显示<code>for index</code>方式在Android上有着更好的效率，但是因为不同平台编译器优化各有差异，我们最好还是针对实际的方法做一下简单的测量比较好，拿到数据之后，再选择效率最高的那个方式。</p><h3 id="LRU缓存"><a href="#LRU缓存" class="headerlink" title="LRU缓存"></a>LRU缓存</h3><p>使用<code>LRU Cache</code>能够显著提升应用的性能，可是也需要注意LRU Cache中被淘汰对象的回收，否者会引起严重的内存泄露。</p><h3 id="透明区域的性能影响"><a href="#透明区域的性能影响" class="headerlink" title="透明区域的性能影响"></a>透明区域的性能影响</h3><p>通常来说，对于不透明的View，显示它只需要渲染一次即可，可是如果这个View设置了<code>alpha</code>值，会至少需要渲染两次。</p><p>大多数情况下，屏幕上的元素都是由后向前进行渲染的。如果后渲染的元素有设置<code>alpha</code>值，那么这个元素就会和屏幕上已经渲染好的元素做混色处理。很多时候，我们会给整个View设置alpha的来达到淡出的动画效果，如果我们dui做alpha逐渐减小的处理，我们可以看到列表上的组件会逐渐融合到背景色上。但是在这个过程中，我们无法观察到它其实已经触发了额外的绘制任务，我们的目标是让整个View逐渐透明，可是期间ListView在不停的做混色操作，这样会导致不少性能问题。</p><p>如何渲染才能够得到我们想要的效果呢？我们可以先按照通常的方式把View上的元素按照从后到前的方式绘制出来，但是不直接显示到屏幕上，而是使用GPU预处理之后，再又GPU渲染到屏幕上，GPU可以对界面上的原始数据直接做旋转，设置透明度等等操作。使用GPU进行渲染，虽然第一次操作相比起直接绘制到屏幕上更加耗时，可是一旦原始纹理数据生成之后，接下去的操作就比较省时省力。</p><p>如何才能够让GPU来渲染某个View呢？我们可以通过<code>setLayerType()</code>的方法来指定View应该如何进行渲染，从SDK 16开始，我们还可以使用<code>ViewPropertyAnimator.alpha().withLayer()</code>来指定。</p><h3 id="优化自定义View"><a href="#优化自定义View" class="headerlink" title="优化自定义View"></a>优化自定义View</h3><ul><li>我们知道调用<code>View.invalidate()</code>会触发View的重绘，有两个原则需要遵守，第一是仅仅在View的内容发生改变的时候才去触发invalidate方法，第二是尽量使用<code>clipRect</code>等方法来提高绘制的性能。</li><li>减少绘制时不必要的绘制元素，对于那些不可见的元素，我们需要尽量避免重绘。</li><li>对于不在屏幕上的元素，可以使用<code>Canvas.quickReject</code>把他们给剔除，避免浪费CPU资源。另外尽量使用GPU来进行UI的渲染，这样能够极大的提高程序的整体表现性能。</li></ul><h3 id="图像格式"><a href="#图像格式" class="headerlink" title="图像格式"></a>图像格式</h3><p>常见格式的图片在设置到UI上之前需要经过解码的过程，而解压时可以选择不同的解码率，不同的解码率对内存的占用是有很大差别的。在不影响到画质的前提下尽量减少内存的占用，这能够显著提升应用程序的性能。</p><p>Android的Heap空间是不会自动做兼容压缩的，意思就是如果Heap空间中的图片被收回之后，这块区域并不会和其他已经回收过的区域做重新排序合并处理，那么当一个更大的图片需要放到Heap之前，很可能找不到那么大的连续空闲区域，那么就会触发GC，使得Heap腾出一块足以放下这张图片的空闲区域，如果无法腾出，就会发生OOM。</p><p>所以为了避免加载一张超大的图片，需要尽量减少这张图片所占用的内存大小，Android为图片提供了4种解码格式.随着解码占用内存大小的降低，清晰度也会有损失。我们需要针对不同的应用场景做不同的处理，大图和小图可以采用不同的解码率。</p><h3 id="位图缩放"><a href="#位图缩放" class="headerlink" title="位图缩放"></a>位图缩放</h3><p>对Bitmap做缩放，这也是Android里面经常遇到的问题。对Bitmap做缩放的意义很明显，提示显示性能，避免分配不必要的内存。Android提供了现成的Bitmap缩放的API，叫做<code>createScaledBitmap()</code>，使用这个方法可以获取到一张经过缩放的图片，可是这个方法能够执行的前提是，原图片需要事先加载到内存中，如果原图片过大，很可能导致OOM。</p><p>可以使用<code>inSampleSize</code>，能够等比的缩放显示图片，同时还避免了需要先把原图加载进内存的缺点。另外，我们还可以使用<code>inScaled</code>，<code>inDensity</code>，<code>inTargetDensity</code>的属性来对解码图片做处理，还有一个经常使用到的技巧是<code>inJustDecodeBounds</code>，使用这个属性去尝试解码图片，可以事先获取到图片的大小而不至于占用什么内存。</p><h3 id="性能优化工作流"><a href="#性能优化工作流" class="headerlink" title="性能优化工作流"></a>性能优化工作流</h3><p>大多数开发者在没有发现严重性能问题之前是不会特别花精力去关注性能优化的，通常大家关注的都是功能是否实现。当性能问题真的出现的时候，请不要慌乱。我们通常采用下面三个步骤来解决性能问题。</p><h4 id="收集数据"><a href="#收集数据" class="headerlink" title="收集数据"></a>收集数据</h4><p>我们可以通过Android SDK里面提供的诸多工具来收集CPU，GPU，内存，电量等等性能数据。</p><h4 id="分析数据"><a href="#分析数据" class="headerlink" title="分析数据"></a>分析数据</h4><p>通过上面的步骤，我们获取到了大量的数据，下一步就是分析这些数据。工具帮我们生成了很多可读性强的表格，我们需要事先了解如何查看表格的数据，每一项代表的含义，这样才能够快速定位问题。如果分析数据之后还是没有找到问题，那么就只能不停的重新收集数据，再进行分析，如此循环。</p><h4 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h4><p>定位到问题之后，我们需要采取行动来解决问题。解决问题之前一定要先有个计划，评估这个解决方案是否可行，是否能够及时的解决问题。</p><h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><p>HashMap内部是使用一个默认容量为16的数组来存储数据，而数组中每一个元素却又是一个链表的头结点，所以，更准确的来说，HashMap内部存储结构是使用哈希表的拉链结构（数组+链表），这种存储数据的方法叫做拉链法。</p><p>每一个结点都是Entry类型，存储的内容有Key、Value、Hash值、和下一个Entry，通过计算元素Key的Hash值，然后对HashMap中数组长度取余得到该元素存储的位置，如果有多个元素Key的Hash值相同的话，后一个元素并不会覆盖上一个元素，而是采取链表的方式，把之后加进来的元素加入链表末尾，从而解决了Hash冲突的问题，由此我们知道HashMap中处理Hash冲突的方法是链地址法。</p><p>我们知道HashMap中默认的存储大小就是一个容量为16的数组，所以当我们创建出一个HashMap对象时，即使里面没有任何元素，也要分别一块内存空间给它，而且，我们再不断的向HashMap里添加数据时，当达到一定的容量限制时（满足这样的一个关系时候将会扩容：HashMap中的数据量&gt;容量*加载因子，而HashMap中默认的加载因子是0.75），HashMap的空间将会扩大，而且扩大后新的空间一定是原来的2倍。</p><p>假如我们有几十万、几百万条数据，那么HashMap要存储完这些数据将要不断的扩容，而且在此过程中也需要不断的做哈希运算，这将对我们的内存空间造成很大消耗和浪费，而且HashMap获取数据是通过遍历Entry[]数组来得到对应的元素，在数据量很大时候会比较慢，所以在Android中，HashMap是比较费内存的，我们在一些情况下可以使用SparseArray和ArrayMap来代替HashMap。</p><h4 id="SparseArray"><a href="#SparseArray" class="headerlink" title="SparseArray"></a>SparseArray</h4><p>SparseArray比HashMap更省内存，在某些条件下性能更好，主要是因为它避免了对Key的自动装箱，它内部则是通过两个数组来进行数据存储的，一个存储Key，另外一个存储Value，为了优化性能，它内部对数据还采取了压缩的方式来表示稀疏数组的数据，从而节约内存空间。</p><p>SparseArray只能存储Key为int类型的数据，同时，SparseArray在存储和读取数据时候，使用的是二分查找法。SparseArray存储的元素都是按元素的Key值从小到大排列好的。而在获取数据的时候，也是使用二分查找法判断元素的位置，所以，在获取数据的时候非常快，比HashMap快的多。</p><p>SparseArray还提供了两个特有方法，更方便数据的查询： </p><p>获取对应的Key：</p><pre><code>public int keyAt(int index)</code></pre><p>获取对应的Value：</p><pre><code>public E valueAt(int index)</code></pre><p>虽说SparseArray性能比较好，但是由于其添加、查找、删除数据都需要先进行一次二分查找，所以在数据量大的情况下性能并不明显，将降低至少50%。</p><p>满足下面两个条件我们可以使用SparseArray代替HashMap：</p><ul><li>数据量不大，最好在千级以内</li><li>Key必须为int类型，这中情况下的HashMap可以用SparseArray代替</li></ul><h4 id="ArrayMap"><a href="#ArrayMap" class="headerlink" title="ArrayMap"></a>ArrayMap</h4><p>ArrayMap是一个<key, value="">映射的数据结构，它设计上更多的是考虑内存的优化，内部是使用两个数组进行数据存储，一个数组记录Key的哈希值，另外一个数组记录Value值，它和SparseArray一样，也会对Key使用二分法进行从小到大排序，在添加、删除、查找数据的时候都是先使用二分查找法得到相应的index，然后通过index来进行添加、查找、删除等操作，所以，应用场景和SparseArray的一样，如果在数据量比较大的情况下，那么它的性能将退化至少50%。</key,></p><p>应用场景</p><ul><li>数据量不大，最好在千级以内</li><li>数据结构类型为Map类型</li></ul><h3 id="自动装箱"><a href="#自动装箱" class="headerlink" title="自动装箱"></a>自动装箱</h3><p>我们知道基础数据类型的大小：<code>boolean</code>(8 bits), <code>int</code>(32 bits), <code>float</code>(32 bits)，<code>long</code>(64 bits)，为了能够让这些基础数据类型在大多数Java容器中运作，会需要做一个AutoBoxing的操作，转换成<code>Boolean</code>，<code>Integer</code>，<code>Float</code>，<code>Long</code>等对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  基础类型</span></span><br><span class="line"><span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">    total += i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  下面的代码生成了很多新对象！</span></span><br><span class="line"><span class="comment">//  创建新对象，放进去值，加到total上</span></span><br><span class="line">Integer total = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">    total += i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AutoBoxing的行为还经常发生在类似HashMap这样的容器里面，对HashMap的增删改查操作都会发生了大量的AutoBoxing的行为。</p><p>Android提供了一些数据结构避免自动装箱行为：<code>SparseBoolMap</code>、<code>SparseIntMap</code>、<code>SparseLongMap</code>、<code>LongSparseMap</code></p><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>不要在Android中使用枚举，比起静态常量会有超出两倍的额外内存开销</p><h3 id="内存使用"><a href="#内存使用" class="headerlink" title="内存使用"></a>内存使用</h3><p>Android系统提供了一些回调来通知应用的内存使用情况，通常来说，当所有的<br>Background应用都被杀掉的时候，Forground应用会收到<code>onLowMemory()</code>的回调。在这种情况下，需要尽快释放当前应用的非必须内存资源，从而确保系统能够稳定继续运行。Android系统还提供了<code>onTrimMemory()</code>的回调，当系统内存达到某些条件的时候，所有正在运行的应用都会收到这个回调。</p><h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><p>通常来说，View会保持Activity的引用，Activity同时还和其他内部对象也有可能保持引用关系。当屏幕发生旋转的时候，Activity很容易发生泄漏，这样的话，里面的View也会发生泄漏。Activity以及View的泄漏是非常严重的，为了避免出现泄漏，请特别留意以下的规则：</p><ol><li>避免使用异步回调</li></ol><p>异步回调被执行的时间不确定，很有可能发生在Activity已经被销毁之后，这不仅仅很容易引起Crash，还很容易发生内存泄露。</p><ol><li>避免使用静态对象</li></ol><p>因为静态对象的生命周期过长，使用不当很可能导致泄漏，在Android中应该尽量避免使用静态对象。</p><ol><li>避免把View添加到没有清除机制的容器里面</li></ol><p>假如把View添加到WeakHashMap，如果没有执行清除操作，很可能会导致泄漏。</p><h3 id="定位与电量优化"><a href="#定位与电量优化" class="headerlink" title="定位与电量优化"></a>定位与电量优化</h3><p>开启定位功能是一个相对来说比较耗电的操作，一般通过<code>setInterval()</code>设置每隔多长的时间获取一次位置更新，时间相隔越短，自然花费的电量就越多，但是时间相隔太长，又无法及时获取到更新的位置信息。其中存在的一个优化点是，我们可以通过判断返回的位置信息是否相同，从而决定设置下次的更新间隔是否增加一倍，通过这种方式可以减少电量的消耗。</p><p>通过GPS定位服务相比起使用网络进行定位更加的耗电，但是也相对更加精准一些。为了提供不同精度的定位需求，同时屏蔽实现位置请求的细节，Android提供了下面4种不同精度与耗电量的参数给应用进行设置调用，应用只需要决定在适当的场景下使用对应的参数就好了，通过<code>LocationRequest.setPriority()</code>方法传递参数就好了。</p><h3 id="多重Layout"><a href="#多重Layout" class="headerlink" title="多重Layout"></a>多重Layout</h3><p><code>RelativeLayout</code>会发生两次<code>layout</code>，<code>LinearLayout</code>等在某些情况下也会触发两次<code>layout</code>，如果只是少量的重复布局本身并不会引起严重的性能问题，但是如果它们发生在布局的根节点，或者是列表里面的某个列表项，这样就会引起比较严重的性能问题。</p><p>我们可以使用<code>Systrace</code>来跟踪特定的某段操作，如果发现了疑似丢帧的现象，可能就是因为重复布局引起的。通常我们无法避免重复布局，在这种情况下，我们应该尽量保持View Hierarchy的层级比较浅，这样即使发生重复布局，也不会因为布局的层级比较深而增大了重复布局的倍数。另外还有一点需要特别注意，在任何时候都请避免调用<code>requestLayout()</code>的方法，因为一旦调用了requestLayout，会导致该布局的所有父节点都发生重新布局的操作。</p><h3 id="网络请求优化"><a href="#网络请求优化" class="headerlink" title="网络请求优化"></a>网络请求优化</h3><ul><li>使用回退机制来避免固定频繁的同步请求：在发现返回数据相同的情况下，推迟下次的请求时间</li><li>使用批处理的方式来集中发出请求，避免频繁的间隔请求</li><li>使用预取的技术提前把一些数据拿到，避免后面频繁再次发起网络请求</li><li>压缩传输数据</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍一些Android的性能优化技巧&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://lakeshire.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://lakeshire.github.io/tags/Android/"/>
    
      <category term="性能优化" scheme="http://lakeshire.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Android——测试</title>
    <link href="http://lakeshire.github.io/2017/03/01//archivers/android-test/"/>
    <id>http://lakeshire.github.io/2017/03/01//archivers/android-test/</id>
    <published>2017-03-01T06:30:00.000Z</published>
    <updated>2017-11-28T03:13:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍了Android应用的常用测试类型</p><a id="more"></a><h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><p>单元测试是编写测试代码，用来检测特定的、明确的、细颗粒的功能</p><p>单元测试不仅仅用来保证当前代码的正确性，更重要的是用来保证代码修复、改进或重构之后的正确性</p><p>一般来说，单元测试任务包括</p><ol><li>接口功能测试：用来保证接口功能的正确性</li><li><p>局部数据结构测试（不常用）：用来保证接口中的数据结构是正确的</p><ol><li>比如变量有无初始值</li><li>变量是否溢出</li></ol></li><li><p>边界条件测试</p><ol><li>变量没有赋值（即为NULL）</li><li><p>变量是数值（或字符)</p><ol><li>主要边界：最小值，最大值，无穷大（对于DOUBLE等）</li><li>溢出边界（期望异常或拒绝服务）：最小值-1，最大值+1</li><li>临近边界：最小值+1，最大值-1</li></ol></li><li><p>变量是字符串</p><ol><li>引用“字符变量”的边界</li><li>空字符串</li><li>对字符串长度应用“数值变量”的边界</li></ol></li><li><p>变量是集合</p><ol><li>空集合</li><li>对集合的大小应用“数值变量”的边界</li><li>调整次序：升序、降序</li></ol></li><li><p>变量有规律：比如对于Math.sqrt，给出n^2^-1和n^2^+1的边界</p></li></ol></li><li><p>所有独立执行通路测试：保证每一条代码，每个分支都经过测试，AndroidStudio中集成了<code>Jacoco</code>可以做覆盖率统计</p><ol><li>语句覆盖：保证每一个语句都执行到了</li><li>判定覆盖（分支覆盖）：保证每一个分支都执行到</li><li>条件覆盖：保证每一个条件都覆盖到true和false（即if、while中的条件语句）</li><li>路径覆盖：保证每一个路径都覆盖到</li><li>各条错误处理通路测试：保证每一个异常都经过测试</li></ol></li></ol><h3 id="JUnit"><a href="#JUnit" class="headerlink" title="JUnit"></a>JUnit</h3><p><code>JUnit4</code>通过注解来识别测试方法</p><ul><li><code>@BeforeClass</code> 全局执行一次，第一个运行</li><li><code>@Before</code> 测试方法运行前运行</li><li><code>@Test</code> 测试方法</li><li><code>@After</code> 测试方法运行后运行</li><li><code>@AfterClass</code> 全局执行一次，最后一个运行</li><li><code>@Ignore</code> 忽略</li></ul><h3 id="Mockito"><a href="#Mockito" class="headerlink" title="Mockito"></a><a href="http://site.mockito.org/" target="_blank" rel="noopener">Mockito</a></h3><p>Mock测试是单元测试的重要方法之一，就是对某些不容易构造或难以获取的对象，用一个虚拟的Mock对象创建以便测试的方法</p><p>最大的有点是可以解除单元测试的耦合，如果你的代码对另一个类或接口由依赖，能够模拟这些依赖，帮你验证调用的依赖行为</p><p>使用一个接口来描述这个对象 在产品代码中实现这个接口，在测试代码中实现这个接口 在被测试代码中只是通过接口来引用对象，所以它不知道这个引用的对象是真实对象，还是Mock对象</p><p><code>Mockito</code>是很强大的单元测试Mock框架</p><h4 id="验证行为"><a href="#验证行为" class="headerlink" title="验证行为"></a>验证行为</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.mockito.Mockito.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">//mock creation</span></span><br><span class="line">List mockedList = mock(List.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">//using mock object</span></span><br><span class="line">mockedList.add(<span class="string">"one"</span>);</span><br><span class="line">mockedList.clear();</span><br><span class="line"></span><br><span class="line"><span class="comment">//verification</span></span><br><span class="line">verify(mockedList).add(<span class="string">"one"</span>);</span><br><span class="line">verify(mockedList).clear();</span><br></pre></td></tr></table></figure><p>它会记得所有的交互，你可以验证</p><h4 id="打桩"><a href="#打桩" class="headerlink" title="打桩"></a>打桩</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LinkedList mockedList = mock(LinkedList.class);</span><br><span class="line">when(mockedList.get(<span class="number">0</span>)).thenReturn(<span class="string">"first"</span>);</span><br><span class="line">when(mockedList.get(<span class="number">1</span>)).thenThrow(<span class="keyword">new</span> RuntimeException());</span><br><span class="line">System.out.println(mockedList.get(<span class="number">0</span>));</span><br><span class="line">System.out.println(mockedList.get(<span class="number">1</span>));</span><br><span class="line">System.out.println(mockedList.get(<span class="number">999</span>));</span><br><span class="line">verify(mockedList).get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>可以为模拟的接口打桩，指定其行为，上面取第一个元素就会返回<code>first</code>，取第二个元素会抛出异常，取没有打桩的元素会返回<code>null</code></p><h4 id="参数匹配器"><a href="#参数匹配器" class="headerlink" title="参数匹配器"></a>参数匹配器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">when(mockedList.get(anyInt())).thenReturn(<span class="string">"element"</span>);</span><br><span class="line">when(mockedList.contains(argThat(isValid()))).thenReturn(<span class="string">"element"</span>);</span><br><span class="line">System.out.println(mockedList.get(<span class="number">999</span>));</span><br><span class="line">verify(mockedList).get(anyInt());</span><br></pre></td></tr></table></figure><p>用<code>anyInt()</code>匹配所有元素，用<code>argThat()</code>指定自定义参数匹配</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">verify(mock).someMethod(anyInt(), anyString(), eq(<span class="string">"third argument"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//  错误，所有的参数都应该由匹配器提供</span></span><br><span class="line">verify(mock).someMethod(anyInt(), anyString(), <span class="string">"third argument"</span>);</span><br></pre></td></tr></table></figure><h4 id="调用额外的调用数字"><a href="#调用额外的调用数字" class="headerlink" title="调用额外的调用数字"></a>调用额外的调用数字</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mockedList.add(<span class="string">"once"</span>);</span><br><span class="line"></span><br><span class="line">mockedList.add(<span class="string">"twice"</span>);</span><br><span class="line">mockedList.add(<span class="string">"twice"</span>);</span><br><span class="line"></span><br><span class="line">mockedList.add(<span class="string">"three times"</span>);</span><br><span class="line">mockedList.add(<span class="string">"three times"</span>);</span><br><span class="line">mockedList.add(<span class="string">"three times"</span>);</span><br><span class="line"></span><br><span class="line">verify(mockedList).add(<span class="string">"once"</span>);</span><br><span class="line">verify(mockedList, times(<span class="number">1</span>)).add(<span class="string">"once"</span>);</span><br><span class="line">verify(mockedList, times(<span class="number">2</span>)).add(<span class="string">"twice"</span>);</span><br><span class="line">verify(mockedList, times(<span class="number">3</span>)).add(<span class="string">"three times"</span>);</span><br><span class="line">verify(mockedList, never()).add(<span class="string">"never happened"</span>);</span><br><span class="line">verify(mockedList, atLeastOnce()).add(<span class="string">"three times"</span>);</span><br><span class="line">verify(mockedList, atLeast(<span class="number">2</span>)).add(<span class="string">"five times"</span>);</span><br><span class="line">verify(mockedList, atMost(<span class="number">5</span>)).add(<span class="string">"three times"</span>);</span><br></pre></td></tr></table></figure><h4 id="处理异常"><a href="#处理异常" class="headerlink" title="处理异常"></a>处理异常</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">doThrow(<span class="keyword">new</span> RuntimeException()).when(mockedList).clear();</span><br><span class="line">mockedList.clear();</span><br></pre></td></tr></table></figure><h4 id="有序验证"><a href="#有序验证" class="headerlink" title="有序验证"></a>有序验证</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">List singleMock = mock(List.class);</span><br><span class="line">singleMock.add(<span class="string">"was added first"</span>);</span><br><span class="line">singleMock.add(<span class="string">"was added second"</span>);</span><br><span class="line"></span><br><span class="line">InOrder inOrder = inOrder(singleMock);</span><br><span class="line"></span><br><span class="line">inOrder.verify(singleMock).add(<span class="string">"was added first"</span>);</span><br><span class="line">inOrder.verify(singleMock).add(<span class="string">"was added second"</span>);</span><br><span class="line"></span><br><span class="line">List firstMock = mock(List.class);</span><br><span class="line">List secondMock = mock(List.class);</span><br><span class="line"></span><br><span class="line">firstMock.add(<span class="string">"was called first"</span>);</span><br><span class="line">secondMock.add(<span class="string">"was called second"</span>);</span><br><span class="line"></span><br><span class="line">InOrder inOrder = inOrder(firstMock, secondMock);</span><br><span class="line"></span><br><span class="line">inOrder.verify(firstMock).add(<span class="string">"was called first"</span>);</span><br><span class="line">inOrder.verify(secondMock).add(<span class="string">"was called second"</span>);</span><br></pre></td></tr></table></figure><h4 id="确保不会发生交互"><a href="#确保不会发生交互" class="headerlink" title="确保不会发生交互"></a>确保不会发生交互</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mockOne.add(<span class="string">"one"</span>);</span><br><span class="line">verify(mockOne).add(<span class="string">"one"</span>);</span><br><span class="line">verify(mockOne, never()).add(<span class="string">"two"</span>);</span><br><span class="line">verifyZeroInteractions(mockTwo, mockThree);</span><br></pre></td></tr></table></figure><h4 id="寻找多余调用"><a href="#寻找多余调用" class="headerlink" title="寻找多余调用"></a>寻找多余调用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mockedList.add(<span class="string">"one"</span>);</span><br><span class="line">mockedList.add(<span class="string">"two"</span>);</span><br><span class="line">verify(mockedList).add(<span class="string">"one"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//  将会失败</span></span><br><span class="line">verifyNoMoreInteractions(mockedList);</span><br></pre></td></tr></table></figure><h4 id="一个列子"><a href="#一个列子" class="headerlink" title="一个列子"></a>一个列子</h4><p>Person.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(Integer id, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PersonDAO.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PersonDAO</span> </span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">fetchPerson</span><span class="params">(Integer id)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(Person person)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PersonService</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> PersonDAO personDAO;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PersonService</span><span class="params">(PersonDAO personDAO)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.personDAO = personDAO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">update</span><span class="params">(Integer id, String name)</span> </span>&#123;</span><br><span class="line">        Person person = personDAO.fetchPerson(id);</span><br><span class="line">        <span class="keyword">if</span> (person != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Person updatedPerson = <span class="keyword">new</span> Person(person.getId(), name);</span><br><span class="line">            personDAO.update(updatedPerson);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PersonServiceTest.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonServiceTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Mock</span> <span class="keyword">private</span> PersonDAO personDAO;</span><br><span class="line">    <span class="keyword">private</span> PersonService personService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//  初始化</span></span><br><span class="line">        MockitoAnnotations.initMocks(<span class="keyword">this</span>);</span><br><span class="line">        personService = <span class="keyword">new</span> PersonService(personDAO);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shouldUpdatePersonName</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person(<span class="number">1</span>, <span class="string">"Phillip"</span>);</span><br><span class="line">        <span class="comment">//  传入1时返回菲利普</span></span><br><span class="line">        when(personDAO.fetchPerson(<span class="number">1</span>)).thenReturn(person);</span><br><span class="line">        <span class="comment">//  测试update</span></span><br><span class="line">        <span class="keyword">boolean</span> updated = personService.update(<span class="number">1</span>, <span class="string">"David"</span>);</span><br><span class="line">        <span class="comment">//  判断是否更新成功(应该成功)</span></span><br><span class="line">        assertTrue(updated);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  验证是否调用fetchPerson</span></span><br><span class="line">        verify(personDAO).fetchPerson(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//  验证是否调用update</span></span><br><span class="line">        ArgumentCaptor&lt;Person&gt; personCaptor = ArgumentCaptor.forClass(Person.class);</span><br><span class="line">        verify(personDAO).update(personCaptor.capture());</span><br><span class="line">        Person updatedPerson = personCaptor.getValue();</span><br><span class="line">        <span class="comment">//  判断更新后的返回值</span></span><br><span class="line">        assertEquals(<span class="string">"David"</span>, updatedPerson.getName());</span><br><span class="line">        <span class="comment">//  判断是否有更多交互</span></span><br><span class="line">        verifyNoMoreInteractions(personDAO);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shouldNotUpdateIfPersonNotFound</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//  传入1时返回null</span></span><br><span class="line">        when(personDAO.fetchPerson(<span class="number">1</span>)).thenReturn(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">boolean</span> updated = personService.update(<span class="number">1</span>, <span class="string">"David"</span>);</span><br><span class="line">        <span class="comment">//  判断是否更新成功(应该失败)</span></span><br><span class="line">        assertFalse(updated);</span><br><span class="line">        <span class="comment">//  验证是否调用fetchPerson</span></span><br><span class="line">        verify(personDAO).fetchPerson(<span class="number">1</span>);</span><br><span class="line">        verifyZeroInteractions(personDAO);</span><br><span class="line">        verifyNoMoreInteractions(personDAO);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="仪器测试"><a href="#仪器测试" class="headerlink" title="仪器测试"></a>仪器测试</h2><h3 id="Espresso"><a href="#Espresso" class="headerlink" title="Espresso"></a><a href="https://developer.android.google.cn/studio/test/espresso-test-recorder.html" target="_blank" rel="noopener">Espresso</a></h3><p>测试登录页面跳转首页，判断是否登录成功</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(AndroidJUnit4.class)</span><br><span class="line"><span class="meta">@LargeTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Rule</span></span><br><span class="line">    <span class="keyword">public</span> ActivityTestRule&lt;LoginActivity&gt; mActivityRule = <span class="keyword">new</span> ActivityTestRule&lt;&gt;(LoginActivity.class);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loginWithWrongPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        onView(withId(R.id.et_username)).perform(replaceText(<span class="string">"android"</span>));</span><br><span class="line">        closeSoftKeyboard();</span><br><span class="line">        onView(withId(R.id.et_password)).perform(replaceText(<span class="string">"wrong"</span>));</span><br><span class="line">        closeSoftKeyboard();</span><br><span class="line">        onView(withId(R.id.btn_login)).perform(click());</span><br><span class="line">        onView(withId(R.id.tv_result)).check(matches(withText(<span class="string">"登录失败"</span>)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loginWithRightPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        onView(withId(R.id.et_username)).perform(replaceText(<span class="string">"android"</span>));</span><br><span class="line">        closeSoftKeyboard();</span><br><span class="line">        onView(withId(R.id.et_password)).perform(replaceText(<span class="string">"123456"</span>));</span><br><span class="line">        closeSoftKeyboard();</span><br><span class="line">        onView(withId(R.id.btn_login)).perform(click());</span><br><span class="line">        onView(withId(R.id.tv_result)).check(matches(withText(<span class="string">"登录成功"</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>不是原生输入法，<code>typeText()</code>可能导致输入不完整而测试失败，使用<code>replaceText()</code>立刻填充或换回原生输入法</p></blockquote><p><a href="https://google.github.io/android-testing-support-library/docs/espresso/index.html" target="_blank" rel="noopener">更多用法</a></p><h2 id="压力测试"><a href="#压力测试" class="headerlink" title="压力测试"></a>压力测试</h2><h3 id="Monkey"><a href="#Monkey" class="headerlink" title="Monkey"></a>Monkey</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍了Android应用的常用测试类型&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://lakeshire.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://lakeshire.github.io/tags/Android/"/>
    
      <category term="测试" scheme="http://lakeshire.github.io/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>AndroidStudio——Gradle小贴士</title>
    <link href="http://lakeshire.github.io/2017/02/24//archivers/android-studio-gradle-tips/"/>
    <id>http://lakeshire.github.io/2017/02/24//archivers/android-studio-gradle-tips/</id>
    <published>2017-02-24T06:30:00.000Z</published>
    <updated>2017-11-28T03:13:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>AndroidStudio里使用Gradle的一些小知识</p><a id="more"></a><h2 id="管理工程和资源"><a href="#管理工程和资源" class="headerlink" title="管理工程和资源"></a>管理工程和资源</h2><h3 id="改变默认源集"><a href="#改变默认源集" class="headerlink" title="改变默认源集"></a>改变默认源集</h3><p>修改<code>sourceSets</code>块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    sourceSets &#123;</span><br><span class="line">        main &#123;</span><br><span class="line">          java.srcDirs = [<span class="string">'other/java'</span>]</span><br><span class="line">          res.srcDirs = [<span class="string">'other/res1'</span>, <span class="string">'other/res2'</span>]</span><br><span class="line">          manifest.srcFile <span class="string">'other/AndroidManifest.xml'</span></span><br><span class="line">          ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        androidTest &#123;</span><br><span class="line">          setRoot <span class="string">'src/tests'</span></span><br><span class="line">          ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置工程范围的属性"><a href="#配置工程范围的属性" class="headerlink" title="配置工程范围的属性"></a>配置工程范围的属性</h3><p>在顶级<code>build.gradle</code>中添加<code>ext</code>块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;...&#125;</span><br><span class="line">allprojects &#123;...&#125;</span><br><span class="line"></span><br><span class="line">ext &#123;</span><br><span class="line">    compileSdkVersion = <span class="number">25</span></span><br><span class="line">    buildToolsVersion = <span class="string">"25.0.0"</span></span><br><span class="line">    supportLibVersion = <span class="string">"25.2.0"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>rootProject.ext.property_name</code>访问这些属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    compileSdkVersion rootProject.ext.compileSdkVersion</span><br><span class="line">    buildToolsVersion rootProject.ext.buildToolsVersion</span><br><span class="line">&#125;</span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile <span class="string">"com.android.support:appcompat-v7:$&#123;rootProject.ext.supportLibVersion&#125;"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="管理库和依赖"><a href="#管理库和依赖" class="headerlink" title="管理库和依赖"></a>管理库和依赖</h2><h3 id="使用依赖配置的特定目标构建"><a href="#使用依赖配置的特定目标构建" class="headerlink" title="使用依赖配置的特定目标构建"></a>使用依赖配置的特定目标构建</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">android &#123;...&#125;</span><br><span class="line"></span><br><span class="line">configurations &#123;</span><br><span class="line">  freeDebugApk &#123;&#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    freeCompile <span class="string">'com.google.firebase:firebase-ads:9.8.0'</span></span><br><span class="line">    <span class="function">freeDebugApk <span class="title">fileTree</span><span class="params">(dir: <span class="string">'libs'</span>, include: [<span class="string">'*.jar'</span>])</span></span></span><br><span class="line"><span class="function">    testCompile 'junit:junit:4.12'</span></span><br><span class="line"><span class="function">    androidTestCompile 'com.android.support.test.espresso:espresso-core:2.2.2'</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="发布库的非默认变体"><a href="#发布库的非默认变体" class="headerlink" title="发布库的非默认变体"></a>发布库的非默认变体</h3><p>改变默认构建变体</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    ...</span><br><span class="line">    defaultPublishConfig <span class="string">"demoDebug"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发布所有库的可用构建变体</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    publishNonDefault <span class="keyword">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置应用模块的构建变体，使他们只使用对应的库的构建变体</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">android &#123;...&#125;</span><br><span class="line"></span><br><span class="line">configurations &#123;</span><br><span class="line">    demoDebugCompile &#123;&#125;</span><br><span class="line">    fullReleaseCompile &#123;&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    <span class="function">demoDebugCompile <span class="title">project</span><span class="params">(path: <span class="string">':my-library-module'</span>, configuration: <span class="string">'demoDebug'</span>)</span></span></span><br><span class="line"><span class="function">    fullReleaseCompile <span class="title">project</span><span class="params">(path: <span class="string">':my-library-module'</span>, configuration: <span class="string">'fullRelease'</span>)</span></span></span><br><span class="line"><span class="function">    ...</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="创建应用的不同版本"><a href="#创建应用的不同版本" class="headerlink" title="创建应用的不同版本"></a>创建应用的不同版本</h2><h3 id="配置多APK支持"><a href="#配置多APK支持" class="headerlink" title="配置多APK支持"></a>配置多APK支持</h3><h4 id="配置每个分辨率一个单独APK"><a href="#配置每个分辨率一个单独APK" class="headerlink" title="配置每个分辨率一个单独APK"></a>配置每个分辨率一个单独APK</h4><p>添加<code>android.splits.density</code>块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    ...</span><br><span class="line">    splits &#123;</span><br><span class="line">        density &#123;</span><br><span class="line">            enable <span class="keyword">true</span></span><br><span class="line">            exclude <span class="string">"ldpi"</span>, <span class="string">"mdpi"</span></span><br><span class="line">            <span class="comment">//  清理并包括</span></span><br><span class="line">            <span class="comment">//  reset()</span></span><br><span class="line">            <span class="comment">//  include "hdpi", "xhdpi", "xxhdpi", "xxxhdpi"</span></span><br><span class="line">            compatibleScreens <span class="string">'normal'</span>, <span class="string">'large'</span>, <span class="string">'xlarge'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="配置每个ABI一个单独APK"><a href="#配置每个ABI一个单独APK" class="headerlink" title="配置每个ABI一个单独APK"></a>配置每个ABI一个单独APK</h4><p>添加<code>android.splits.abi</code>块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    ...</span><br><span class="line">    splits &#123;</span><br><span class="line">        abi &#123;</span><br><span class="line">            enable <span class="keyword">true</span></span><br><span class="line">            <span class="comment">//  默认所有ABI都包括，清理</span></span><br><span class="line">            reset()</span><br><span class="line">            include <span class="string">"x86"</span>, <span class="string">"armeabi-v7a"</span>, <span class="string">"mips"</span></span><br><span class="line">            <span class="comment">//  需要生成一个包括所有ABI的APK</span></span><br><span class="line">            universalApk <span class="keyword">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置动态版本号"><a href="#配置动态版本号" class="headerlink" title="配置动态版本号"></a>配置动态版本号</h3><p>默认每个APK都会有同样的版本信息，谷歌商店不支持同一个应用的不同APK有同样的版本信息，你需要确保每个APK有自己独特的<code>versionCode</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        ...</span><br><span class="line">        versionCode <span class="number">4</span></span><br><span class="line">    &#125;</span><br><span class="line">    splits &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Map for the version code that gives each ABI a value.</span></span><br><span class="line">ext.abiCodes = [<span class="string">'armeabi-v7a'</span>:<span class="number">1</span>, mips:<span class="number">2</span>, x86:<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// For per-density APKs, create a similar map like this:</span></span><br><span class="line"><span class="comment">// ext.densityCodes = ['hdpi': 1, 'xhdpi': 2, 'xxhdpi': 3, 'xxxhdpi': 4]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.android.build.OutputFile</span><br><span class="line"></span><br><span class="line"><span class="comment">// For each APK output variant, override versionCode with a combination of</span></span><br><span class="line"><span class="comment">// ext.abiCodes * 1000 + variant.versionCode. In this example, variant.versionCode</span></span><br><span class="line"><span class="comment">// is equal to defaultConfig.versionCode. If you configure product flavors that</span></span><br><span class="line"><span class="comment">// define their own versionCode, variant.versionCode uses that value instead.</span></span><br><span class="line">android.applicationVariants.all &#123; variant -&gt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Assigns a different version code for each output APK</span></span><br><span class="line">    <span class="comment">// other than the universal APK.</span></span><br><span class="line">    variant.outputs.each &#123; output -&gt;</span><br><span class="line">        <span class="comment">// Stores the value of ext.abiCodes that is associated with the ABI for this variant.</span></span><br><span class="line">        <span class="comment">// Determines the ABI for this variant and returns the mapped value.</span></span><br><span class="line">        def baseAbiVersionCode = project.ext.abiCodes.get(output.getFilter(OutputFile.ABI))</span><br><span class="line">        <span class="comment">// Because abiCodes.get() returns null for ABIs that are not mapped by ext.abiCodes,</span></span><br><span class="line">        <span class="comment">// the following code does not override the version code for universal APKs.</span></span><br><span class="line">        <span class="comment">// However, because we want universal APKs to have the lowest version code,</span></span><br><span class="line">        <span class="comment">// this outcome is desirable.</span></span><br><span class="line">        <span class="keyword">if</span> (baseAbiVersionCode != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">// Assigns the new version code to versionCodeOverride, which changes the version code</span></span><br><span class="line">          <span class="comment">// for only the output APK, not for the variant itself. Skipping this step simply</span></span><br><span class="line">          <span class="comment">// causes Gradle to use the value of variant.versionCode for the APK.</span></span><br><span class="line">          output.versionCodeOverride = baseAbiVersionCode * <span class="number">1000</span> + variant.versionCode</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置多个产品风味"><a href="#配置多个产品风味" class="headerlink" title="配置多个产品风味"></a>配置多个产品风味</h3><p>通过<code>flavorDimensions</code>来创建产品风味组，按优先级由高到低排列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    ...</span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        debug &#123;...&#125;</span><br><span class="line">        release &#123;...&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Specifies the flavor dimensions you want to use. The order in which you</span></span><br><span class="line">    <span class="comment">// list each dimension determines its priority, from highest to lowest,</span></span><br><span class="line">    <span class="comment">// when Gradle merges variant sources and configurations. You must assign</span></span><br><span class="line">    <span class="comment">// each product flavor you configure to one of the flavor dimensions.</span></span><br><span class="line">    flavorDimensions <span class="string">"api"</span>, <span class="string">"mode"</span></span><br><span class="line"></span><br><span class="line">    productFlavors &#123;</span><br><span class="line">        demo &#123;</span><br><span class="line">          <span class="comment">// Assigns this product flavor to the "mode" flavor dimension.</span></span><br><span class="line">          dimension <span class="string">"mode"</span></span><br><span class="line">          ...</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        full &#123;</span><br><span class="line">          dimension <span class="string">"mode"</span></span><br><span class="line">          ...</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// Configurations in the "api" product flavors override those in "mode"</span></span><br><span class="line">        <span class="comment">// flavors and the defaultConfig block. Gradle determines the priority</span></span><br><span class="line">        <span class="comment">// between flavor dimensions based on the order in which they appear next</span></span><br><span class="line">        <span class="comment">// to the flavorDimensions property above--the first dimension has a higher</span></span><br><span class="line">        <span class="comment">// priority than the second, and so on.</span></span><br><span class="line">        minApi24 &#123;</span><br><span class="line">          dimension <span class="string">"api"</span></span><br><span class="line">          minSdkVersion <span class="string">'24'</span></span><br><span class="line">          <span class="comment">// To ensure the target device receives the version of the app with</span></span><br><span class="line">          <span class="comment">// the highest compatible API level, assign version codes in increasing</span></span><br><span class="line">          <span class="comment">// value with API level. To learn more about assigning version codes to</span></span><br><span class="line">          <span class="comment">// support app updates and uploading to Google Play, read Multiple APK Support</span></span><br><span class="line">          versionCode <span class="number">30000</span> + android.defaultConfig.versionCode</span><br><span class="line">          versionNameSuffix <span class="string">"-minApi24"</span></span><br><span class="line">          ...</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        minApi23 &#123;</span><br><span class="line">          dimension <span class="string">"api"</span></span><br><span class="line">          minSdkVersion <span class="string">'23'</span></span><br><span class="line">          versionCode <span class="number">20000</span>  + android.defaultConfig.versionCode</span><br><span class="line">          versionNameSuffix <span class="string">"-minApi23"</span></span><br><span class="line">          ...</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        minApi21 &#123;</span><br><span class="line">          dimension <span class="string">"api"</span></span><br><span class="line">          minSdkVersion <span class="string">'21'</span></span><br><span class="line">          versionCode <span class="number">10000</span>  + android.defaultConfig.versionCode</span><br><span class="line">          versionNameSuffix <span class="string">"-minApi21"</span></span><br><span class="line">          ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h3><p>通过<code>variantFilter</code>配置不希望构建的变体</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    ...</span><br><span class="line">    buildTypes &#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    flavorDimensions <span class="string">"api"</span>, <span class="string">"mode"</span></span><br><span class="line">    productFlavors &#123;</span><br><span class="line">        demo &#123;...&#125;</span><br><span class="line">        full &#123;...&#125;</span><br><span class="line">        minApi24 &#123;...&#125;</span><br><span class="line">        minApi23 &#123;...&#125;</span><br><span class="line">        minApi21 &#123;...&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    variantFilter &#123; variant -&gt;</span><br><span class="line">        def names = variant.flavors*.name</span><br><span class="line">        <span class="comment">// To check for a build type instead, use variant.buildType.name == "buildType"</span></span><br><span class="line">        <span class="keyword">if</span> (names.contains(<span class="string">"minApi21"</span>) &amp;&amp; names.contains(<span class="string">"demo"</span>)) &#123;</span><br><span class="line">          <span class="comment">// Gradle ignores any variants that satisfy the conditions above.</span></span><br><span class="line">          setIgnore(<span class="keyword">true</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试应用"><a href="#测试应用" class="headerlink" title="测试应用"></a>测试应用</h2><h3 id="配置Lint"><a href="#配置Lint" class="headerlink" title="配置Lint"></a>配置Lint</h3><p>使用<code>lintOptions</code>配置<code>Lint</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    ...</span><br><span class="line">    lintOptions &#123;</span><br><span class="line">        <span class="comment">// Turns off checks for the issue IDs you specify.</span></span><br><span class="line">        disable <span class="string">'TypographyFractions'</span>,<span class="string">'TypographyQuotes'</span></span><br><span class="line">        <span class="comment">// Turns on checks for the issue IDs you specify. These checks are in</span></span><br><span class="line">        <span class="comment">// addition to the default lint checks.</span></span><br><span class="line">        enable <span class="string">'RtlHardcoded'</span>, <span class="string">'RtlCompat'</span>, <span class="string">'RtlEnabled'</span></span><br><span class="line">        <span class="comment">// To enable checks for only a subset of issue IDs and ignore all others,</span></span><br><span class="line">        <span class="comment">// list the issue IDs with the 'check' property instead. This property overrides</span></span><br><span class="line">        <span class="comment">// any issue IDs you enable or disable using the properties above.</span></span><br><span class="line">        check <span class="string">'NewApi'</span>, <span class="string">'InlinedApi'</span></span><br><span class="line">        <span class="comment">// If set to true, turns off analysis progress reporting by lint.</span></span><br><span class="line">        quiet <span class="keyword">true</span></span><br><span class="line">        <span class="comment">// if set to true (default), stops the build if errors are found.</span></span><br><span class="line">        abortOnError <span class="keyword">false</span></span><br><span class="line">        <span class="comment">// if true, only report errors.</span></span><br><span class="line">        ignoreWarnings <span class="keyword">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="配置测试manifest"><a href="#配置测试manifest" class="headerlink" title="配置测试manifest"></a>配置测试manifest</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Each product flavor you configure can override properties in the</span></span><br><span class="line">    <span class="comment">// defaultConfig block. To learn more, go to Configure Product Flavors.</span></span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// Specifies the application ID for the test APK.</span></span><br><span class="line">        testApplicationId <span class="string">"com.test.foo"</span></span><br><span class="line">        <span class="comment">// Specifies the fully-qualified class name of the test instrumentation runner.</span></span><br><span class="line">        testInstrumentationRunner <span class="string">"android.test.InstrumentationTestRunner"</span></span><br><span class="line">        <span class="comment">// If set to 'true', enables the instrumentation class to start and stop profiling.</span></span><br><span class="line">        <span class="comment">// If set to false (default), profiling occurs the entire time the instrumentation</span></span><br><span class="line">        <span class="comment">// class is running.</span></span><br><span class="line">        testHandleProfiling <span class="keyword">true</span></span><br><span class="line">        <span class="comment">// If set to 'true', indicates that the Android system should run the instrumentation</span></span><br><span class="line">        <span class="comment">// class as a functional test. The default value is 'false'</span></span><br><span class="line">        testFunctionalTest <span class="keyword">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="改变测试构建类型"><a href="#改变测试构建类型" class="headerlink" title="改变测试构建类型"></a>改变测试构建类型</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    ...</span><br><span class="line">    testBuildType <span class="string">"staging"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置Gradle测试选项"><a href="#配置Gradle测试选项" class="headerlink" title="配置Gradle测试选项"></a>配置Gradle测试选项</h3><p>通过<code>testOptions</code>配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Encapsulates options for running tests.</span></span><br><span class="line">    testOptions &#123;</span><br><span class="line">        <span class="comment">// Changes the directory where Gradle saves test reports. By default, Gradle saves test reports</span></span><br><span class="line">        <span class="comment">// in the path_to_your_project/module_name/build/outputs/reports/ directory.</span></span><br><span class="line">        <span class="comment">// '$rootDir' sets the path relative to the root directory of the current project.</span></span><br><span class="line">        reportDir <span class="string">"$rootDir/test-reports"</span></span><br><span class="line">        <span class="comment">// Changes the directory where Gradle saves test results. By default, Gradle saves test results</span></span><br><span class="line">        <span class="comment">// in the path_to_your_project/module_name/build/outputs/test-results/ directory.</span></span><br><span class="line">        <span class="comment">// '$rootDir' sets the path relative to the root directory of the current project.</span></span><br><span class="line">        resultsDir <span class="string">"$rootDir/test-results"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>testOptions.unitTests</code>块仅配置单元测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    ...</span><br><span class="line">    testOptions &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// Encapsulates options for unit tests.</span></span><br><span class="line">        unitTests &#123;</span><br><span class="line">            <span class="comment">// By default, unit tests throw an exception any time the code you are testing tries to access</span></span><br><span class="line">            <span class="comment">// Android platform APIs (unless you mock Android dependencies yourself or with a testing</span></span><br><span class="line">            <span class="comment">// framework like Mockito). However, you can enable the following property so that the test</span></span><br><span class="line">            <span class="comment">// returns either null or zero when accessing platform APIs, rather than throwing an exception.</span></span><br><span class="line">            returnDefaultValues <span class="keyword">true</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// Encapsulates options for controlling how Gradle executes unit tests. For a list</span></span><br><span class="line">            <span class="comment">// of all the options you can specify, read Gradle's reference documentation.</span></span><br><span class="line">            all &#123;</span><br><span class="line">                <span class="comment">// Sets JVM argument(s) for the test JVM(s).</span></span><br><span class="line">                jvmArgs <span class="string">'-XX:MaxPermSize=256m'</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">// You can also check the task name to apply options to only the tests you specify.</span></span><br><span class="line">                <span class="keyword">if</span> (it.name == <span class="string">'testDebug'</span>) &#123;</span><br><span class="line">                  systemProperty <span class="string">'debug'</span>, <span class="string">'true'</span></span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (it.name == <span class="string">'connectedDebugAndroidTest'</span>) &#123;</span><br><span class="line">                  ...</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优化构建"><a href="#优化构建" class="headerlink" title="优化构建"></a>优化构建</h2><h3 id="裁剪代码"><a href="#裁剪代码" class="headerlink" title="裁剪代码"></a>裁剪代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">          minifyEnabled <span class="keyword">true</span></span><br><span class="line">          <span class="function">proguardFiles <span class="title">getDefaultProguardFile</span><span class="params">(<span class="string">'proguard-android-optimize.txt'</span>)</span>, 'proguard-rules.pro'</span></span><br><span class="line"><span class="function">        &#125;</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function">    ...</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p>为不同的构建提供裁剪的`proguar</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    ...</span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">          minifyEnabled <span class="keyword">true</span></span><br><span class="line">          <span class="function">proguardFiles <span class="title">getDefaultProguardFile</span><span class="params">(<span class="string">'proguard-android.txt'</span>)</span>, 'proguard-rules.pro'</span></span><br><span class="line"><span class="function">        &#125;</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function">    productFlavors </span>&#123;</span><br><span class="line">        flavor1 &#123;</span><br><span class="line">          ...</span><br><span class="line">        &#125;</span><br><span class="line">        flavor2 &#123;</span><br><span class="line">          proguardFile <span class="string">'flavor2-rules.pro'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置DEX"><a href="#配置DEX" class="headerlink" title="配置DEX"></a>配置DEX</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    ...</span><br><span class="line">    dexOptions &#123;</span><br><span class="line">        <span class="comment">// Sets the maximum number of DEX processes</span></span><br><span class="line">        <span class="comment">// that can be started concurrently.</span></span><br><span class="line">        maxProcessCount <span class="number">8</span></span><br><span class="line">        <span class="comment">// Sets the maximum memory allocation pool size</span></span><br><span class="line">        <span class="comment">// for the dex operation.</span></span><br><span class="line">        javaMaxHeapSize <span class="string">"2g"</span></span><br><span class="line">        <span class="comment">// Enables Gradle to pre-dex library dependencies.</span></span><br><span class="line">        preDexLibraries <span class="keyword">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="发布应用"><a href="#发布应用" class="headerlink" title="发布应用"></a>发布应用</h2><h3 id="签名"><a href="#签名" class="headerlink" title="签名"></a>签名</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    ...</span><br><span class="line">    defaultConfig &#123; ... &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Encapsulates signing configurations.</span></span><br><span class="line">    signingConfigs &#123;</span><br><span class="line">        <span class="comment">// Creates a signing configuration called "release".</span></span><br><span class="line">        release &#123;</span><br><span class="line">            <span class="comment">// Specifies the path to your keystore file.</span></span><br><span class="line">            <span class="function">storeFile <span class="title">file</span><span class="params">(<span class="string">"my-release-key.jks"</span>)</span></span></span><br><span class="line"><span class="function">            <span class="comment">// Specifies the password for your keystore.</span></span></span><br><span class="line"><span class="function">            storePassword "password"</span></span><br><span class="line"><span class="function">            <span class="comment">// Specifies the identifying name for your key.</span></span></span><br><span class="line"><span class="function">            keyAlias "my-alias"</span></span><br><span class="line"><span class="function">            <span class="comment">// Specifies the password for your key.</span></span></span><br><span class="line"><span class="function">            keyPassword "password"</span></span><br><span class="line"><span class="function">        &#125;</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function">    buildTypes </span>&#123;</span><br><span class="line">        release &#123;</span><br><span class="line">          <span class="comment">// Adds the "release" signing configuration to the release build type.</span></span><br><span class="line">          signingConfig signingConfigs.release</span><br><span class="line">          ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="从工程中移除私人签名信息"><a href="#从工程中移除私人签名信息" class="headerlink" title="从工程中移除私人签名信息"></a>从工程中移除私人签名信息</h3><ol><li>创建<code>keystore.properties</code>目录</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">storePassword=[myStorePassword]</span><br><span class="line">keyPassword=[myKeyPassword]</span><br><span class="line">keyAlias=[myKeyAlias]</span><br><span class="line">storeFile=[myStoreFileLocation]</span><br></pre></td></tr></table></figure><ol><li>在<code>build.gradle</code>中加载<code>keystore.properties</code>文件</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Creates a variable called keystorePropertiesFile, and initializes it to the</span></span><br><span class="line"><span class="comment">// keystore.properties file.</span></span><br><span class="line">def keystorePropertiesFile = rootProject.file(<span class="string">"keystore.properties"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initializes a new Properties() object called keystoreProperties.</span></span><br><span class="line">def keystoreProperties = <span class="keyword">new</span> Properties()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Loads the keystore.properties file into the keystoreProperties object.</span></span><br><span class="line">keystoreProperties.load(<span class="keyword">new</span> FileInputStream(keystorePropertiesFile))</span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">    signingConfigs &#123;</span><br><span class="line">        config &#123;</span><br><span class="line">          keyAlias keystoreProperties[<span class="string">'keyAlias'</span>]</span><br><span class="line">          keyPassword keystoreProperties[<span class="string">'keyPassword'</span>]</span><br><span class="line">          <span class="function">storeFile <span class="title">file</span><span class="params">(keystoreProperties[<span class="string">'storeFile'</span>])</span></span></span><br><span class="line"><span class="function">          storePassword keystoreProperties['storePassword']</span></span><br><span class="line"><span class="function">        &#125;</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function">    ...</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="简化应用开发"><a href="#简化应用开发" class="headerlink" title="简化应用开发"></a>简化应用开发</h2><h3 id="与代码共享自定义域和资源值"><a href="#与代码共享自定义域和资源值" class="headerlink" title="与代码共享自定义域和资源值"></a>与代码共享自定义域和资源值</h3><p>编译时，生成<code>BuildConfig</code>类，所以代码可以获得当前构建的信息，可以在<code>buildConfigField()</code>方法中添加自定义域，在运行时访问，也可以通过<code>resValue()</code>添加资源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    ...</span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            <span class="comment">// These values are defined only for the release build, which</span></span><br><span class="line">            <span class="comment">// is typically used for full builds and continuous builds.</span></span><br><span class="line">            buildConfigField(<span class="string">"String"</span>, <span class="string">"BUILD_TIME"</span>, <span class="string">"\"$&#123;minutesSinceEpoch&#125;\""</span>)</span><br><span class="line">            resValue(<span class="string">"string"</span>, <span class="string">"build_time"</span>, <span class="string">"$&#123;minutesSinceEpoch&#125;"</span>)</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        debug &#123;</span><br><span class="line">            <span class="comment">// Use static values for incremental builds to ensure that</span></span><br><span class="line">            <span class="comment">// resource files and BuildConfig aren't rebuilt with each run.</span></span><br><span class="line">            <span class="comment">// If they were dynamic, they would prevent certain benefits of</span></span><br><span class="line">            <span class="comment">// Instant Run as well as Gradle UP-TO-DATE checks.</span></span><br><span class="line">            buildConfigField(<span class="string">"String"</span>, <span class="string">"BUILD_TIME"</span>, <span class="string">"\"0\""</span>)</span><br><span class="line">            resValue(<span class="string">"string"</span>, <span class="string">"build_time"</span>, <span class="string">"0"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以这样访问他们</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Log.i(TAG, BuildConfig.BUILD_TIME);</span><br><span class="line">Log.i(TAG, getString(R.string.build_time));</span><br></pre></td></tr></table></figure><h3 id="与Manifest共享属性"><a href="#与Manifest共享属性" class="headerlink" title="与Manifest共享属性"></a>与Manifest共享属性</h3><p>有时需要在代码和Manifest中声明同样的属性值，在<code>build.gradle</code>中定义一份多处使用最好</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    <span class="comment">// For settings specific to a product flavor, configure these properties</span></span><br><span class="line">    <span class="comment">// for each flavor in the productFlavors block.</span></span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        <span class="comment">// Creates a property for the FileProvider authority.</span></span><br><span class="line">        def filesAuthorityValue = applicationId + <span class="string">".files"</span></span><br><span class="line">        <span class="comment">// Creates a placeholder property to use in the manifest.</span></span><br><span class="line">        manifestPlaceholders =  [filesAuthority : filesAuthorityValue]</span><br><span class="line">        <span class="comment">// Adds a new field for the authority to the BuildConfig class.</span></span><br><span class="line">        buildConfigField(<span class="string">"String"</span>, <span class="string">"FILES_AUTHORITY"</span>, <span class="string">"\"$&#123;filesAuthorityValue&#125;\""</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Manifest中使用</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;manifest&gt;</span><br><span class="line">    ...</span><br><span class="line">    &lt;application&gt;</span><br><span class="line">        ...</span><br><span class="line">        &lt;provider</span><br><span class="line">          android:name=<span class="string">"android.support.v4.content.FileProvider"</span></span><br><span class="line">          android:authorities=<span class="string">"$&#123;filesAuthority&#125;"</span></span><br><span class="line">          android:exported=<span class="string">"false"</span></span><br><span class="line">          android:grantUriPermissions=<span class="string">"true"</span>&gt;</span><br><span class="line">          ...</span><br><span class="line">        &lt;/provider&gt;</span><br><span class="line">    &lt;/application&gt;</span><br><span class="line">&lt;/manifest&gt;</span><br></pre></td></tr></table></figure><p>代码中使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Uri contentUri = FileProvider.getUriForFile(getContext(), BuildConfig.FILES_AUTHORITY, myFile);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;AndroidStudio里使用Gradle的一些小知识&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://lakeshire.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://lakeshire.github.io/tags/Android/"/>
    
      <category term="Gradle" scheme="http://lakeshire.github.io/tags/Gradle/"/>
    
  </entry>
  
  <entry>
    <title>封装DLNA开源库</title>
    <link href="http://lakeshire.github.io/2017/02/21//archivers/cling-xmly/"/>
    <id>http://lakeshire.github.io/2017/02/21//archivers/cling-xmly/</id>
    <published>2017-02-21T10:00:00.000Z</published>
    <updated>2017-11-28T03:15:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>对Cling类库所做的封装</p><a id="more"></a><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="BaseDeviceItem"><a href="#BaseDeviceItem" class="headerlink" title="BaseDeviceItem"></a>BaseDeviceItem</h2><p>设备基类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseDeviceItem</span> </span>&#123;</span><br><span class="line">    <span class="comment">//  DLNA设备类型</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> mDlnaType;</span><br><span class="line">    <span class="comment">//  AV服务</span></span><br><span class="line">    <span class="keyword">public</span> Service mAVservice;</span><br><span class="line">    <span class="comment">//  RC服务</span></span><br><span class="line">    <span class="keyword">protected</span> Service mRCservice;</span><br><span class="line">    <span class="comment">//  DLNA设备</span></span><br><span class="line">    <span class="keyword">protected</span> DeviceItem mDeviceItem;</span><br><span class="line">    <span class="comment">//  模块表</span></span><br><span class="line">    <span class="keyword">protected</span> HashMap&lt;String, IBaseModule&gt; mModules;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="BaseBindableDeviceItem"><a href="#BaseBindableDeviceItem" class="headerlink" title="BaseBindableDeviceItem"></a>BaseBindableDeviceItem</h3><p>有绑定专辑功能的设备，持有一个<code>BaseItemBindableModel</code></p><h4 id="BaseItemBindableModel"><a href="#BaseItemBindableModel" class="headerlink" title="BaseItemBindableModel"></a>BaseItemBindableModel</h4><p>绑定专辑模型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  每个键上绑定的专辑列表</span></span><br><span class="line"><span class="keyword">protected</span> HashMap&lt;Integer, AlbumM&gt; mAlbums;</span><br><span class="line"><span class="comment">//  名字</span></span><br><span class="line"><span class="keyword">protected</span> List&lt;String&gt; mKeyNames;</span><br><span class="line"><span class="comment">//  图标</span></span><br><span class="line"><span class="keyword">protected</span> List&lt;Integer&gt; mKeyImages;</span><br></pre></td></tr></table></figure><h4 id="CommonDevice"><a href="#CommonDevice" class="headerlink" title="CommonDevice"></a>CommonDevice</h4><p>支持喜马拉雅协议的通用设备</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonDeviceItem</span> <span class="keyword">extends</span> <span class="title">BaseBindableDeviceItem</span> </span>&#123;</span><br><span class="line">    <span class="comment">//  PQ服务</span></span><br><span class="line"><span class="keyword">protected</span> Service mPQservice;</span><br><span class="line"><span class="comment">//  MM服务</span></span><br><span class="line"><span class="keyword">protected</span> Service mMMservice;</span><br><span class="line"><span class="comment">//  当前播放的数据结构</span></span><br><span class="line"><span class="keyword">protected</span> BaseCurrentPlayingModel mCurrentPlayingModel = <span class="keyword">new</span> BaseCurrentPlayingModel();</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>BaseCurrentPlayingModel</code>保存当前播放的数据结构，如当前页，当前列表，当前曲目数deng</p><h2 id="LinkedDeviceModel"><a href="#LinkedDeviceModel" class="headerlink" title="LinkedDeviceModel"></a>LinkedDeviceModel</h2><ul><li>持有一个BaseDeviceItem</li><li>管理播放状态：播放、停止</li><li>管理音量</li><li>透过它获得设备的AV和RC服务</li></ul><h2 id="IDlnaController"><a href="#IDlnaController" class="headerlink" title="IDlnaController"></a>IDlnaController</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IDlnaController</span> </span>&#123;</span><br><span class="line">    <span class="comment">//  基本信息：设备类型、UDN</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getDeviceType</span><span class="params">()</span></span>;</span><br><span class="line">    String[] getCheckedUdn();</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isThisDeviceType</span><span class="params">(BaseDeviceItem deviceItem)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  设备管理</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addDeivce</span><span class="params">(BaseDeviceItem myDeviceItem)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">removeDeivce</span><span class="params">(BaseDeviceItem myDeviceItem)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearDeivce</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">List&lt;BaseDeviceItem&gt; <span class="title">getAllDevices</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isThisDevice</span><span class="params">(BaseDeviceItem deviceItem)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  模块管理</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initModules</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">IBaseModule <span class="title">getModule</span><span class="params">(String moduleName)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setModule</span><span class="params">(IBaseModule baseModule)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onCommandFailed</span><span class="params">(ActionModel model)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  获取设备信息，如绑定专辑、内置声音</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initDeviceInfo</span><span class="params">(BaseDeviceItem deviceItem, IActionCallBack callBack)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在默认的推送后面加上额外的操作，如订阅更多种类的事件</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tuisongExtra</span><span class="params">(BasePlayManageController basePlayManageController)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  播放声音</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">playSound</span><span class="params">(BaseDeviceItem baseDeviceItem, ActionModel model)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  切换到本地</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change2Bendi</span><span class="params">(BasePlayManageController basePlayManageController)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="BaseDlnaController"><a href="#BaseDlnaController" class="headerlink" title="BaseDlnaController"></a>BaseDlnaController</h3><p>DLNA控制器基类，实现<code>IDlnaController</code>接口，维护了设备列表、模块表、<code>ControlPoint</code>，功能还需要子类实现</p><h4 id="CommonController"><a href="#CommonController" class="headerlink" title="CommonController"></a>CommonController</h4><p>实现了通用的功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tuisongExtra</span><span class="params">(BasePlayManageController basePlayManageController)</span> </span>&#123;</span><br><span class="line">    CommonDeviceItem commonDeviceItem = (CommonDeviceItem) basePlayManageController.getLinkedDeviceModel().getNowDeviceItem();</span><br><span class="line">    <span class="keyword">if</span> (commonDeviceItem.getPQservice() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        basePlayManageController.setPlayQueueSubscriptionCallback(<span class="keyword">new</span> MyPlaySubscriptionCallback(commonDeviceItem.getPQservice(), <span class="number">600</span>, basePlayManageController));</span><br><span class="line">        getControlPoint().execute(basePlayManageController.getPlayQueueSubscriptionCallback());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (commonDeviceItem.getMMservice() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        basePlayManageController.setMediaManagerSubscriptionCallback(<span class="keyword">new</span> MyPlaySubscriptionCallback(commonDeviceItem.getMMservice(), <span class="number">600</span>, basePlayManageController));</span><br><span class="line">        getControlPoint().execute(basePlayManageController.getMediaManagerSubscriptionCallback());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>tuisongExtra()</code>里主要订阅了播放列表<code>PQService</code>和媒体管理<code>MMService</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">change2Bendi</span><span class="params">(BasePlayManageController basePlayManageController)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (basePlayManageController.getPlayQueueSubscriptionCallback() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        basePlayManageController.getPlayQueueSubscriptionCallback().end();</span><br><span class="line">        basePlayManageController.setPlayQueueSubscriptionCallback(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (basePlayManageController.getMediaManagerSubscriptionCallback() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        basePlayManageController.getMediaManagerSubscriptionCallback().end();</span><br><span class="line">        basePlayManageController.setMediaManagerSubscriptionCallback(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>change2Bendi()</code>里进行了退订</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playSound</span><span class="params">(BaseDeviceItem baseDeviceItem, ActionModel model)</span> </span>&#123;</span><br><span class="line">    BaseTuiSongModule tuiSongModule = (BaseTuiSongModule) getModule(BaseTuiSongModule.NAME);</span><br><span class="line">    <span class="keyword">if</span> (tuiSongModule == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    tuiSongModule.tuisong(baseDeviceItem, model);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>playSound()</code>通过<code>BaseTuiSongModule</code>的<code>tuisong()</code>实现</p><h2 id="DlnaControllerFactory"><a href="#DlnaControllerFactory" class="headerlink" title="DlnaControllerFactory"></a>DlnaControllerFactory</h2><p>通过这个工厂类生成了控制器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DlnaControllerFactory</span> </span>&#123;</span><br><span class="line">    List&lt;IDlnaControllerCreator&gt; mCreators;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//  调用所有构造器的设备添加回调</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildController</span><span class="params">(BaseDeviceItem baseDeviceItem)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mCreators.size(); i++) &#123;</span><br><span class="line">mCreators.get(i).onDeviceAdded(baseDeviceItem);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>保存了一组控制器的构造器，创建时根据控制器的类型选择合适的构造器构造控制器</p><h3 id="IDlnaControllerCreator"><a href="#IDlnaControllerCreator" class="headerlink" title="IDlnaControllerCreator"></a>IDlnaControllerCreator</h3><p>控制器构造器接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IDlnaControllerCreator</span> </span>&#123;</span><br><span class="line">    <span class="comment">//  设备添加回调</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onDeviceAdded</span><span class="params">(BaseDeviceItem baseDeviceItem)</span></span>;</span><br><span class="line">    <span class="comment">//  创建控制器</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buildController</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//  子类实现，返回控制器类型</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getControllerType</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="AbsControllerCreator"><a href="#AbsControllerCreator" class="headerlink" title="AbsControllerCreator"></a>AbsControllerCreator</h4><p>一个抽象的实现类，构造函数再<code>DlnaManager</code>中添加了一个控制器<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbsControllerCreator</span> <span class="keyword">implements</span> <span class="title">IDlnaControllerCreator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Context mContext;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbsControllerCreator</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        DlnaManager.getInstance(context).addControllerCreator(<span class="keyword">this</span>);</span><br><span class="line">        mContext = context;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="CometController"><a href="#CometController" class="headerlink" title="CometController"></a>CometController</h5><p>举个<code>Comet</code>设备的例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CometControllerCreator</span> <span class="keyword">extends</span> <span class="title">AbsControllerCreator</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDeviceAdded</span><span class="params">(BaseDeviceItem baseDeviceItem)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//  获得设备UDN</span></span><br><span class="line">        String udn = baseDeviceItem.getDevice().getIdentity().getUdn().toString();</span><br><span class="line">        <span class="comment">//  判断UDN是否包含COMET设备的头信息</span></span><br><span class="line">        <span class="keyword">if</span> (udn.contains(CometController.DEVICE_COMET_HEADER)) &#123;</span><br><span class="line">            baseDeviceItem.setDlnaType(DeviceType.comet);</span><br><span class="line">            DlnaManager.getInstance(mContext).getController(DeviceType.comet).addDeivce(baseDeviceItem);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getControllerType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> DeviceType.comet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BaseDlnaModule"><a href="#BaseDlnaModule" class="headerlink" title="BaseDlnaModule"></a>BaseDlnaModule</h2><p>DLNA功能模块基础类<br>功能的实现都差不多，通过发送的<code>ActionCallback</code>不同来区分</p><ul><li>BasePlayModule</li><li>BaseDownloadModule</li><li>BaseDlnaKeyModule</li><li>BaseTuisongModule</li><li>BaseManageTFModule</li><li>BaseBindModule</li></ul><h1 id="DlnaManager"><a href="#DlnaManager" class="headerlink" title="DlnaManager"></a>DlnaManager</h1><p>DLNA功能的管理器，持有一个<code>CoreController</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DlnaManager</span> </span>&#123;</span><br><span class="line">    <span class="comment">//  核心控制器</span></span><br><span class="line">    <span class="keyword">public</span> CoreController mCoreController;</span><br><span class="line">    <span class="comment">//  播放事件管理</span></span><br><span class="line">    <span class="keyword">private</span> PlayManageController mPlayManageController; </span><br><span class="line">    <span class="keyword">private</span> OperationStorageModel mOperationStroageModel;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Integer, IDlnaController&gt; mContrllerMap;</span><br><span class="line">    <span class="keyword">private</span> CopyOnWriteArrayList&lt;OnDeviceChangedListener&gt; mOnDeviceChangedListeners;</span><br><span class="line">    <span class="keyword">private</span> CopyOnWriteArrayList&lt;OnKeyEventListener&gt; mOnkeyEventListeners;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>设备管理</li><li>控制器管理</li><li>播放控制</li></ul><h2 id="CoreController"><a href="#CoreController" class="headerlink" title="CoreController"></a>CoreController</h2><p>核心控制器，<code>BasePlayManageController</code>的子类</p><h3 id="绑定服务"><a href="#绑定服务" class="headerlink" title="绑定服务"></a>绑定服务</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bindService</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    deviceListRegistryListener = <span class="keyword">new</span> DeviceListRegistryListener();</span><br><span class="line">    mIsBind = mContext.bindService(<span class="keyword">new</span> Intent(mContext, DmcUpnpService.class), serviceConnection, Context.BIND_AUTO_CREATE);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> ServiceConnection serviceConnection = <span class="keyword">new</span> ServiceConnection() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName className, IBinder service)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        upnpService = (UpnpServiceBinder) service;</span><br><span class="line">        <span class="comment">//  为这个服务提供CoreUpnpServiceListener</span></span><br><span class="line">        upnpService.setProcessor(coreUpnpServiceListener);</span><br><span class="line">        ...    </span><br><span class="line">        <span class="comment">//  在Registry中添加DeviceListRegistryListener</span></span><br><span class="line">        upnpService.getRegistry().addListener(deviceListRegistryListener);</span><br><span class="line">        <span class="comment">//  移除所有的远端和本地设备</span></span><br><span class="line">        upnpService.getRegistry().removeAllRemoteDevices(<span class="keyword">true</span>);</span><br><span class="line">        upnpService.getRegistry().removeAllLocalDevices();</span><br><span class="line">        <span class="comment">//  搜索设备</span></span><br><span class="line">        searchDevice();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName className)</span> </span>&#123;</span><br><span class="line">        upnpService = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>初始化，绑定到<code>DmcUpnpService</code></p><h4 id="CoreUpnpServiceListener"><a href="#CoreUpnpServiceListener" class="headerlink" title="CoreUpnpServiceListener"></a>CoreUpnpServiceListener</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CoreUpnpServiceListener</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onNetworkChanged</span><span class="params">(NetworkInterface ni)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onRouterError</span><span class="params">(String message)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onRouterDisabled</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onRouterEnabled</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>监听网络状态和路由状态</p><h4 id="DeviceListRegistryListener"><a href="#DeviceListRegistryListener" class="headerlink" title="DeviceListRegistryListener"></a>DeviceListRegistryListener</h4><p>实现接口<code>RegistryListener</code>，这个接口主要用来通知设备的添加、删除和更新</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RegistryListener</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remoteDeviceDiscoveryStarted</span><span class="params">(Registry registry, RemoteDevice device)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remoteDeviceDiscoveryFailed</span><span class="params">(Registry registry, RemoteDevice device, Exception ex)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remoteDeviceAdded</span><span class="params">(Registry registry, RemoteDevice device)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remoteDeviceUpdated</span><span class="params">(Registry registry, RemoteDevice device)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remoteDeviceRemoved</span><span class="params">(Registry registry, RemoteDevice device)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">localDeviceAdded</span><span class="params">(Registry registry, LocalDevice device)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">localDeviceRemoved</span><span class="params">(Registry registry, LocalDevice device)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">beforeShutdown</span><span class="params">(Registry registry)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">afterShutdown</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="搜索设备"><a href="#搜索设备" class="headerlink" title="搜索设备"></a>搜索设备</h3><p>通过<code>startScanThread()</code>和<code>stopScanThread()</code>方法<br>创建<code>ScanThread</code>搜索设备，最终调用<code>upnpService.getControlPoint().search()</code></p><h3 id="设备管理"><a href="#设备管理" class="headerlink" title="设备管理"></a>设备管理</h3><p>通过<code>removeDevice()</code>和<code>removeAllDevices()</code>移除设备<br>最终调用<code>Registry</code>中的移除设备的方法</p><h3 id="按键处理"><a href="#按键处理" class="headerlink" title="按键处理"></a>按键处理</h3><p>实现了<code>MyPlaySubscriptionCallback.OnPlayKeyHandler</code>接口<br>通过<code>BaseDlnaKeyModule</code>把<code>GENASubscription</code>结构转化为<code>KeyEvent</code>，然后调用<code>OnCoreControllerListener.onKeyAciton()</code></p><h4 id="OnCoreControllerListener"><a href="#OnCoreControllerListener" class="headerlink" title="OnCoreControllerListener"></a>OnCoreControllerListener</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OnCoreControllerListener</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onDeviceAdded</span><span class="params">(BaseDeviceItem baseDeviceItem)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onDeviceRemoved</span><span class="params">(BaseDeviceItem baseDeviceItem)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onNetworkChanged</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onKeyAciton</span><span class="params">(KeyEvent keyEvent)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>暴露给<code>DlnaManager</code>的接口，处理设备添加、设备删除、网络变化和按键事件</p><h3 id="播放控制"><a href="#播放控制" class="headerlink" title="播放控制"></a>播放控制</h3><p>包括推送到设备、切换到本地、(继续)播放、上一曲、下一曲、暂停、停止</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tuisongDevice</span><span class="params">(BaseDeviceItem baseDeviceItem)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isUpnpServiceCanUse()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  如果当前没有操作的设备就创建一个</span></span><br><span class="line">    <span class="keyword">if</span> (mLinkedDeviceModel == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mLinkedDeviceModel = <span class="keyword">new</span> LinkedDeviceModel();</span><br><span class="line">    &#125;</span><br><span class="line">    mLinkedDeviceModel.setNowDeviceItem(baseDeviceItem);</span><br><span class="line">    <span class="comment">//  获得一个控制器</span></span><br><span class="line">    mNowDlnaController = mDlnaManager.getController(baseDeviceItem.getDlnaType());</span><br><span class="line">    <span class="keyword">if</span> (mNowDlnaController == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里推送需要重新重新新建订阅，两台设备切换的情况，一直只会订阅第一台设备</span></span><br><span class="line">    mPlaySubscriptionCallback = <span class="keyword">new</span> MyPlaySubscriptionCallback(mLinkedDeviceModel.getAvService(), <span class="number">600</span>, <span class="keyword">this</span>);</span><br><span class="line">    upnpService.getControlPoint().execute(mPlaySubscriptionCallback);</span><br><span class="line">    mNowDlnaController.tuisongExtra(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先通过<code>tuisongDevice()</code>确定要操作的设备，获得该设备类型的控制器，然后调用<code>IDlnaController.tuisongExtra()</code></p><h3 id="音量控制"><a href="#音量控制" class="headerlink" title="音量控制"></a>音量控制</h3><h3 id="进度条控制"><a href="#进度条控制" class="headerlink" title="进度条控制"></a>进度条控制</h3><p>提供了<code>setSeekBar</code>设置进度条，以及<code>PositionThread</code>来周期性获得播放进度</p><h3 id="BasePlayManageController"><a href="#BasePlayManageController" class="headerlink" title="BasePlayManageController"></a>BasePlayManageController</h3><ul><li>持有一个<code>LinkedDeviceModel</code>，记录正在操作的设备</li><li>订阅事件相关处理</li><li>实现了<code>MyPlaySubscriptionCallback.OnPlayKeyHandler</code>接口（并没实现，仍需要子类实现）</li></ul><h2 id="DmcUpnpService"><a href="#DmcUpnpService" class="headerlink" title="DmcUpnpService"></a>DmcUpnpService</h2><p>通过绑定这个服务调用<code>UpnpService</code>提供的功能，返回<code>AndroidUpnpService</code>接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AndroidUpnpService</span> </span>&#123;</span><br><span class="line">    <span class="function">UpnpService <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">UpnpServiceConfiguration <span class="title">getConfiguration</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Registry <span class="title">getRegistry</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">ControlPoint <span class="title">getControlPoint</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>createUpnpService()</code>创建一个UPnP服务，提供配置、路由等信息</p><h1 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h1><h2 id="搜索设备-1"><a href="#搜索设备-1" class="headerlink" title="搜索设备"></a>搜索设备</h2><h2 id="发送命令"><a href="#发送命令" class="headerlink" title="发送命令"></a>发送命令</h2><h2 id="按键事件"><a href="#按键事件" class="headerlink" title="按键事件"></a>按键事件</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对Cling类库所做的封装&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://lakeshire.github.io/categories/Android/"/>
    
    
      <category term="DLNA" scheme="http://lakeshire.github.io/tags/DLNA/"/>
    
      <category term="Cling" scheme="http://lakeshire.github.io/tags/Cling/"/>
    
  </entry>
  
  <entry>
    <title>DLNA开源库——Cling</title>
    <link href="http://lakeshire.github.io/2017/02/13//archivers/cling/"/>
    <id>http://lakeshire.github.io/2017/02/13//archivers/cling/</id>
    <published>2017-02-13T10:00:00.000Z</published>
    <updated>2017-11-28T03:14:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>Cling是由Java实现的<code>DLNA/UPnP</code>协议栈。可以开发出类似多屏互动、资源共享、远程控制等功能的应用，通过Android 应用管理一个或多个设备，将音频、视频、图片推送到指定设备显示</p><a id="more"></a><h2 id="Meta"><a href="#Meta" class="headerlink" title="Meta"></a>Meta</h2><h3 id="ActionInvocation"><a href="#ActionInvocation" class="headerlink" title="ActionInvocation"></a>ActionInvocation</h3><p>动作请求的输入、输出和失败值</p><h3 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h3><p>描述一个动作和它的输入输出参数</p><h3 id="ActionExecutor"><a href="#ActionExecutor" class="headerlink" title="ActionExecutor"></a>ActionExecutor</h3><p>处理<code>ActionInvocation</code>的处理器</p><h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><p>服务的元数据，里面维护了一组<code>Action</code>，有<code>LocalService</code>和<code>RemoteService</code>两个子类</p><h4 id="LocalService"><a href="#LocalService" class="headerlink" title="LocalService"></a>LocalService</h4><p>本地创建服务的元数据，维护了一张对应<code>Action</code>的<code>ActionExecutor</code>表</p><h4 id="RemoteService"><a href="#RemoteService" class="headerlink" title="RemoteService"></a>RemoteService</h4><p>远程设备上发现服务的元数据，包括获取服务描述的URI，调用它的<code>Action</code>和订阅事件</p><h3 id="Resource"><a href="#Resource" class="headerlink" title="Resource"></a>Resource</h3><p>一个可寻址的对象，通过<code>Registry</code>存储、管理和访问，对不同的资源有若干子类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Resource</span>&lt;<span class="title">M</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> URI pathQuery;</span><br><span class="line">    <span class="keyword">private</span> M model;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ServiceControlResource"><a href="#ServiceControlResource" class="headerlink" title="ServiceControlResource"></a>ServiceControlResource</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceControlResource</span> <span class="keyword">extends</span> <span class="title">Resource</span>&lt;<span class="title">LocalService</span>&gt; </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Device"><a href="#Device" class="headerlink" title="Device"></a>Device</h3><p>描述一个设备，根或者嵌套的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Device</span>&lt;<span class="title">DI</span> <span class="keyword">extends</span> <span class="title">DeviceIdentity</span>, <span class="title">D</span> <span class="keyword">extends</span> <span class="title">Device</span>, <span class="title">S</span> <span class="keyword">extends</span> <span class="title">Service</span>&gt; <span class="keyword">implements</span> <span class="title">Validatable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">private</span> DI identity;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">private</span> UDAVersion version;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">private</span> DeviceType type;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">private</span> DeviceDetails details;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">private</span> Icon[] icons;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">protected</span> S[] services;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">protected</span> D[] embeddedDevices;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="RemoteDevice"><a href="#RemoteDevice" class="headerlink" title="RemoteDevice"></a>RemoteDevice</h4><p>网络上发现的设备</p><h4 id="LocalDevice"><a href="#LocalDevice" class="headerlink" title="LocalDevice"></a>LocalDevice</h4><p>本地创建的设备</p><h3 id="DeviceIdentity"><a href="#DeviceIdentity" class="headerlink" title="DeviceIdentity"></a>DeviceIdentity</h3><p>唯一的设备名，在网络发现时提供和接收</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeviceIdentity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">private</span> UDN udn;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">private</span> Integer maxAgeSeconds;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="RemoteDeviceIdentity"><a href="#RemoteDeviceIdentity" class="headerlink" title="RemoteDeviceIdentity"></a>RemoteDeviceIdentity</h4><p>远程设备的额外信息，包括设备描述的URL，未来应该使用的本地网络接口，可能有对方设备的MAC</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoteDeviceIdentity</span> <span class="keyword">extends</span> <span class="title">DeviceIdentity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">private</span> URL descriptorURL;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">private</span> <span class="keyword">byte</span>[] interfaceMacAddress;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">private</span> InetAddress discoveredOnLocalAddress;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="GENASubscription"><a href="#GENASubscription" class="headerlink" title="GENASubscription"></a>GENASubscription</h2><p>建立的订阅，有标识符、过期时间、序列处理和状态变量值，本地订阅和远端订阅都维护在<code>Registry</code>里</p><h3 id="LocalGENASubscription"><a href="#LocalGENASubscription" class="headerlink" title="LocalGENASubscription"></a>LocalGENASubscription</h3><p>对于本地服务的订阅，即其他设备对自己的订阅</p><h3 id="RemoteGENASubscription"><a href="#RemoteGENASubscription" class="headerlink" title="RemoteGENASubscription"></a>RemoteGENASubscription</h3><p>对于远端服务的订阅，即自己对其他设备的订阅，一旦建立，当从远端服务接收事件时会调用<code>eventReceived()</code></p><h2 id="ControlPoint"><a href="#ControlPoint" class="headerlink" title="ControlPoint"></a>ControlPoint</h2><p>异步执行网络搜索、操作、事件订阅的统一接口，后面的所有操作都要用到它</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ControlPoint</span> </span>&#123;</span><br><span class="line">    <span class="function">UpnpServiceConfiguration <span class="title">getConfiguration</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">ProtocolFactory <span class="title">getProtocolFactory</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Registry <span class="title">getRegistry</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(UpnpHeader searchType)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> mxSeconds)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(UpnpHeader searchType, <span class="keyword">int</span> mxSeconds)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(ActionCallback callback)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(SubscriptionCallback callback)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要是<code>search()</code>和<code>execute()</code>接口，<code>ControlPointImpl</code>是提供的实现类</p><h3 id="ControlPointImpl"><a href="#ControlPointImpl" class="headerlink" title="ControlPointImpl"></a>ControlPointImpl</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(ActionCallback callback)</span> </span>&#123;</span><br><span class="line">    callback.setControlPoint(<span class="keyword">this</span>);</span><br><span class="line">    getConfiguration().getSyncProtocolExecutor().execute(callback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中一个<code>execute()</code>，其实就是获得配置中给定的线程池，把命令放进去执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">search</span><span class="params">(UpnpHeader searchType, <span class="keyword">int</span> mxSeconds)</span> </span>&#123;</span><br><span class="line">        getConfiguration().getAsyncProtocolExecutor().execute(getProtocolFactory().createSendingSearch(searchType, mxSeconds));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以发现<code>search()</code>也是通过<code>execute()</code>实现的</p><h2 id="ActionCallback"><a href="#ActionCallback" class="headerlink" title="ActionCallback"></a>ActionCallback</h2><p>执行的动作基类，它是个可执行的<code>Runnable</code>，主要关注它的<code>run()</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Service service = actionInvocation.getAction().getService();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Local execution</span></span><br><span class="line">    <span class="keyword">if</span> (service <span class="keyword">instanceof</span> LocalService) &#123;</span><br><span class="line">        LocalService localService = (LocalService) service;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Executor validates input inside the execute() call immediately</span></span><br><span class="line">        localService.getExecutor(actionInvocation.getAction()).execute(actionInvocation);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (actionInvocation.getFailure() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            failure(actionInvocation, <span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            success(actionInvocation);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remote execution</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (service <span class="keyword">instanceof</span> RemoteService) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (getControlPoint() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Callback must be executed through ControlPoint"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        RemoteService remoteService = (RemoteService) service;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Figure out the remote URL where we'd like to send the action</span></span><br><span class="line">        <span class="comment">// request to</span></span><br><span class="line">        URL controLURL = remoteService.getDevice().normalizeURI(remoteService.getControlURI());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Do it</span></span><br><span class="line">        SendingAction prot = getControlPoint().getProtocolFactory().createSendingAction(actionInvocation, controLURL);</span><br><span class="line">        prot.run();</span><br><span class="line"></span><br><span class="line">        IncomingActionResponseMessage response = prot.getOutputMessage();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (response == <span class="keyword">null</span>) &#123;</span><br><span class="line">            failure(actionInvocation, <span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (response.getOperation().isFailed()) &#123;</span><br><span class="line">            failure(actionInvocation, response.getOperation());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            success(actionInvocation);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分为本地服务和远程服务，远程服务的话通过控制点发命令给目标URL，然后等待响应</p><p><code>org.teleal.cling.support</code>包里都是<code>ActionCallback</code>的子类，仿照库里提供的一些命令可以很方便的根据协议添加</p><p>一般都是在构造函数中提供字段，并且实现<code>success()</code>和<code>fail()</code>方法供回调，成功或失败后的处理经常不一样，所以一般在使用命令的地方实现一个这样的类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Service service = device.findService(<span class="keyword">new</span> UDAServiceId(<span class="string">"SwitchPower"</span>));</span><br><span class="line">Action getStatusAction = service.getAction(<span class="string">"GetStatus"</span>);</span><br><span class="line">ActionInvocation getStatusInvocation = <span class="keyword">new</span> ActionInvocation(getStatusAction);</span><br><span class="line">ActionCallback getStatusCallback = <span class="keyword">new</span> ActionCallback(getStatusInvocation) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">success</span><span class="params">(ActionInvocation invocation)</span> </span>&#123;</span><br><span class="line">        ActionArgumentValue status = invocation.getOutput(<span class="string">"ResultStatus"</span>);</span><br><span class="line">        assertEquals((Boolean) status.getValue(), Boolean.valueOf(<span class="keyword">false</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failure</span><span class="params">(ActionInvocation invocation, UpnpResponse res)</span> </span>&#123;</span><br><span class="line">        System.err.println(createDefaultFailureMessage(invocation, res));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">upnpService.getControlPoint().execute(getStatusCallback);</span><br></pre></td></tr></table></figure><p>注释中提供的示例代码</p><h2 id="SubscriptionCallback"><a href="#SubscriptionCallback" class="headerlink" title="SubscriptionCallback"></a>SubscriptionCallback</h2><p>订阅和接受事件，通过<code>GENA</code>，它也是一个<code>Runnable</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">   <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (getControlPoint() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Callback must be executed through ControlPoint"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (getService() <span class="keyword">instanceof</span> LocalService) &#123;</span><br><span class="line">        establishLocalSubscription((LocalService) service);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (getService() <span class="keyword">instanceof</span> RemoteService) &#123;</span><br><span class="line">        establishRemoteSubscription((RemoteService) service);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也是分为本地服务和远程服务的订阅</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">establishRemoteSubscription</span><span class="params">(RemoteService service)</span> </span>&#123;</span><br><span class="line">    RemoteGENASubscription remoteSubscription = <span class="keyword">new</span> RemoteGENASubscription(service, requestedDurationSeconds) &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(UpnpResponse responseStatus)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (SubscriptionCallback.<span class="keyword">this</span>) &#123;</span><br><span class="line">                SubscriptionCallback.<span class="keyword">this</span>.setSubscription(<span class="keyword">null</span>);</span><br><span class="line">                SubscriptionCallback.<span class="keyword">this</span>.failed(<span class="keyword">this</span>, responseStatus, <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">established</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (SubscriptionCallback.<span class="keyword">this</span>) &#123;</span><br><span class="line">                SubscriptionCallback.<span class="keyword">this</span>.setSubscription(<span class="keyword">this</span>);</span><br><span class="line">                SubscriptionCallback.<span class="keyword">this</span>.established(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ended</span><span class="params">(CancelReason reason, UpnpResponse responseStatus)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (SubscriptionCallback.<span class="keyword">this</span>) &#123;</span><br><span class="line">                SubscriptionCallback.<span class="keyword">this</span>.setSubscription(<span class="keyword">null</span>);</span><br><span class="line">                SubscriptionCallback.<span class="keyword">this</span>.ended(<span class="keyword">this</span>, reason, responseStatus);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eventReceived</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (SubscriptionCallback.<span class="keyword">this</span>) &#123;</span><br><span class="line">                SubscriptionCallback.<span class="keyword">this</span>.eventReceived(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eventsMissed</span><span class="params">(<span class="keyword">int</span> numberOfMissedEvents)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (SubscriptionCallback.<span class="keyword">this</span>) &#123;</span><br><span class="line">                SubscriptionCallback.<span class="keyword">this</span>.eventsMissed(<span class="keyword">this</span>, numberOfMissedEvents);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    getControlPoint().getProtocolFactory().createSendingSubscribe(remoteSubscription).run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>failed()</code>、<code>established()</code>、<code>ended()</code>、<code>eventReceived()</code>、<code>eventMissed()</code>都需要子类实现</p><h2 id="Registry"><a href="#Registry" class="headerlink" title="Registry"></a>Registry</h2><p>UPNP协议栈的核心，追踪设备和资源，一个运行的UPNP栈有一个<code>Registry</code>，任何被发现的设备被添加到这个<code>Registry</code>里，暴露的本地设备也是一样，然后会持续的维持这些设备，必要时刷新他们的声明，过期时移除他们，同样追踪<code>GENA</code>事件订阅</p><h2 id="ProtocolFactory"><a href="#ProtocolFactory" class="headerlink" title="ProtocolFactory"></a>ProtocolFactory</h2><p>UPNP协议的工厂，工厂创建可执行的协议基于接收到的UPNP消息，或者本地设备/搜索/服务的元数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProtocolFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">UpnpService <span class="title">getUpnpService</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  创建异步接收通知/搜索/搜索响应</span></span><br><span class="line">    <span class="function">ReceivingAsync <span class="title">createReceivingAsync</span><span class="params">(IncomingDatagramMessage message)</span> <span class="keyword">throws</span> ProtocolCreationException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  创建同步接收动作/订阅/退订/事件</span></span><br><span class="line">    <span class="function">ReceivingSync <span class="title">createReceivingSync</span><span class="params">(StreamRequestMessage requestMessage)</span> <span class="keyword">throws</span> ProtocolCreationException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  声明本地设备</span></span><br><span class="line">    <span class="function">SendingNotificationAlive <span class="title">createSendingNotificationAlive</span><span class="params">(LocalDevice localDevice)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  移除本地设备</span></span><br><span class="line">    <span class="function">SendingNotificationByebye <span class="title">createSendingNotificationByebye</span><span class="params">(LocalDevice localDevice)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  搜索广播</span></span><br><span class="line">    <span class="function">SendingSearch <span class="title">createSendingSearch</span><span class="params">(UpnpHeader searchTarget, <span class="keyword">int</span> mxSeconds)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  发送命令</span></span><br><span class="line">    <span class="function">SendingAction <span class="title">createSendingAction</span><span class="params">(ActionInvocation actionInvocation, URL controlURL)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  发送订阅</span></span><br><span class="line">    <span class="function">SendingSubscribe <span class="title">createSendingSubscribe</span><span class="params">(RemoteGENASubscription subscription)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  发送续订</span></span><br><span class="line">    <span class="function">SendingRenewal <span class="title">createSendingRenewal</span><span class="params">(RemoteGENASubscription subscription)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  发送退订</span></span><br><span class="line">    <span class="function">SendingUnsubscribe <span class="title">createSendingUnsubscribe</span><span class="params">(RemoteGENASubscription subscription)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  发送事件</span></span><br><span class="line">    <span class="function">SendingEvent <span class="title">createSendingEvent</span><span class="params">(LocalGENASubscription subscription)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ProtocolFactoryImpl"><a href="#ProtocolFactoryImpl" class="headerlink" title="ProtocolFactoryImpl"></a>ProtocolFactoryImpl</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ReceivingAsync <span class="title">createReceivingAsync</span><span class="params">(IncomingDatagramMessage message)</span> <span class="keyword">throws</span> ProtocolCreationException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (message.getOperation() <span class="keyword">instanceof</span> UpnpRequest) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (incomingRequest.getOperation().getMethod()) &#123;</span><br><span class="line">            <span class="keyword">case</span> NOTIFY:</span><br><span class="line">                <span class="keyword">return</span> isByeBye(incomingRequest) || isSupportedServiceAdvertisement(incomingRequest) ? <span class="keyword">new</span> ReceivingNotification(getUpnpService(), incomingRequest) : <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">case</span> MSEARCH:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> ReceivingSearch(getUpnpService(), incomingRequest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (message.getOperation() <span class="keyword">instanceof</span> UpnpResponse) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ReceivingSearchResponse(getUpnpService(), incomingResponse);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建接收异步消息的协议，分为请求和响应，其中请求包括通知<code>ReceivingNotification()</code>和搜索<code>ReceivingSearch()</code>，响应就是搜索结果的响应<code>ReceivingSearchResponse()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ReceivingSync <span class="title">createReceivingSync</span><span class="params">(StreamRequestMessage message)</span> <span class="keyword">throws</span> ProtocolCreationException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (message.getOperation().getMethod().equals(UpnpRequest.Method.GET)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ReceivingRetrieval(getUpnpService(), message);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (getUpnpService().getConfiguration().getNamespace().isControlPath(message.getUri())) &#123;</span><br><span class="line">        <span class="keyword">if</span> (message.getOperation().getMethod().equals(UpnpRequest.Method.POST))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ReceivingAction(getUpnpService(), message);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (getUpnpService().getConfiguration().getNamespace().isEventSubscriptionPath(message.getUri())) &#123;</span><br><span class="line">        <span class="keyword">if</span> (message.getOperation().getMethod().equals(UpnpRequest.Method.SUBSCRIBE)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ReceivingSubscribe(getUpnpService(), message);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (message.getOperation().getMethod().equals(UpnpRequest.Method.UNSUBSCRIBE)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ReceivingUnsubscribe(getUpnpService(), message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (getUpnpService().getConfiguration().getNamespace().isEventCallbackPath(message.getUri())) &#123;</span><br><span class="line">        <span class="keyword">if</span> (message.getOperation().getMethod().equals(UpnpRequest.Method.NOTIFY))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ReceivingEvent(getUpnpService(), message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建接收同步消息的协议，根据方法不同返回不同的协议</p><p>创建发送消息的协议比较简单，直接创建对应的</p><h2 id="SendingAsync"><a href="#SendingAsync" class="headerlink" title="SendingAsync"></a>SendingAsync</h2><p>异步处理协议、发送消息的基类，是一个<code>Runnable</code></p><p>子类需要实现<code>execute()</code>方法</p><h3 id="SendingSync"><a href="#SendingSync" class="headerlink" title="SendingSync"></a>SendingSync</h3><p>同步处理协议、发送消息的基类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SendingSync</span>&lt;<span class="title">IN</span> <span class="keyword">extends</span> <span class="title">StreamRequestMessage</span>, <span class="title">OUT</span> <span class="keyword">extends</span> <span class="title">StreamResponseMessage</span>&gt; <span class="keyword">extends</span> <span class="title">SendingAsync</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">private</span> IN inputMessage;</span><br><span class="line">    <span class="keyword">protected</span> OUT outputMessage;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">SendingSync</span><span class="params">(UpnpService upnpService, IN inputMessage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(upnpService);</span><br><span class="line">        <span class="keyword">this</span>.inputMessage = inputMessage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IN <span class="title">getInputMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> inputMessage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> OUT <span class="title">getOutputMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> outputMessage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        outputMessage = executeSync();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> OUT <span class="title">executeSync</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同步等待处理结果，子类需要实现<code>executeSync()</code>方法</p><h4 id="SendingAction"><a href="#SendingAction" class="headerlink" title="SendingAction"></a>SendingAction</h4><p>发送控制消息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> IncomingActionResponseMessage <span class="title">invokeRemote</span><span class="params">(OutgoingActionRequestMessage requestMessage)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    StreamResponseMessage streamResponse = sendRemoteRequest(requestMessage);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>executeSync()</code>里面调用了<code>invokeRemote()</code>方法，通过<code>sendRemoteRequest()</code>发送请求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> StreamResponseMessage <span class="title">sendRemoteRequest</span><span class="params">(OutgoingActionRequestMessage requestMessage)</span> <span class="keyword">throws</span> ActionException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        getUpnpService().getConfiguration().getSoapActionProcessor().writeBody(requestMessage, actionInvocation);</span><br><span class="line">        <span class="keyword">return</span> getUpnpService().getRouter().send(requestMessage);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedDataException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ActionException(ErrorCode.ACTION_FAILED, <span class="string">"Error writing request message. "</span> + ex.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发送请求，可以看到是通过配置里给定的<code>SOAPActionProcessor</code>写入请求</p><h4 id="SendingEvent"><a href="#SendingEvent" class="headerlink" title="SendingEvent"></a>SendingEvent</h4><p>发送<code>GENA</code>事件消息到远程订阅者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SendingEvent</span><span class="params">(UpnpService upnpService, LocalGENASubscription subscription)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(upnpService, <span class="keyword">null</span>); <span class="comment">// Special case, we actually need to send several messages to each callback URL</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Ugly design! It is critical (concurrency) that we prepare the event messages here, in the constructor thread!</span></span><br><span class="line"></span><br><span class="line">    subscriptionId = subscription.getSubscriptionId();</span><br><span class="line"></span><br><span class="line">    requestMessages = <span class="keyword">new</span> OutgoingEventRequestMessage[subscription.getCallbackURLs().size()];</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (URL url : subscription.getCallbackURLs()) &#123;</span><br><span class="line">        requestMessages[i] = <span class="keyword">new</span> OutgoingEventRequestMessage(subscription, url);</span><br><span class="line">        getUpnpService().getConfiguration().getGenaEventProcessor().writeBody(requestMessages[i]);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    currentSequence = subscription.getCurrentSequence();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Always increment sequence now, as (its value) has already been set on the headers and the</span></span><br><span class="line">    <span class="comment">// next event will use the incremented value</span></span><br><span class="line">    subscription.incrementSequence();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造函数里对订阅的每一个URL生成了请求消息<code>executeSync()</code>里都发出去</p><h4 id="SendingSubscribe"><a href="#SendingSubscribe" class="headerlink" title="SendingSubscribe"></a>SendingSubscribe</h4><p>发送订阅消息，获得响应，<code>Registry.addRemoteSubscription()</code>，调用<code>subscription.establish()</code></p><h4 id="SendingUnsubscribe"><a href="#SendingUnsubscribe" class="headerlink" title="SendingUnsubscribe"></a>SendingUnsubscribe</h4><p>发送退订消息</p><h4 id="SendingRenewal"><a href="#SendingRenewal" class="headerlink" title="SendingRenewal"></a>SendingRenewal</h4><p>发送续订消息</p><h3 id="SendingSearch"><a href="#SendingSearch" class="headerlink" title="SendingSearch"></a>SendingSearch</h3><p>发送搜索请求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">   <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    OutgoingSearchRequest msg = <span class="keyword">new</span> OutgoingSearchRequest(searchTarget, getMxSeconds());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; getBulkRepeat(); i++) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            getUpnpService().getRouter().send(msg);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// UDA 1.0 is silent about this but UDA 1.1 recomments "a few hundred milliseconds"</span></span><br><span class="line">            Thread.sleep(getBulkIntervalMilliseconds());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SendingNotification"><a href="#SendingNotification" class="headerlink" title="SendingNotification"></a>SendingNotification</h3><p>向注册的本地设备发送通知消息，两个子类分别通知存活和死亡</p><h4 id="SendingNotificationAlive"><a href="#SendingNotificationAlive" class="headerlink" title="SendingNotificationAlive"></a>SendingNotificationAlive</h4><h4 id="SendingNotificationByebye"><a href="#SendingNotificationByebye" class="headerlink" title="SendingNotificationByebye"></a>SendingNotificationByebye</h4><h2 id="SOAPActionProcessor"><a href="#SOAPActionProcessor" class="headerlink" title="SOAPActionProcessor"></a>SOAPActionProcessor</h2><p>完成<code>UPNP SOAP</code>和动作请求的互相转换<br>UPNP协议层处理本地和远程的动作请求，UPNP传输层接收和返回请求和响应，这个处理器是两层之间的适配器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SOAPActionProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">writeBody</span><span class="params">(ActionRequestMessage requestMessage, ActionInvocation actionInvocation)</span> <span class="keyword">throws</span> UnsupportedDataException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">writeBody</span><span class="params">(ActionResponseMessage responseMessage, ActionInvocation actionInvocation)</span> <span class="keyword">throws</span> UnsupportedDataException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">readBody</span><span class="params">(ActionRequestMessage requestMessage, ActionInvocation actionInvocation)</span> <span class="keyword">throws</span> UnsupportedDataException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">readBody</span><span class="params">(ActionResponseMessage responseMsg, ActionInvocation actionInvocation)</span> <span class="keyword">throws</span> UnsupportedDataException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SOAPActionProcessorImpl"><a href="#SOAPActionProcessorImpl" class="headerlink" title="SOAPActionProcessorImpl"></a>SOAPActionProcessorImpl</h3><p>这个是基于<code>W3C DOM</code>的默认实现的XML解析器</p><h2 id="ReceivingAsync"><a href="#ReceivingAsync" class="headerlink" title="ReceivingAsync"></a>ReceivingAsync</h2><p>所有异步处理协议的基类，处理UPnP消息的接收</p><h3 id="ReceivingSync"><a href="#ReceivingSync" class="headerlink" title="ReceivingSync"></a>ReceivingSync</h3><p>所有同步处理协议的基类，处理UPnP消息的接收并返回响应</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ReceivingSync</span>&lt;<span class="title">IN</span> <span class="keyword">extends</span> <span class="title">StreamRequestMessage</span>, <span class="title">OUT</span> <span class="keyword">extends</span> <span class="title">StreamResponseMessage</span>&gt; <span class="keyword">extends</span> <span class="title">ReceivingAsync</span>&lt;<span class="title">IN</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> OUT outputMessage;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">ReceivingSync</span><span class="params">(UpnpService upnpService, IN inputMessage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(upnpService, inputMessage);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> OUT <span class="title">getOutputMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> outputMessage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        outputMessage = executeSync();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> OUT <span class="title">executeSync</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">responseSent</span><span class="params">(StreamResponseMessage responseMessage)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">responseException</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ReceivingAction"><a href="#ReceivingAction" class="headerlink" title="ReceivingAction"></a>ReceivingAction</h4><p>接收动作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> StreamResponseMessage <span class="title">executeSync</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    IncomingActionRequestMessage requestMessage = <span class="keyword">new</span> IncomingActionRequestMessage(getInputMessage(), resource.getModel());</span><br><span class="line">    ...</span><br><span class="line">    invocation = <span class="keyword">new</span> ActionInvocation(requestMessage.getAction());</span><br><span class="line">    getUpnpService().getConfiguration().getSoapActionProcessor().readBody(requestMessage, invocation);</span><br><span class="line">    ...</span><br><span class="line">    resource.getModel().getExecutor(invocation.getAction()).execute(invocation);</span><br><span class="line">    ...</span><br><span class="line">    responseMessage = <span class="keyword">new</span> OutgoingActionResponseMessage(invocation.getAction());</span><br><span class="line">    ...</span><br><span class="line">    getUpnpService().getConfiguration().getSoapActionProcessor().writeBody(responseMessage, invocation);</span><br><span class="line">    <span class="keyword">return</span> responseMessage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接收消息，转化为<code>ActionInvocation</code>，然后由对应动作的处理器处理</p><blockquote><p><code>LocalService</code>里的<code>actionExecutors</code>并没有被赋过值，Why?<br>可能因为手机端只是发送动作给设备，而不接收动作</p></blockquote><h4 id="ReceivingEvent"><a href="#ReceivingEvent" class="headerlink" title="ReceivingEvent"></a>ReceivingEvent</h4><p>接收GENA事件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> OutgoingEventResponseMessage <span class="title">executeSync</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">final</span> IncomingEventRequestMessage requestMessage = <span class="keyword">new</span> IncomingEventRequestMessage(getInputMessage(), resource.getModel());</span><br><span class="line">    ...</span><br><span class="line">    getUpnpService().getConfiguration().getGenaEventProcessor().readBody(requestMessage);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//  处理事件的时候锁定订阅</span></span><br><span class="line">    getUpnpService().getRegistry().lockRemoteSubscriptions();</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">final</span> RemoteGENASubscription subscription = getUpnpService().getRegistry().getRemoteSubscription(requestMessage.getSubscrptionId());</span><br><span class="line">    ...</span><br><span class="line">    getUpnpService().getConfiguration().getRegistryListenerExecutor().execute(</span><br><span class="line">        <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                subscription.receive(requestMessage.getSequence(), requestMessage.getStateVariableValues());&#125;</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接收到GENA事件，调用远端订阅的<code>eventReceived()</code></p><h4 id="ReceivingSubscribe"><a href="#ReceivingSubscribe" class="headerlink" title="ReceivingSubscribe"></a>ReceivingSubscribe</h4><p>接收订阅，根据id和头部信息选择续订或新订阅，续订就是延长时间并更新，新订阅就是<code>Registry.addLocalSubscription()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">subscription = <span class="keyword">new</span> LocalGENASubscription(service, timeoutSeconds, requestMessage.getCallbackURLs()) &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">established</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ended</span><span class="params">(CancelReason reason)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eventReceived</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        getUpnpService().getConfiguration().getSyncProtocolExecutor().execute(getUpnpService().getProtocolFactory().createSendingEvent(<span class="keyword">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>添加这个<code>subscription</code>，在<code>eventReceived()</code>的时候会发送事件</p><h4 id="ReceivingUnsubscribe"><a href="#ReceivingUnsubscribe" class="headerlink" title="ReceivingUnsubscribe"></a>ReceivingUnsubscribe</h4><p>接收退订</p><h4 id="ReceivingRetrieval"><a href="#ReceivingRetrieval" class="headerlink" title="ReceivingRetrieval"></a>ReceivingRetrieval</h4><h3 id="ReceivingSearch"><a href="#ReceivingSearch" class="headerlink" title="ReceivingSearch"></a>ReceivingSearch</h3><p>接收搜索请求，响应本地已注册的设备</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    UpnpHeader searchTarget = getInputMessage().getSearchTarget();</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">for</span> (NetworkAddress activeStreamServer : activeStreamServers) &#123;</span><br><span class="line">        sendResponses(searchTarget, activeStreamServer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对每个网络地址，发送响应</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sendResponses</span><span class="params">(UpnpHeader searchTarget, NetworkAddress activeStreamServer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (searchTarget <span class="keyword">instanceof</span> STAllHeader) &#123;</span><br><span class="line">        sendSearchResponseAll(activeStreamServer);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (searchTarget <span class="keyword">instanceof</span> RootDeviceHeader) &#123;</span><br><span class="line">        sendSearchResponseRootDevices(activeStreamServer);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (searchTarget <span class="keyword">instanceof</span> UDNHeader) &#123;</span><br><span class="line">        sendSearchResponseUDN((UDN) searchTarget.getValue(), activeStreamServer);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (searchTarget <span class="keyword">instanceof</span> DeviceTypeHeader) &#123;</span><br><span class="line">        sendSearchResponseDeviceType((DeviceType) searchTarget.getValue(), activeStreamServer);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (searchTarget <span class="keyword">instanceof</span> ServiceTypeHeader) &#123;</span><br><span class="line">        sendSearchResponseServiceType((ServiceType) searchTarget.getValue(), activeStreamServer);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (searchTarget <span class="keyword">instanceof</span> EASYLINKHeader) &#123;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>searchTarget</code>是UPnP头，根据头的不同做不同处理</p><h3 id="ReceivingNotification"><a href="#ReceivingNotification" class="headerlink" title="ReceivingNotification"></a>ReceivingNotification</h3><p>接收通知消息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (getInputMessage().isAliveMessage()) &#123;</span><br><span class="line">        ...</span><br><span class="line">        getUpnpService().getConfiguration().getAsyncProtocolExecutor().execute(<span class="keyword">new</span> RetrieveRemoteDescriptors(getUpnpService(), rd)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (getInputMessage().isByeByeMessage()) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">boolean</span> removed = getUpnpService().getRegistry().removeDevice(rd);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是存活消息，处理和<code>ReceivingSearchResponse</code>类似，如果是再见消息，就移除设备</p><h3 id="ReceivingSearchResponse"><a href="#ReceivingSearchResponse" class="headerlink" title="ReceivingSearchResponse"></a>ReceivingSearchResponse</h3><p>接收搜索的响应消息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (getInputMessage().getHeaders().containsKey(<span class="string">"Easylink"</span>)) &#123;</span><br><span class="line">        matchEasylink(getInputMessage());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (getUpnpService().getRegistry().update(rdIdentity)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    getUpnpService().getConfiguration().getAsyncProtocolExecutor().execute(<span class="keyword">new</span> RetrieveRemoteDescriptors(getUpnpService(), rd));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先对<code>EasyLink</code>消息做特殊处理，然后<code>Registry.update()</code>看是否已经注册有这个设备，最后把<code>RemoteDevice</code>封装成<code>RetrieveRemoteDescriptors</code>处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">matchEasylink</span><span class="params">(IncomingSearchResponse msg)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    String[] headerSplit = headerStr.split(<span class="string">"\r\n"</span>);</span><br><span class="line">    String IP = <span class="keyword">null</span>;</span><br><span class="line">    String UUID = <span class="keyword">null</span>;</span><br><span class="line">    String Easylink = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  解析头部拿到这些字符串</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (Easylink != <span class="keyword">null</span> &amp;&amp; Easylink.equals(<span class="string">"1"</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (IP != <span class="keyword">null</span> &amp;&amp; UUID != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//  发送EasyLink广播</span></span><br><span class="line">            Intent in = <span class="keyword">new</span> Intent();</span><br><span class="line">            in.putExtra(<span class="string">"EASYLINK"</span>, Easylink);</span><br><span class="line">            in.putExtra(<span class="string">"IP"</span>, IP);</span><br><span class="line">            in.putExtra(<span class="string">"UUID"</span>, UUID);</span><br><span class="line">            in.setAction(ReceivingSearchResponse.ACTION_EASY_LINK_OK);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (ClingHelper.getInstance().getContext() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                ClingHelper.getInstance().getContext().sendBroadcast(in);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            Map&lt;String, String&gt; mDataOnline = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">            mDataOnline.put(<span class="string">"EASYLINK"</span>, Easylink);</span><br><span class="line">            mDataOnline.put(<span class="string">"IP"</span>, IP);</span><br><span class="line">            mDataOnline.put(<span class="string">"UUID"</span>, UUID);</span><br><span class="line">            AndroidEzlinkHandler.me().notifyDeviceOnline(mDataOnline);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>EasyLink</code>处理拿到IP和UUID，然后发广播通知Android系统</p><h4 id="RetrieveRemoteDescriptors"><a href="#RetrieveRemoteDescriptors" class="headerlink" title="RetrieveRemoteDescriptors"></a>RetrieveRemoteDescriptors</h4><p>一个<code>Runnable</code>，获取所有的远程设备XML描述，分析并创建设备和服务元数据</p><p>在<code>run()</code>中判断一下设备URL是否已存在，设备是否已存在于<code>Registry</code>中，然后开始描述设备</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">describe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    StreamRequestMessage deviceDescRetrievalMsg = <span class="keyword">new</span> StreamRequestMessage(UpnpRequest.Method.GET, rd.getIdentity().getDescriptorURL());</span><br><span class="line">    StreamResponseMessage deviceDescMsg = getUpnpService().getRouter().send(deviceDescRetrievalMsg);</span><br><span class="line">    ...</span><br><span class="line">    describe(deviceDescMsg.getBodyString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里请求设备描述信息，然后解析，这个过程包含了多个网络请求和XML解析，是很耗时的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">describe</span><span class="params">(String descriptorXML)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    DeviceDescriptorBinder deviceDescriptorBinder = getUpnpService().getConfiguration().getDeviceDescriptorBinderUDA10();</span><br><span class="line">    describedDevice = deviceDescriptorBinder.describe(rd, descriptorXML);</span><br><span class="line">    ...</span><br><span class="line">    notifiedStart = getUpnpService().getRegistry().notifyDiscoveryStart(describedDevice);</span><br><span class="line">    ...</span><br><span class="line">    RemoteDevice hydratedDevice = describeServices(describedDevice);</span><br><span class="line">    ...</span><br><span class="line">    getUpnpService().getRegistry().addDevice(hydratedDevice);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>DeviceDescriptorBinder</code>解析XML，得到<code>RemoteDevice</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> RemoteDevice <span class="title">describeServices</span><span class="params">(RemoteDevice currentDevice)</span> <span class="keyword">throws</span> DescriptorBindingException, ValidationException </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  描述服务，先根据配置排除一些服务，然后依次描述</span></span><br><span class="line">    List&lt;RemoteService&gt; describedServices = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    <span class="keyword">if</span> (currentDevice.hasServices()) &#123;</span><br><span class="line">        List&lt;RemoteService&gt; filteredServices = filterExclusiveServices(currentDevice.getServices());</span><br><span class="line">        <span class="keyword">for</span> (RemoteService service : filteredServices) &#123;</span><br><span class="line">            RemoteService svc = describeService(service);</span><br><span class="line">            <span class="keyword">if</span> (svc == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            describedServices.add(svc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  描述内嵌设备，递推的调用</span></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  描述图标</span></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  解析全部完成</span></span><br><span class="line">    <span class="keyword">return</span> currentDevice.newInstance(</span><br><span class="line">        currentDevice.getIdentity().getUdn(),</span><br><span class="line">        currentDevice.getVersion(), </span><br><span class="line">        currentDevice.getType(),</span><br><span class="line">        currentDevice.getDetails(), </span><br><span class="line">        iconDupes,</span><br><span class="line">        currentDevice.toServiceArray(describedServices),</span><br><span class="line">        describedEmbeddedDevices);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对<code>RemoteDevice</code>进一步解析服务、内联设备和图标</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> RemoteService <span class="title">describeService</span><span class="params">(RemoteService service)</span> <span class="keyword">throws</span> DescriptorBindingException, ValidationException </span>&#123;</span><br><span class="line">    URL descriptorURL = service.getDevice().normalizeURI(service.getDescriptorURI());</span><br><span class="line">    StreamRequestMessage serviceDescRetrievalMsg = <span class="keyword">new</span> StreamRequestMessage(UpnpRequest.Method.GET, descriptorURL);</span><br><span class="line">    StreamResponseMessage serviceDescMsg = getUpnpService().getRouter().send(serviceDescRetrievalMsg);</span><br><span class="line">    ...</span><br><span class="line">    ServiceDescriptorBinder serviceDescriptorBinder = getUpnpService().getConfiguration().getServiceDescriptorBinderUDA10();</span><br><span class="line">    <span class="keyword">return</span> serviceDescriptorBinder.describe(service, serviceDescMsg.getBodyString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>ServiceDescriptorBinder</code>解析XML，得到<code>RemoteService</code></p><h2 id="Router"><a href="#Router" class="headerlink" title="Router"></a>Router</h2><p>网络传输层接口，封装传输层，为上层提供方法来发送UPNP流（HTTP）和发送UDP数据报，还有局域网广播<br><code>Router</code>维护监听套接字和服务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Router</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">received</span><span class="params">(IncomingDatagramMessage msg)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">received</span><span class="params">(UpnpStream stream)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">(OutgoingDatagramMessage msg)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">StreamResponseMessage <span class="title">send</span><span class="params">(StreamRequestMessage msg)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">broadcast</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Router</code>构造的时候会创建一组<code>StreamServer</code>、<code>DatagramIO</code>、<code>MulticastReceiver</code>，然后执行他们</p><h3 id="RouterImpl"><a href="#RouterImpl" class="headerlink" title="RouterImpl"></a>RouterImpl</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(OutgoingDatagramMessage msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (DatagramIO datagramIO : getDatagramIOs().values()) &#123;</span><br><span class="line">        datagramIO.send(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发送UDP消息，就是遍历所有的接口发送</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> StreamResponseMessage <span class="title">send</span><span class="params">(StreamRequestMessage msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (getStreamClient() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> getStreamClient().sendRequest(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发送HTTP数据，就是使用<code>StreamClient</code>发送请求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">received</span><span class="params">(IncomingDatagramMessage msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ReceivingAsync protocol = getProtocolFactory().createReceivingAsync(msg);</span><br><span class="line">        <span class="keyword">if</span> (protocol == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        getConfiguration().getAsyncProtocolExecutor().execute(protocol);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ProtocolCreationException ex) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接收UDP消息，构建一个<code>ReceivingAsync</code>并执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">received</span><span class="params">(UpnpStream stream)</span> </span>&#123;</span><br><span class="line">    getConfiguration().getSyncProtocolExecutor().execute(stream);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接收HTTP数据，直接执行<code>UpnpStream</code></p><h3 id="DatagramIO"><a href="#DatagramIO" class="headerlink" title="DatagramIO"></a>DatagramIO</h3><p>接受单播和发送UDP数据报的服务，每个IP绑定一个<br>该服务在一个套接字上监听UDP单播数据报，监听循环在<code>run()</code>中开始，任何接收的数据报然后被转化为<code>IncomingDatagramMessage</code>，然后被<code>Router.received()</code>处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DatagramIO</span>&lt;<span class="title">C</span> <span class="keyword">extends</span> <span class="title">DatagramIOConfiguration</span>&gt; <span class="keyword">extends</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(InetAddress bindAddress, Router router, DatagramProcessor datagramProcessor)</span> <span class="keyword">throws</span> InitializationException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">C <span class="title">getConfiguration</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">(OutgoingDatagramMessage message)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">(DatagramPacket datagram)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="DatagramIOImpl"><a href="#DatagramIOImpl" class="headerlink" title="DatagramIOImpl"></a>DatagramIOImpl</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[getConfiguration().getMaxDatagramBytes()];</span><br><span class="line">            DatagramPacket datagram = <span class="keyword">new</span> DatagramPacket(buf, buf.length);</span><br><span class="line"></span><br><span class="line">            socket.receive(datagram);</span><br><span class="line"></span><br><span class="line">            router.received(datagramProcessor.read(localAddress.getAddress(), datagram));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SocketException ex) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedDataException ex) &#123;</span><br><span class="line">        </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!socket.isClosed()) &#123;</span><br><span class="line">            socket.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>循环中先由套接字获得UDP数据报，然后交由<code>Router.received()</code>处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(DatagramPacket datagram)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    socket.send(datagram);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>Socket</code>发送数据报，这是一个<code>MulticastSocket</code></p><h5 id="MulticastSocket"><a href="#MulticastSocket" class="headerlink" title="MulticastSocket"></a>MulticastSocket</h5><p>多播套接字，参见<code>java.net</code>包</p><h3 id="StreamClient"><a href="#StreamClient" class="headerlink" title="StreamClient"></a>StreamClient</h3><p>发送TCP流请求消息的服务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StreamClient</span>&lt;<span class="title">C</span> <span class="keyword">extends</span> <span class="title">StreamClientConfiguration</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">StreamResponseMessage <span class="title">sendRequest</span><span class="params">(StreamRequestMessage message)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">C <span class="title">getConfiguration</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="StreamClientImpl"><a href="#StreamClientImpl" class="headerlink" title="StreamClientImpl"></a>StreamClientImpl</h4><h3 id="StreamServer"><a href="#StreamServer" class="headerlink" title="StreamServer"></a>StreamServer</h3><p>接收TCP流的服务，每个IP一个，该服务在一个套接字上监听TCP连接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StreamServer</span>&lt;<span class="title">C</span> <span class="keyword">extends</span> <span class="title">StreamServerConfiguration</span>&gt; <span class="keyword">extends</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(InetAddress bindAddress, Router router)</span> <span class="keyword">throws</span> InitializationException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getPort</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">C <span class="title">getConfiguration</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="StreamServerImpl"><a href="#StreamServerImpl" class="headerlink" title="StreamServerImpl"></a>StreamServerImpl</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!stopped) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Block until we have a connection</span></span><br><span class="line">            Socket clientSocket = serverSocket.accept();</span><br><span class="line">            <span class="keyword">if</span> (HTTPServerData.HOST != <span class="keyword">null</span> &amp;&amp; !clientSocket.getInetAddress().getHostAddress().equals(HTTPServerData.HOST) &amp;&amp; !configuration.isExported()) &#123;</span><br><span class="line">                clientSocket.close();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// We have to force this fantastic library to accept HTTP</span></span><br><span class="line">            <span class="comment">// methods which are not in the holy RFCs.</span></span><br><span class="line">            DefaultHttpServerConnection httpServerConnection = <span class="keyword">new</span> DefaultHttpServerConnection() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> HttpRequestFactory <span class="title">createHttpRequestFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> UpnpHttpRequestFactory();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            httpServerConnection.bind(clientSocket, globalParams);</span><br><span class="line">            <span class="comment">// Wrap the processing of the request in a UpnpStream</span></span><br><span class="line">            UpnpStream connectionStream = <span class="keyword">new</span> HttpServerConnectionUpnpStream(router.getProtocolFactory(), httpServerConnection, globalParams);</span><br><span class="line"></span><br><span class="line">            router.received(connectionStream);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedIOException ex) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SocketException ex) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!stopped) &#123;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!serverSocket.isClosed()) &#123;</span><br><span class="line">            serverSocket.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在循环中监听套接字，获得的<code>UpnpStream</code>交由<code>Router.received()</code>处理</p><h4 id="UpnpStream"><a href="#UpnpStream" class="headerlink" title="UpnpStream"></a>UpnpStream</h4><p>代表一个HTTP请求或响应的<code>Runnable</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> StreamResponseMessage <span class="title">process</span><span class="params">(StreamRequestMessage requestMsg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// Try to get a protocol implementation that matches the request message</span></span><br><span class="line">        syncProtocol = getProtocolFactory().createReceivingSync(requestMsg);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ProtocolCreationException ex) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> StreamResponseMessage(UpnpResponse.Status.NOT_IMPLEMENTED);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Run it</span></span><br><span class="line">    syncProtocol.run();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... then grab the response</span></span><br><span class="line">    StreamResponseMessage responseMsg = syncProtocol.getOutputMessage();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (responseMsg == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// That's ok, the caller is supposed to handle this properly (e.g. convert it to HTTP 404)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> responseMsg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>process()</code>从<code>StreamRequestMessage</code>创建出一个<code>ReceivingSync</code>并执行，然后返回<code>StreamResponseMessage</code></p><h5 id="HttpExchangeUpnpStream"><a href="#HttpExchangeUpnpStream" class="headerlink" title="HttpExchangeUpnpStream"></a>HttpExchangeUpnpStream</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//  构造StreamRequestMessage</span></span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  处理之</span></span><br><span class="line">    StreamResponseMessage responseMessage = process(requestMessage);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  返回StreamResponseMessage</span></span><br><span class="line">    ......</span><br><span class="line">    ReceivingSync.responseSent()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="MulticastReceiver"><a href="#MulticastReceiver" class="headerlink" title="MulticastReceiver"></a>MulticastReceiver</h3><p>接受UDP数据报广播的服务，每个网络接口一个，该服务在一个套接字上监听UDP数据报，监听循环在<code>run()</code>中开始，任何接收的数据报然后被转化为<code>IncomingDatagramMessage</code>，然后被<code>Router.received()</code>处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MulticastReceiver</span>&lt;<span class="title">C</span> <span class="keyword">extends</span> <span class="title">MulticastReceiverConfiguration</span>&gt; <span class="keyword">extends</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(NetworkInterface networkInterface, Router router, DatagramProcessor datagramProcessor)</span> <span class="keyword">throws</span> InitializationException</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">C <span class="title">getConfiguration</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="MulticastReceiverImpl"><a href="#MulticastReceiverImpl" class="headerlink" title="MulticastReceiverImpl"></a>MulticastReceiverImpl</h4><h2 id="一些流程"><a href="#一些流程" class="headerlink" title="一些流程"></a>一些流程</h2><h3 id="搜索设备-发送UDP数据报"><a href="#搜索设备-发送UDP数据报" class="headerlink" title="搜索设备(发送UDP数据报)"></a>搜索设备(发送UDP数据报)</h3><ol><li><code>ControlPoint</code>: 调用<code>search()</code>，即处理<code>SendingSearch</code></li><li><code>Router</code>: 循环调用<code>send()</code></li><li><code>DatagramIO</code>: 对每一个端口，调用<code>send()</code>，将消息封装成<code>DatagramPacket</code></li><li><code>MulticastSocket</code>: 调用<code>send()</code></li></ol><blockquote><p>扩展看一下<code>java.net</code>包</p></blockquote><h3 id="发送命令-发送TCP数据流"><a href="#发送命令-发送TCP数据流" class="headerlink" title="发送命令(发送TCP数据流)"></a>发送命令(发送TCP数据流)</h3><ol><li><code>ControlPoint</code>: 调用<code>execute()</code>，执行<code>ActionCallback</code>，即处理<code>SendingActoin</code></li><li><code>Router</code>: 调用<code>send()</code></li><li><code>StreamClient</code>: 调用<code>sendRequest()</code></li><li><code>DefaultHttpClient</code>: 调用<code>execute()</code></li></ol><h3 id="接收UDP数据报"><a href="#接收UDP数据报" class="headerlink" title="接收UDP数据报"></a>接收UDP数据报</h3><ol><li><code>DatagramIO</code>: 循环中在套接字上接收<code>DatagramPacket</code>，转换成<code>IncomingDatagramMessage</code></li><li><code>Router</code>: <code>received()</code>，创建一个<code>ReceivingAsync</code>并执行</li><li><code>ReceivingAsync</code>: 执行<code>execute()</code>，由不同的子类分别处理，拿到对应的数据结构</li></ol><h3 id="接收TCP数据流"><a href="#接收TCP数据流" class="headerlink" title="接收TCP数据流"></a>接收TCP数据流</h3><ol><li><code>StreamServer</code>: 循环中监听套接字，得到<code>UpnpStream</code></li><li><code>Router</code>: <code>received()</code>，其实就是执行这个<code>UpnpStream</code></li><li><code>UpnpStream</code>: 从<code>StreamRequestMessage</code>创建出一个<code>ReceivingSync</code>并执行，然后返回<code>StreamResponseMessage</code></li><li><code>ReceivingSync</code>: 执行<code>executeSync()</code>，由不同的子类分别处理，拿到对应的数据结构</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Cling是由Java实现的&lt;code&gt;DLNA/UPnP&lt;/code&gt;协议栈。可以开发出类似多屏互动、资源共享、远程控制等功能的应用，通过Android 应用管理一个或多个设备，将音频、视频、图片推送到指定设备显示&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://lakeshire.github.io/categories/Android/"/>
    
    
      <category term="开源库" scheme="http://lakeshire.github.io/tags/%E5%BC%80%E6%BA%90%E5%BA%93/"/>
    
      <category term="DLNA" scheme="http://lakeshire.github.io/tags/DLNA/"/>
    
      <category term="Cling" scheme="http://lakeshire.github.io/tags/Cling/"/>
    
  </entry>
  
  <entry>
    <title>AndroidWear开发心得</title>
    <link href="http://lakeshire.github.io/2016/12/29//archivers/android-wear/"/>
    <id>http://lakeshire.github.io/2016/12/29//archivers/android-wear/</id>
    <published>2016-12-29T09:00:00.000Z</published>
    <updated>2017-11-28T03:15:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>Android Wear开发的踩坑史……</p><a id="more"></a><h2 id="AndroidWear开发"><a href="#AndroidWear开发" class="headerlink" title="AndroidWear开发"></a>AndroidWear开发</h2><p>需要SDKTools 23.0.0以上以及<code>API20</code>以上的SDK</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>下载AndroidWear手机应用，最好是国际版，我用的华为手表，开机之后会有引导，可以扫描二维码下载对应的国际版AndroidWear，然后扫描设备，配对，同步一段时间，手表就能开始运行了</p><blockquote><p>后来把手表刷到2.0做开发，这个AndroidWear就连不上了，要使用Google的开发者预览版</p></blockquote><p>在手表上开启开发者选项，就是在<code>设置</code>-&gt;<code>关于</code>里面，点击版本号七次，然后在开发者选项里面开启<code>ADB调试</code>，同时也开一下<code>通过蓝牙调试</code></p><p>进入手机的AndroidWear应用，右上角的<code>设置</code>里面，开启<code>通过蓝牙调试</code>,有两个连接，<code>主机</code>是电脑与手机的连接，<code>目标</code>是手机与手表的连接，在电脑的命令行输入命令进行连接，手表上确认后就可以调试了</p><pre><code>adbforward tcp:4444 localabstract:/adb-hubadb connect localhost:4444</code></pre><blockquote><p>有时候下面那条命令连不上，把<code>localhost</code>换成<code>127.0.0.1</code>试试</p></blockquote><h2 id="创建工程"><a href="#创建工程" class="headerlink" title="创建工程"></a>创建工程</h2><p>创建工程跟一般的Android工程差不多，注意除了<code>Phone and Tablet</code>之外多选一个<code>Wear</code>，这样你的工程就包含<code>mobile</code>和<code>wear</code>两个模块了，后者就是手表端的代码</p><p>很多代码都通用，理论上把手机端的应用直接装手表上也能跑起来，但是界面就不能看了，所以还是需要遵守一下手表端的交互规范，但是这东西很新而且一直也在更新，很多东西说过时就过时，也是不用太纠结</p><h3 id="GridViewPager"><a href="#GridViewPager" class="headerlink" title="GridViewPager"></a>GridViewPager</h3><p>多页的展示我用了这个，类似<code>ViewPager</code>，但是它是<code>2D</code>的更强大一点，然而我也没用到这个特性，配合<code>DotsPageIndicator</code>做指示器</p><p>三个页面，我希望初始显示第2页，那么就要用到<code>setCurrentItem(0,1)</code>，但是没有效果，后来发现手表毕竟性能比较弱，可能是还没初始化完这个<code>GridViewPager</code>就进行设置导致无效，所以用了这段代码就好了</p><pre><code>Runnable dirtyHack  = new Runnable() {    @Override    public void run() {        pager.setCurrentItem(0, 1);    }};</code></pre><h3 id="WearableListView"><a href="#WearableListView" class="headerlink" title="WearableListView"></a>WearableListView</h3><p>用于列表展示，然而并不是<code>ListView</code>的子类，而是<code>RecyclerView</code>的子类，这个类在<code>2.0</code>就废了</p><h4 id="显示列表头"><a href="#显示列表头" class="headerlink" title="显示列表头"></a>显示列表头</h4><p>跟手机上的列表显示不同，手表上会自己做处理，把列表的第一项显示在屏幕中心，体验会好一点，上面还有一半的空白还专门有个函数<code>onTopEmptyRegionClick()</code>来处理这里的点击，但是我没找到有方法可以获得这个区域，往里面填充点我想要的列表头什么的，又没有<code>ListView</code>的比较方便的<code>addHeaderView()</code>的方法，<code>RecyclerView</code>根据项类型不同改变布局的话，有需要自己调整列表的偏移，总体来说这个需求就比较恶心，我就直接用了几层布局，反正列表初始显示时上方是露出的，滑动时覆盖掉也是可以达到预期</p><h4 id="下拉刷新"><a href="#下拉刷新" class="headerlink" title="下拉刷新"></a>下拉刷新</h4><p>使用了<code>SwipeRefreshLayout</code>，试了其他的没成功，然后这个库好像刷新头就是那个旋转尖头，还能设置多种颜色挨着变，可定制性就不太高，不过对手表这种轻量的场合也就够了</p><h4 id="加载更多"><a href="#加载更多" class="headerlink" title="加载更多"></a>加载更多</h4><p>没有找到实现方法，按照网上流行的<code>RecyclerView</code>加载更多的实现方法，需要用到某个<code>LayoutManager</code>，<code>WearableListView</code>里面继承了这个并且设置为了<code>private</code>，导致那个判定某项是否是最后一项的方法调不到，不想多折腾，在列表里面加入一个判断项，用来显示<code>加载更多</code>好了</p><h4 id="列表项显示效果"><a href="#列表项显示效果" class="headerlink" title="列表项显示效果"></a>列表项显示效果</h4><p>圆形表盘引入的问题，一页显示三项，中间项较大，这样视觉效果会比较好，为此可以自定义一个布局，实现<code>WearableListView.OnCenterProximityListener</code>这个接口，在<code>onCenterPosition()</code>和<code>onNonCenterPosition()</code>两个函数里面做一下缩放的动画，类似冒泡的效果</p><blockquote><p>最初会有列表无法滑动的问题，可能是跟<code>GridViewPager</code>冲突了，用这句代码解决<code>listView.setGreedyTouchMode(true)</code>，也是很无语</p></blockquote><h3 id="WearableRecyclerView"><a href="#WearableRecyclerView" class="headerlink" title="WearableRecyclerView"></a>WearableRecyclerView</h3><p><code>2.0</code>推荐使用的列表，它可以显示一个弧状的列表，好处是可以显示更多的内容</p><h3 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h3><p><code>2.0</code>以前的手表一般是依赖手机工作的，因为其自身不支持网络，所有的数据都从手机获得，所以数据传输方面的API特别重要，也很坑</p><p>方法和类本身很简单，先连接到<code>GoogleApiClient</code>，注册<code>DataApi</code>和<code>MessageApi</code>的监听，就可以收发消息，也可以同步数据（相当于两端公用一个数据结构，一方的改动会推送到另一方）</p><p>但是，它是基于<code>GooglePlayService</code>的，在国内基本处于不可用状态，华为官网提供了一个可用的版本，应该是做过处理了，然而能不能通信还是有很多坑点</p><ol><li><code>wear</code>和<code>mobile</code>用的库版本需要是一样的</li><li>调试版本一般是可以通信的，发布版本有一定的要求</li><li>蓝牙要保持连接，<code>AndroidWear</code>也要保持运行</li><li>可以在没有<code>GooglePlayServiceFramework</code>的手机上工作（可能是华为的库做过处理）</li></ol><h2 id="打包发布"><a href="#打包发布" class="headerlink" title="打包发布"></a>打包发布</h2><p><code>2.0</code>以前<code>wear</code>的apk是附在<code>mobile</code>里面的，手机安装时推送到手表端，两种打包方式</p><h3 id="自动打包"><a href="#自动打包" class="headerlink" title="自动打包"></a>自动打包</h3><p><code>mobile</code>的<code>build.gradle</code>里加入</p><pre><code>dependencies {    wearApp project(&apos;:wear&apos;)}</code></pre><p>那个<code>:wear</code>就是手表的工程，然后<code>Build</code>-&gt;<code>Generate Signed APK</code>，这样的话就同时签名了</p><h3 id="手动打包"><a href="#手动打包" class="headerlink" title="手动打包"></a>手动打包</h3><p><code>mobile</code>的<code>AndroidMenifest.xml</code>要包含<code>wear</code>的全部权限</p><p>确保两个工程有同样的包名和版本号（可能都是不需要的，因为接下来需要提供一个描述文件，里面都有指定，没验证过）</p><p>把正式版<code>wear</code>的apk拷贝到<code>res/raw</code>目录，假设命名为<code>wearable_app.apk</code></p><p>创建<code>res/xml/wearable_app_desc.xml</code>文件</p><pre><code>&lt;wearableApp package=&quot;[包名]&quot;    &lt;versionCode&gt;1&lt;/versionCode&gt;     &lt;versionName&gt;1.0&lt;/versionName&gt;     &lt;rawPathResId&gt;wearable_app&lt;/rawPathResId&gt;&lt;/wearableApp&gt;</code></pre><p>在<code>mobile</code>的<code>AndroidMenifest.xml</code>里的<code>&lt;application&gt;</code>标签里添加</p><pre><code>&lt;meta-data android:name=&quot;com.google.android.wearable.beta.app&quot; android:resource=&quot;@xml/wearable_app_desc&quot; /&gt;</code></pre><p>构建正式版<code>mobile</code>应用</p><p><code>2.0</code>就可以独立安装手表的apk了，我的最终配置是下面这样然后能够工作（主要指通信部分）：</p><ol><li>两边的包名相同</li><li>两边的版本号不同</li><li><code>mobile</code>并没有做手动打包的3／4／5步</li></ol><h3 id="杂七杂八的配置"><a href="#杂七杂八的配置" class="headerlink" title="杂七杂八的配置"></a>杂七杂八的配置</h3><p>做的过程并没有记得很清楚，所以一些配置可能并不是必要的，但是如果遇到奇怪的无法通信的错误可以试试</p><p><code>AndroidMenifest.xml</code>中加入手表的特性</p><p>手机端</p><pre><code>&lt;uses-feature android:name=&quot;android.hardware.type.watch&quot; android:required=&quot;false&quot; /&gt;</code></pre><p>手表端</p><pre><code>&lt;uses-feature android:name=&quot;android.hardware.type.watch&quot; /&gt;</code></pre><p>可能<code>wear</code>编译缺少库时，在<code>&lt;appliaction&gt;</code>标签下加入</p><pre><code>&lt;uses-library android:name=&quot;com.google.android.wearable&quot; android:required=&quot;false&quot; /&gt;</code></pre><p>华为提供的库是个<code>aar</code>，需要在<code>build.gradle</code>中加入支持</p><pre><code>android {    ......    repositories {        flatDir {            dirs : &apos;libs&apos;        }    }    ......    }dependencies {    ......    compile(name : &apos;play-services-7.8.87&apos;, ext : &apos;aar&apos;)    ......}</code></pre><h2 id="刷机升级到2-0"><a href="#刷机升级到2-0" class="headerlink" title="刷机升级到2.0"></a>刷机升级到<code>2.0</code></h2><ol><li>进入开发者模式，打开<code>ADB调试</code></li><li><code>adb devices</code>可以看到设备，看不到是连接问题，也可能是驱动问题，用MAC吧，我的就是连不上Windows</li><li><code>adb reboot bootloader</code>进入BootLoader</li><li><code>fastboot oem unlock</code>解锁</li><li>在官网下载正确的镜像（华为的国内版镜像在最下面，请仔细）</li><li>解压，执行命令<code>flash-all.sh</code>，等待镜像刷好，重启就好了</li></ol><blockquote><p>关于第4步，我在集成友盟统计的时候，需要访问<code>/data</code>文件夹，但是一直提示没有权限，后来“奇迹般”的又好了，期间可能的操作就是我又进行了锁定操作<code>fastboot oem lock</code>，没有进一步验证过<br>刷机后，应用市场上的AndroidWear软件可能会在于手表端数据传输时出问题，应该用官网上提供的预览版软件</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Android Wear开发的踩坑史……&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://lakeshire.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://lakeshire.github.io/tags/Android/"/>
    
      <category term="Wear" scheme="http://lakeshire.github.io/tags/Wear/"/>
    
  </entry>
  
  <entry>
    <title>Android布局优化</title>
    <link href="http://lakeshire.github.io/2016/11/15//archivers/layout-optimize/"/>
    <id>http://lakeshire.github.io/2016/11/15//archivers/layout-optimize/</id>
    <published>2016-11-15T09:00:00.000Z</published>
    <updated>2017-11-28T03:03:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>收集一些布局优化技巧，持续更新……</p><a id="more"></a><h3 id="include标签"><a href="#include标签" class="headerlink" title="include标签"></a>include标签</h3><p>可以复用布局，统一修改管理，典型的比如标题栏，也可以在<code>&lt;include&gt;</code>标签中重新设置<code>layout</code>属性</p><h3 id="merge标签"><a href="#merge标签" class="headerlink" title="merge标签"></a>merge标签</h3><p>用来去除不必要的视图层级</p><p>如果仅仅是添加子视图到父视图进行显示，而不指定任何针对父视图的布局属性，可以使用</p><p>另外，假如需要在<code>LinearLayout</code>里面嵌入一个布局，而恰恰这个布局的根节点也是<code>LinearLayout</code>，这样就多了一层没有用的嵌套，无疑这样只会拖慢程序速度，也需要使用</p><p><code>&lt;merge&gt;</code>标签只能作为<code>xml</code>的根元素</p><h3 id="TextView同时显示文字与图片"><a href="#TextView同时显示文字与图片" class="headerlink" title="TextView同时显示文字与图片"></a>TextView同时显示文字与图片</h3><p>一般是一个<code>ImageView</code>加一个<code>TextView</code>，其实可以用<code>TextView</code>直接搞定</p><pre><code>public void setCompoundDrawables(@Nullable Drawable left, @Nullable Drawable top, @Nullable Drawable right, @Nullable Drawable bottom);</code></pre><p>设置四个方向的<code>drawable</code></p><pre><code>public void setCompoundDrawablePadding(int pad);</code></pre><p>设置图片和文字的距离</p><h3 id="利用TextView的行间距"><a href="#利用TextView的行间距" class="headerlink" title="利用TextView的行间距"></a>利用TextView的行间距</h3><p><code>android:lineSpaceingExtra</code>属性可以改变行间距，还有<code>android:lineSpacingMultiplier</code>设定行距倍数</p><p>遇到多行文本，行间有一定距离的场景，就不需要多个<code>TextView</code>了</p><h3 id="一个TextView中不同的样式"><a href="#一个TextView中不同的样式" class="headerlink" title="一个TextView中不同的样式"></a>一个TextView中不同的样式</h3><p>如果一段文字中有多种样式，一般就是分成几个<code>TextView</code>去做</p><p>但是也可以通过<code>Spannable</code>或<code>Html.fromHtml()</code>实现</p><pre><code>String text;SpannableStringBuilder style = new SpannableStringBuilder(text);</code></pre><p><code>SpannableStringBuilder.setSpan()</code></p><pre><code>public void setSpan(Object what, int start, int end, int flags);</code></pre><p>设置的东西都是<code>CharacterStyle</code>的子类，比如<code>AbsoluteSizeSpan</code>定义字体大小，<code>ForegroundColorSpan</code>定义字体颜色等等</p><p><code>CharacterStyle</code></p><ul><li><code>ForegroundColorSpan</code></li><li><code>MaskFilterSpan</code></li><li><code>SuggestionSpan</code></li><li><code>RasterizerSpan</code></li><li><code>BackgroundColorSpan</code></li><li><code>StrikethroughSpan</code></li><li><code>UnderlineSpan</code></li><li><code>ClickableSpan</code><ul><li><code>URLSpan</code></li></ul></li><li><code>MetricAffectingSpan</code><ul><li><code>SubscriptSpan</code></li><li><code>StyleSpan</code></li><li><code>AbsoluteSizeSpan</code></li><li><code>RelativeSizeSpan</code></li><li><code>TextAppearanceSpan</code></li><li><code>SuperscriptSpan</code></li><li><code>LocaleSpan</code></li><li><code>ScaleXSpan</code></li><li><code>TypefaceSpan</code></li><li><code>ReplacementSpan</code><ul><li><code>DynamicDrawableSpan</code></li></ul></li></ul></li></ul><p>最后设置给<code>TextView</code></p><pre><code>mTextView.setText(style);</code></pre><h3 id="ViewStub"><a href="#ViewStub" class="headerlink" title="ViewStub"></a>ViewStub</h3><p><code>ViewStub</code>是个轻量级的<code>View</code>，不占用布局位置，可以实现按需加载，比如网络请求失败的提示页面</p><p>一旦<code>ViewStub</code>可见或是被<code>inflate()</code>了，它就不存在了，被获得的<code>View</code>取代</p><h3 id="LinearLayout的分割线"><a href="#LinearLayout的分割线" class="headerlink" title="LinearLayout的分割线"></a>LinearLayout的分割线</h3><p>比如两个按钮之间的一道分割线，一般都是用一个<code>View</code>，也可以直接使用<code>LinearLayout</code>的<code>android:divider</code>属性，<code>android:showDividers</code>可以设置显示位置，<code>android:dividerPadding</code>可以设置内边距</p><h3 id="Space"><a href="#Space" class="headerlink" title="Space"></a>Space</h3><p>要为布局间添加间距，可以通过添加一个空的<code>View</code>，也可以通过设置<code>margin</code>，但前者影响性能，后者影响可读性，这时可以使用<code>Space</code>，它也很轻量</p><h3 id="移除不必要的背景"><a href="#移除不必要的背景" class="headerlink" title="移除不必要的背景"></a>移除不必要的背景</h3><p>过多的背景叠加会导致过度绘制，会影响性能</p><blockquote><p>假设我们的<code>Activity</code>背景是白色，<code>Activity</code>的布局最终会加入<code>DecorView</code>中，那么这个<code>View</code>中的背景就没必要了，通过下面的代码</p><pre><code>getWindow().setBackgroundDrawable(null);</code></pre></blockquote><h3 id="使用TextSwitcher和ImageSwitcher平滑过渡"><a href="#使用TextSwitcher和ImageSwitcher平滑过渡" class="headerlink" title="使用TextSwitcher和ImageSwitcher平滑过渡"></a>使用TextSwitcher和ImageSwitcher平滑过渡</h3><p>很多时候文字改变的时候希望不那么突兀，平滑一点，可以使用这些类</p><p>使用<code>TextSwitcher</code></p><ol><li>获得<code>TextSwitcher</code>对象</li><li>通过<code>setFactory()</code>设置<code>ViewFactory</code>，实现<code>makeView()</code>方法，返回实际的<code>TextView</code></li><li>通过<code>setInAnimation()</code>设置换入动画</li><li>通过<code>setOutAnimation()</code>设置换出动画</li></ol><p><code>ImageSwitcher</code>也是同样的用法</p><p>这两个控件的目的是使过度更自然，代码更易读，因此不要滥用它们</p><h3 id="在onCreate中获得视图的宽高"><a href="#在onCreate中获得视图的宽高" class="headerlink" title="在onCreate中获得视图的宽高"></a>在onCreate中获得视图的宽高</h3><p>在<code>onCreate()</code>中调用<code>getWidth()</code>和<code>getHeight()</code>获得的都是0，可以使用<code>post()</code>方法</p><pre><code>view.post(new Runnable() {    @Override    public void run() {        int height = view.getHeight();        int width = view.getWidth();    }});</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;收集一些布局优化技巧，持续更新……&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://lakeshire.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://lakeshire.github.io/tags/Android/"/>
    
      <category term="性能优化" scheme="http://lakeshire.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>AsyncTask源码初步分析</title>
    <link href="http://lakeshire.github.io/2016/11/15//archivers/asynctask/"/>
    <id>http://lakeshire.github.io/2016/11/15//archivers/asynctask/</id>
    <published>2016-11-15T04:00:00.000Z</published>
    <updated>2017-11-28T03:04:18.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>AsyncTask</code>源码看似比较独立和简单，分析一下</p><a id="more"></a><h2 id="AsyncTask"><a href="#AsyncTask" class="headerlink" title="AsyncTask"></a>AsyncTask</h2><pre><code>public AsyncTask() {    mWorker = new WorkerRunnable&lt;Params, Result&gt;() {        public Result call() throws Exception {            mTaskInvoked.set(true);            Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);            //  这里调用后台运行            Result result = doInBackground(mParams);            Binder.flushPendingCommands();            //  发送结果            return postResult(result);        }    };    mFuture = new FutureTask&lt;Result&gt;(mWorker) {        @Override        protected void done() {            try {                postResultIfNotInvoked(get());            } catch (InterruptedException e) {                android.util.Log.w(LOG_TAG, e);            } catch (ExecutionException e) {                throw new RuntimeException(&quot;An error occurred while executing doInBackground()&quot;,                        e.getCause());            } catch (CancellationException e) {                postResultIfNotInvoked(null);            }        }    };}</code></pre><p>构造函数，分别构造了一个<code>WorkerRunnable</code>和一个<code>FutureTask</code><br><code>WorkerRunnable</code>就是任务，里面保存了<code>Params</code>，在执行结束后返回<code>Result</code><br><code>FutureTask</code>包装了一下任务，实际调度的是它，它会运行那个<code>WorkerRunnable</code>，得到返回结果在<code>done()</code>中处理</p><pre><code>private static abstract class WorkerRunnable&lt;Params, Result&gt; implements Callable&lt;Result&gt; {        Params[] mParams;}</code></pre><h3 id="线程相关接口和类"><a href="#线程相关接口和类" class="headerlink" title="线程相关接口和类"></a>线程相关接口和类</h3><p><img src="http://7xt3ho.com1.z0.glb.clouddn.com/Runnable.jpg" alt=""></p><pre><code>//  可被执行的命令，不返回结果public interface Runnable {    public void run();}//  一个任务，能够返回结果，可能抛出异常public interface Callable&lt;V&gt; {    V call() throws Exception;}//  Future代表了一个异步任务的结果//  有方法检查任务是否完成、等待完成、获得任务结果//  结果只能当任务完成时通过get()获得，必要的话会阻塞直到就绪public interface Future&lt;V&gt; {    boolean cancel(boolean mayInterruptIfRunning);    boolean isCancelled();    boolean isDone();    V get() throws InterruptedException, ExecutionException;    V get(long timeout, TimeUnit unit)        throws InterruptedException, ExecutionException, TimeoutException;}//  一个可运行的Future//  run()的成功执行导致Future的完成，并且允许访问其结果public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt; {    void run();}//  一个可取消的异步任务//  可以用来包裹Runnable或Callable//  因为实现了Runnable，所以可以提交给一个Executor处理//  可以开始和结束任务，查看任务结果public class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt; {    public FutureTask(Callable&lt;V&gt; callable) {        ......    }    public FutureTask(Runnable runnable, V result) {        ......    }    ......}</code></pre><h3 id="工作流"><a href="#工作流" class="headerlink" title="工作流"></a>工作流</h3><p>通过<code>execute()</code>执行，返回任务的引用，调用者可以保持引用</p><pre><code>@MainThreadpublic final AsyncTask&lt;Params, Progress, Result&gt; execute(Params... params) {    return executeOnExecutor(sDefaultExecutor, params);}@MainThreadpublic final AsyncTask&lt;Params, Progress, Result&gt; executeOnExecutor(Executor exec, Params... params) {    if (mStatus != Status.PENDING) {        switch (mStatus) {            case RUNNING:                //  不能执行正在执行的任务                throw new IllegalStateException(&quot;Cannot execute task:&quot; + &quot; the task is already running.&quot;);            case FINISHED:                //  不能执行完成的任务                throw new IllegalStateException(&quot;Cannot execute task:&quot; + &quot; the task has already been executed &quot; + &quot;(a task can be executed only once)&quot;);        }    }    mStatus = Status.RUNNING;    //  准备执行，重写的方法    onPreExecute();    mWorker.mParams = params;    //  线程池执行    exec.execute(mFuture);    return this;}     </code></pre><p>线程池执行任务，<code>FutureTask.run()</code></p><pre><code>public void run() {    if (state != NEW || !U.compareAndSwapObject(this, RUNNER, null, Thread.currentThread()))        return;    try {        Callable&lt;V&gt; c = callable;        if (c != null &amp;&amp; state == NEW) {            V result;            boolean ran;            try {                //  执行                result = c.call();                ran = true;            } catch (Throwable ex) {                result = null;                ran = false;                setException(ex);            }            if (ran)                //  设置结果                set(result);        }    } finally {        runner = null;        int s = state;        if (s &gt;= INTERRUPTING)            handlePossibleCancellationInterrupt(s);    }}protected void set(V v) {    if (U.compareAndSwapInt(this, STATE, NEW, COMPLETING)) {        outcome = v;        U.putOrderedInt(this, STATE, NORMAL);        finishCompletion();    }}private void finishCompletion() {    for (WaitNode q; (q = waiters) != null;) {        if (U.compareAndSwapObject(this, WAITERS, q, null)) {            for (;;) {                Thread t = q.thread;                if (t != null) {                    q.thread = null;                    LockSupport.unpark(t);                }                WaitNode next = q.next;                if (next == null)                    break;                q.next = null;                q = next;            }            break;        }    }    //  这个done()就是匿名类中重写的方法，表示完成后的处理    done();    callable = null;}</code></pre><p>完成后会调用这个，发消息从后台执行前台动作</p><pre><code>private Result postResult(Result result) {    @SuppressWarnings(&quot;unchecked&quot;)    Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT, new AsyncTaskResult&lt;Result&gt;(this, result));    message.sendToTarget();    return result;}</code></pre><p>那么一定有消息处理器</p><pre><code>private static class InternalHandler extends Handler {    public InternalHandler() {        super(Looper.getMainLooper());    }    @SuppressWarnings({&quot;unchecked&quot;, &quot;RawUseOfParameterizedType&quot;})    @Override    public void handleMessage(Message msg) {        AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj;        switch (msg.what) {            case MESSAGE_POST_RESULT:                result.mTask.finish(result.mData[0]);                break;            case MESSAGE_POST_PROGRESS:                result.mTask.onProgressUpdate(result.mData);                break;        }    }}private void finish(Result result) {    if (isCancelled()) {        //  取消        onCancelled(result);    } else {        //  执行结束        onPostExecute(result);    }    mStatus = Status.FINISHED;}</code></pre><h3 id="线程注解"><a href="#线程注解" class="headerlink" title="线程注解"></a>线程注解</h3><p>如果你的方法只能在指定的线程类型中被调用，那么你就可以使用以下4个注解来标注它：</p><ul><li><code>@UiThread</code></li><li><code>@MainThread</code></li><li><code>@WorkerThread</code></li><li><code>@BinderThread</code></li></ul><p>如果一个类中的所有方法都有相同的线程需求，那么你可以注解类本身。比如<code>android.view.View</code>，就被用<code>@UiThread</code>标注。</p><p>关于线程注解使用的一个很好的例子就是<code>AsyncTask</code>：</p><p>如果你在重写的<code>doInBackground()</code>方法里尝试调用<code>onProgressUpdate()</code>方法或者<code>View</code>的任何方法，就会马上把它标记为一个错误</p><blockquote><p><code>@UiThread</code>还是<code>@MainThread</code>?<br>在进程里只有一个主线程。这个就是<code>@MainThread</code>。同时这个线程也是一个<code>@UiThread</code>。比如<code>Activity</code>的主要窗口就运行在这个线程上。然而它也有能力为应用创建其他线程。这很少见，一般具备这样功能的都是系统进程。通常是把和生命周期有关的用<code>@MainThread</code>标注，和<code>View</code>层级结构相关的用<code>@UiThread</code>标注。但是由于<code>@MainThread</code>本质上是一个<code>@UiThread</code>，而大部分情况下<code>@UiThread</code>又是一个<code>@MainThread</code>，所以你能在一个可以调用<code>@MainThread</code>方法的地方也能调用<code>@UiThread</code>方法，反之亦然。</p></blockquote><h3 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h3><pre><code>private static volatile Executor sDefaultExecutor = SERIAL_EXECUTOR;//  这个执行器是串行的public static final Executor SERIAL_EXECUTOR = new SerialExecutor();private static final int CORE_POOL_SIZE = CPU_COUNT + 1;private static final int MAXIMUM_POOL_SIZE = CPU_COUNT * 2 + 1;//  这个执行器是并行的public static final Executor THREAD_POOL_EXECUTOR = new ThreadPoolExecutor(CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE, TimeUnit.SECONDS, sPoolWorkQueue, sThreadFactory);private static class SerialExecutor implements Executor {    final ArrayDeque&lt;Runnable&gt; mTasks = new ArrayDeque&lt;Runnable&gt;();    Runnable mActive;    public synchronized void execute(final Runnable r) {        //  将任务加入队列        //  做了一下包装 任务在运行完成或异常后执行下一个 保证线性执行        mTasks.offer(new Runnable() {            public void run() {                try {                    r.run();                } finally {                    scheduleNext();                }            }        });        if (mActive == null) {            scheduleNext();        }    }    protected synchronized void scheduleNext() {        if ((mActive = mTasks.poll()) != null) {            THREAD_POOL_EXECUTOR.execute(mActive);        }    }}//  这个方法可以指定使用的执行器@MainThreadpublic final AsyncTask&lt;Params, Progress, Result&gt; executeOnExecutor(Executor exec, Params... params);</code></pre><p>最初的版本，<code>AsyncTask</code>在单个后台线程上顺序执行<br>从<code>API4(1.6)</code>开始，变成了允许多个任务并行进行的线程池<br>从<code>API11(3.0)</code>开始，任务在一个单一线程执行以避免并行操作引起的错误<br>如果你需要并行执行，可以使用<code>executeOnExecutor()</code>，传入<code>THREAD_POOL_EXECUTOR</code></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>AsyncTask</code>是一个简单的在工作线程处理任务的方式，通过线程池调度任务（默认或者指定），后台任务的执行结果通过<code>Handler</code>机制发消息给<code>UI线程</code>更新界面</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;AsyncTask&lt;/code&gt;源码看似比较独立和简单，分析一下&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://lakeshire.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://lakeshire.github.io/tags/Android/"/>
    
      <category term="AsyncTask" scheme="http://lakeshire.github.io/tags/AsyncTask/"/>
    
      <category term="线程通信" scheme="http://lakeshire.github.io/tags/%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>OkHttp源码分析</title>
    <link href="http://lakeshire.github.io/2016/11/14//archivers/android-okhttp/"/>
    <id>http://lakeshire.github.io/2016/11/14//archivers/android-okhttp/</id>
    <published>2016-11-14T04:00:00.000Z</published>
    <updated>2017-11-28T03:16:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>OkHttp是一个一个处理网络请求的开源项目，是安卓端最火热的轻量级框架，由移动支付Square公司贡献</p><a id="more"></a><h2 id="Call"><a href="#Call" class="headerlink" title="Call"></a>Call</h2><p>接口，准备处理的一个请求，可以被取消，它代表了一个请求/响应，不能被处理两次</p><pre><code>public interface Call {    //  返回原始请求    Request request();    //  立刻调用请求，然后阻塞直到收到响应或错误    Response execute() throws IOException;    //  调度让请求在未来被调用    void enqueue(Callback responseCallback);    //  取消请求    void cancel();    boolean isExecuted();    boolean isCanceled();    //  产生Call的工厂    interface Factory {        Call newCall(Request request);    }}</code></pre><h2 id="OkHttpClient"><a href="#OkHttpClient" class="headerlink" title="OkHttpClient"></a>OkHttpClient</h2><p><code>Call</code>的工厂，<code>Call</code>能够被用来发送请求和接收响应</p><p>创建一个<code>OkHttpClient</code>实例并被所有的<code>HTTP</code>调用重用可以获得最好的表现，因为每个<code>client</code>都持有自己的连接池和线程池，重用连接和线程可以减少时延和节省内存，为每一个请求创建<code>client</code>浪费空闲池资源</p><pre><code>public final OkHttpClient client = new OkHttpClient();</code></pre><p>构造默认的<code>OkHttpCilent</code></p><pre><code>public final OkHttpClient client = new OkHttpClient.Builder().addInterceptor(new HttpLoggingInterceptor()).cache(new Cache(cacheDir, cacheSize)).build();</code></pre><p>用<code>Builder()</code>自定义</p><pre><code>OkHttpClient eagerClient = client.newBuilder().readTimeout(500, TimeUnit.MILLISECONDS).build();</code></pre><p>用<code>newBuilder()</code>自定义，但是重用原来的<code>OkHttpClient</code></p><pre><code>public class OkHttpClient implements Cloneable, Call.Factory {    @Override public Call newCall(Request request) {        return new RealCall(this, request);    }}</code></pre><p>实现了<code>Call.Factory</code>接口，调用<code>newCall()</code>可以产生一个<code>Call</code>，实际返回的是实现类<code>RealCall</code></p><h3 id="RealCall"><a href="#RealCall" class="headerlink" title="RealCall"></a>RealCall</h3><pre><code>protected RealCall(OkHttpClient client, Request originalRequest) {}</code></pre><p>构造函数接收两个参数<code>OkHttpClient</code>和<code>Request</code></p><pre><code>Request request() {    return originalRequest;}</code></pre><p>所以<code>request()</code>返回的就是这个原始请求</p><pre><code>@Override public Response execute() throws IOException {    synchronized (this) {        if (executed) throw new IllegalStateException(&quot;Already Executed&quot;);        executed = true;    }    try {        client.dispatcher().executed(this);        Response result = getResponseWithInterceptorChain(false);        if (result == null) throw new IOException(&quot;Canceled&quot;);        return result;    } finally {        client.dispatcher().finished(this);    }}</code></pre><p>同步请求，一个请求只能执行一次，否则会抛异常，通过<code>Dispatcher</code>来分发请求，执行请求后，通过<code>getResponseWithInterceptorChain()</code>获取结果</p><pre><code>private Response getResponseWithInterceptorChain() throws IOException {    //  除了构造client时指定的拦截器外 还添加了几个内部的    List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;();    interceptors.addAll(client.interceptors());    interceptors.add(retryAndFollowUpInterceptor);    interceptors.add(new BridgeInterceptor(client.cookieJar()));    interceptors.add(new CacheInterceptor(client.internalCache()));    interceptors.add(new ConnectInterceptor(client));    if (!retryAndFollowUpInterceptor.isForWebSocket()) {      interceptors.addAll(client.networkInterceptors());    }    interceptors.add(new CallServerInterceptor(retryAndFollowUpInterceptor.isForWebSocket()));    Interceptor.Chain chain = new RealInterceptorChain(        interceptors, null, null, null, 0, originalRequest);    return chain.proceed(originalRequest);  }</code></pre><p>这个函数以及<code>Chain</code>的实现版本之间应该有过重构</p><p>异步请求</p><pre><code>void enqueue(Callback responseCallback, boolean forWebSocket) {    synchronized (this) {        if (executed) throw new IllegalStateException(&quot;Already Executed&quot;);        executed = true;    }    client.dispatcher().enqueue(new AsyncCall(responseCallback, forWebSocket)); }</code></pre><p>将一个<code>AsyncCall</code>放进队列，里面重写了<code>execute()</code>，在<code>getResponseWithInterceptorChain()</code>获得响应后调用回调</p><pre><code>@Override protected void execute() {    boolean signalledCallback = false;    try {        Response response = getResponseWithInterceptorChain(forWebSocket);        if (canceled) {            signalledCallback = true;            responseCallback.onFailure(RealCall.this, new IOException(&quot;Canceled&quot;));        } else {            signalledCallback = true;            responseCallback.onResponse(RealCall.this, response);        }    } catch (IOException e) {        if (signalledCallback) {            logger.log(Level.INFO, &quot;Callback failure for &quot; + toLoggableString(), e);        } else {            responseCallback.onFailure(RealCall.this, e);        }    } finally {        client.dispatcher().finished(this);    }}</code></pre><h3 id="Dispatcher"><a href="#Dispatcher" class="headerlink" title="Dispatcher"></a>Dispatcher</h3><p>分配器</p><pre><code>//  准备好的异步调用，将要被执行private final Deque&lt;AsyncCall&gt; readyAsyncCalls = new ArrayDeque&lt;&gt;();//  正在执行中的异步调用private final Deque&lt;AsyncCall&gt; runningAsyncCalls = new ArrayDeque&lt;&gt;();//  正在执行中的同步调用private final Deque&lt;RealCall&gt; runningSyncCalls = new ArrayDeque&lt;&gt;();</code></pre><p>用这三个队列管理调用，可以指定最大请求数</p><h3 id="Interceptor"><a href="#Interceptor" class="headerlink" title="Interceptor"></a>Interceptor</h3><pre><code>public interface Interceptor {    Response intercept(Chain chain) throws IOException;    interface Chain {        Request request();        Response proceed(Request request) throws IOException;        Connection connection();    }}</code></pre><p>拦截器，观察、修改请求和响应，典型的用来添加删除修改头部信息</p><h4 id="RealInterceptorChain"><a href="#RealInterceptorChain" class="headerlink" title="RealInterceptorChain"></a>RealInterceptorChain</h4><p><code>RealInterceptorChain</code>是<code>Chain</code>的实现类</p><pre><code>public Response proceed(Request request, StreamAllocation streamAllocation, HttpStream httpStream, Connection connection) throws IOException {    ......    //  调用拦截链中的下一个拦截器    RealInterceptorChain next = new RealInterceptorChain(        interceptors, streamAllocation, httpStream, connection, index + 1, request);    Interceptor interceptor = interceptors.get(index);    Response response = interceptor.intercept(next);    ......    return response;}</code></pre><p>最重要的<code>proceed()</code>方法的实现，<code>OkHttpClient</code>里有一个拦截器列表，会先用列表里这个拦截器进行拦截，传给它一个<code>index+1</code>的<code>Chain</code>，<del>否则调用<code>getResponse()</code>做<code>HTTP</code>请求</del>，之前<code>getResponse()</code>里和<code>HttpEngine</code>的功能逻辑拆分到了新的内部拦截器中</p><p><code>RetryAndFollowUpInterceptor</code>尝试恢复错误和之后的重定向<br><code>BridgeInterceptor</code>首先从用户请求构造网络请求，然后处理网络调用，最后从网络响应构造用户响应<br><code>CacheInterceptor</code>处理缓存<br><code>ConnectInterceptor</code>打开服务器连接<br><code>CallServerInterceptor</code>链中的最终的拦截器，它向服务器发送请求<br><code>Chain</code>携带了请求的信息，还提供了获取响应的逻辑</p><p>拦截器是在构造的时候的自己添加上去的，一般是这样</p><pre><code>OkHttpClient client = new OkHttpClient().newBuilder().addInterceptor(new Interceptor() {    @Override    public Response intercept(Chain chain) throws IOException {        Request request = chain.request();        //  处理request        Response response = chain.proceed(request);        //  处理response        return response;    }}).build();</code></pre><p>通过关键方法<code>Chain.proceed()</code>获得<code>Response</code>，再看看上面的代码，发现在获得响应之前会依次执行拦截器</p><h4 id="RetryAndFollowUpInterceptor"><a href="#RetryAndFollowUpInterceptor" class="headerlink" title="RetryAndFollowUpInterceptor"></a>RetryAndFollowUpInterceptor</h4><pre><code>public Response intercept(Chain chain) throws IOException {    //  在一个循环里处理首个请求和后续请求    while (true) {        ......        //  交由下一个拦截器处理        response = ((RealInterceptorChain) chain).proceed(request, streamAllocation, null, null);        ......        //  查看后续请求        Request followUp = followUpRequest(response);        ......    }}</code></pre><p><code>followUpRequest()</code>用来指出为了回应响应应该发什么请求，可能是添加认证头、重定向或者处理客户端请求超时</p><h4 id="BridgeInterceptor"><a href="#BridgeInterceptor" class="headerlink" title="BridgeInterceptor"></a>BridgeInterceptor</h4><pre><code>public Response intercept(Chain chain) throws IOException {    //  构造网络请求头    //  添加Content-Type/Content-Length/Host/Connection/Accept-Encoding等字段    //  添加User-Agent字段    //  添加Cookie字段    ......    Response networkResponse = chain.proceed(requestBuilder.build());    //  获得网络响应 处理后返回    //  处理Cookiew    //  Gzip解压    ......}</code></pre><h4 id="CacheInterceptor"><a href="#CacheInterceptor" class="headerlink" title="CacheInterceptor"></a>CacheInterceptor</h4><pre><code>public Response intercept(Chain chain) throws IOException {    //  从缓存中获取请求，处理异常状况    ......    networkResponse = chain.proceed(networkRequest);    //  获得网络响应    //  判断是使用网络响应还是缓存响应    //  可能要更新缓存    ......}</code></pre><h4 id="ConnectInterceptor"><a href="#ConnectInterceptor" class="headerlink" title="ConnectInterceptor"></a>ConnectInterceptor</h4><pre><code>public Response intercept(Chain chain) throws IOException {    StreamAllocation streamAllocation = realChain.streamAllocation();    ......    RealConnection connection = streamAllocation.connection();    ......    return realChain.proceed(request, streamAllocation, httpStream, connection);  }</code></pre><p>调用了<code>StreamAllocation.newStream()</code>:</p><p>首先通过<code>findHealthyConnection()</code>查找健康的连接，然后获得<code>HttpStream</code><br><code>findConnection()</code>查找连接，首先看是否有存在的连接，然后查找连接池，都没有的话就创建一个并加入连接池，然后<code>connect()</code><br>连接的调用路径：<code>RealConnection.connect()</code>-&gt;<code>Platform.connectSocket()</code>—&gt;<code>Socket.connect()</code><br><code>Platform</code>显然是与底层具体实现有关，在构造的时候会通过<code>findPlatform()</code>决定底层实现</p><h4 id="CallServerInterceptor"><a href="#CallServerInterceptor" class="headerlink" title="CallServerInterceptor"></a>CallServerInterceptor</h4><pre><code>public Response intercept(Chain chain) throws IOException {    //  写入请求头    httpStream.writeRequestHeaders(request);    //  写入请求体    ......    //  读取响应    Response response = httpStream.readResponseHeaders().request(request).handshake(streamAllocation.connection().handshake()).sentRequestAtMillis(sentRequestMillis).receivedResponseAtMillis(System.currentTimeMillis()).build();    //  读取响应体并返回    ......}</code></pre><h4 id="StreamAllocation"><a href="#StreamAllocation" class="headerlink" title="StreamAllocation"></a>StreamAllocation</h4><p>这个类用来协调三个实体的关系：</p><ul><li>连接(<code>Connections</code>)：到远程服务器的物理连接，可能建立起来很慢所以有必要能够在连接中取消</li><li>流(<code>Streams</code>)：在连接上的逻辑<code>HTTP</code>请求响应对，每个连接有它自己的分配限制，定义了同时能承载多少个流，<code>HTTP/1.X</code>可以承载一个流，<code>SPDY</code>和<code>HTTP/2</code>可以承载多个</li><li>调用(<code>Calls</code>)：一个流的逻辑序列，典型的是它的初始请求和后续请求，我们倾向于保持所有一个单独调用的流在一个连接上，为了更好的表现</li></ul><p><code>newStream()</code>里面做了判断，可以返回<code>Http1xStream</code>或<code>Http2xStream</code>，它们都实现了<code>HttpStream</code>接口</p><pre><code>public interface HttpStream {    Sink createRequestBody(Request request, long contentLength) throws IOException;    void writeRequestHeaders(Request request) throws IOException;    void writeRequestBody(RetryableSink requestBody) throws IOException;    void finishRequest() throws IOException;    Response.Builder readResponseHeaders() throws IOException;    ResponseBody openResponseBody(Response response) throws IOException;    void setHttpEngine(HttpEngine httpEngine);    void cancel();}</code></pre><p>参考文章：<a href="https://www.zhihu.com/question/34074946" target="_blank" rel="noopener">HTTP/1和HTTP/2</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>OkHttpClient</code>通过<code>newCall()</code>产生<code>Call</code></p><p>同步调用<code>execute()</code>(异步调用就是个线程池)，会依次调用拦截链上的拦截器，其中包括一些内置的拦截器：</p><ul><li>自定义拦截器</li><li>重试与后续请求</li><li>构造请求和响应</li><li>缓存</li><li>连接：这里调用了<code>Socket</code>的连接，并且获得了请求和响应的缓冲区</li><li>请求：通过<code>HttpStream</code>写入请求读取响应</li></ul><h2 id="之前版本的实现"><a href="#之前版本的实现" class="headerlink" title="之前版本的实现"></a>之前版本的实现</h2><p><del>之前的版本在处理完拦截器之后，会调用<code>getResponse()</code>方法，实际上包括了新版本的一部分拦截器功能</del></p><pre><code>Response getResponse(Request request, boolean forWebSocket) throws IOException {    //  获得请求体，然后获得一些元数据构造请求头    RequestBody body = request.body();    if (body != null) {        Request.Builder requestBuilder = request.newBuilder();        //  获得Content-Type字段        MediaType contentType = body.contentType();        if (contentType != null) {            requestBuilder.header(&quot;Content-Type&quot;, contentType.toString());        }        //  获得Content-Length字段或者Transfer-Encoding字段        long contentLength = body.contentLength();        if (contentLength != -1) {            requestBuilder.header(&quot;Content-Length&quot;, Long.toString(contentLength));            requestBuilder.removeHeader(&quot;Transfer-Encoding&quot;);        } else {            requestBuilder.header(&quot;Transfer-Encoding&quot;, &quot;chunked&quot;);            requestBuilder.removeHeader(&quot;Content-Length&quot;);        }        request = requestBuilder.build();    }    //  构建HTTP引擎，重试和重定向需要重新构造    engine = new HttpEngine(client, request, false, false, forWebSocket, null, null, null);    int followUpCount = 0;    while (true) {        //  检测取消标志        if (canceled) {            engine.releaseStreamAllocation();            throw new IOException(&quot;Canceled&quot;);        }        boolean releaseConnection = true;        try {            engine.sendRequest();            engine.readResponse();            releaseConnection = false;        } catch (RequestException e) {            throw e.getCause();        } catch (RouteException e) {            //  试图恢复路由错误            HttpEngine retryEngine = engine.recover(e.getLastConnectException(), null);            if (retryEngine != null) {                releaseConnection = false;                engine = retryEngine;                continue;            }            throw e.getLastConnectException();        } catch (IOException e) {            //  视图恢复IO错误            HttpEngine retryEngine = engine.recover(e, null);            if (retryEngine != null) {                releaseConnection = false;                engine = retryEngine;                continue;            }            throw e;        } finally {            //  清理工作            if (releaseConnection) {                StreamAllocation streamAllocation = engine.close();                streamAllocation.release();            }        }        Response response = engine.getResponse();        Request followUp = engine.followUpRequest();        if (followUp == null) {            if (!forWebSocket) {                engine.releaseStreamAllocation();            }            return response;        }        StreamAllocation streamAllocation = engine.close();        if (++followUpCount &gt; MAX_FOLLOW_UPS) {            streamAllocation.release();            throw new ProtocolException(&quot;Too many follow-up requests: &quot; + followUpCount);        }        if (!engine.sameConnection(followUp.url())) {            streamAllocation.release();            streamAllocation = null;        }        request = followUp;        engine = new HttpEngine(client, request, false, false, forWebSocket, streamAllocation, null, response);    }}</code></pre><p>其中<code>Content-Length</code>和<code>Transfer-Encoding</code>参见<a href="https://imququ.com/post/transfer-encoding-header-in-http.html#simple_thread" target="_blank" rel="noopener">HTTP 协议中的 Transfer-Encoding</a></p><p><del>实际的工作通过<code>HttpEngine</code>完成，现在完全由拦截器完成</del></p><h4 id="HttpEngine"><a href="#HttpEngine" class="headerlink" title="HttpEngine"></a>HttpEngine</h4><p><del><code>HttpEngine</code>处理一个单独的请求响应对，按照下面的生命周期：</del></p><ol><li><del>创建</del></li><li><del>用<code>sendRequest()</code>发送请求消息，一旦发送了请求再修改请求头就会出错，如果有请求体的话可以写入</del></li><li><del>用<code>readResponse()</code>读取响应消息，之后响应头和响应体可以被读取，所有的响应都有一个响应提输入流，尽管在一些实例中是空的</del></li></ol><p><del><code>sendRequest()</code>方法</del></p><pre><code>public void sendRequest() throws RequestException, RouteException, IOException {    if (cacheStrategy != null) {        return;    }    if (httpStream != null) {        throw new IllegalStateException();     }    Request request = networkRequest(userRequest);    //  缓存相关处理    InternalCache responseCache = Internal.instance.internalCache(client);    Response cacheCandidate = responseCache != null ? responseCache.get(request) : null;    long now = System.currentTimeMillis();    cacheStrategy = new CacheStrategy.Factory(now, request, cacheCandidate).get();    networkRequest = cacheStrategy.networkRequest;    cacheResponse = cacheStrategy.cacheResponse;    if (responseCache != null) {        responseCache.trackResponse(cacheStrategy);    }    if (cacheCandidate != null &amp;&amp; cacheResponse == null) {        closeQuietly(cacheCandidate.body());    }    if (networkRequest == null &amp;&amp; cacheResponse == null) {        userResponse = new Response.Builder().request(userRequest).priorResponse(stripBody(priorResponse)).protocol(Protocol.HTTP_1_1).code(504).message(&quot;Unsatisfiable Request (only-if-cached)&quot;).body(EMPTY_BODY).build();    return;    }    if (networkRequest == null) {        userResponse = cacheResponse.newBuilder().request(userRequest).priorResponse(stripBody(priorResponse)).cacheResponse(stripBody(cacheResponse)).build();        userResponse = unzip(userResponse);        return;    }    boolean success = false;    try {        httpStream = connect();        httpStream.setHttpEngine(this);        long contentLength = OkHeaders.contentLength(request);        if (bufferRequestBody) {            //  请求体必须在传输之前缓冲            if (contentLength &gt; Integer.MAX_VALUE) {                throw new IllegalStateException(&quot;Use setFixedLengthStreamingMode() or &quot; + &quot;setChunkedStreamingMode() for requests larger than 2 GiB.&quot;);            }            if (contentLength != -1) {                //  已知请求体的长度                httpStream.writeRequestHeaders(networkRequest);                requestBodyOut = new RetryableSink((int) contentLength);            } else {                //  缓存未知长度的请求体，直到整个请求体都准备好不会写入请求头                requestBodyOut = new RetryableSink();            }        } else {          httpStream.writeRequestHeaders(networkRequest);          requestBodyOut = httpStream.createRequestBody(networkRequest, contentLength);        }        success = true;    } finally {        if (!success &amp;&amp; cacheCandidate != null) {            closeQuietly(cacheCandidate.body());        }    }}</code></pre><p><del><code>sendRequest()</code>中调用<code>networkRequest()</code>构造请求<br>如果<code>request</code>中不存在这些字段<code>Host</code>/<code>Connection</code>/<code>Accept-Encoding</code>/<code>User-Agent</code>则添加默认值<br>另外会添加<code>Cookie</code>字段如果对应<code>url的</code>cookie`不为空的话</del></p><p><del>通过<code>connect()</code>发起连接</del></p><pre><code>private HttpStream connect() throws RouteException, RequestException, IOException {    boolean doExtensiveHealthChecks = !networkRequest.method().equals(&quot;GET&quot;);    return streamAllocation.newStream(client.connectTimeoutMillis(), client.readTimeoutMillis(), client.writeTimeoutMillis(), client.retryOnConnectionFailure(), doExtensiveHealthChecks);}</code></pre><p><del>调用了<code>StreamAllocation.newStream()</code>，首先通过<code>findHealthyConnection()</code>查找健康的连接，然后获得<code>HttpStream</code></del></p><p><del><code>findConnection()</code>查找连接，首先看是否有存在的连接，然后查找连接池，都没有的话就创建一个并加入连接池</del></p><p><del>创建连接会生成一个<code>RealConnection</code>的实例，它实现<code>Connection</code>接口</del></p><p><del>连接的调用路径：<code>RealConnection.connect()</code>-&gt;<code>Platform.connectSocket()</code>—&gt;<code>Socket.connect()</code></del></p><p><del><code>Platform</code>显然是与底层具体实现有关，在构造的时候会通过<code>findPlatform()</code>决定底层实现</del></p><p><del><code>readResponse()</code>方法</del></p><pre><code>public void readResponse() throws IOException {    //  响应已经准备好了    if (userResponse != null) {      return;    }    if (networkRequest == null &amp;&amp; cacheResponse == null) {      throw new IllegalStateException(&quot;call sendRequest() first!&quot;);    }    //  没有响应    if (networkRequest == null) {      return;    }    Response networkResponse;    if (forWebSocket) {        httpStream.writeRequestHeaders(networkRequest);        networkResponse = readNetworkResponse();    } else if (!callerWritesRequestBody) {        networkResponse = new NetworkInterceptorChain(0, networkRequest).proceed(networkRequest);    } else {        //  向Buffer中写入请求体        if (bufferedRequestBody != null &amp;&amp; bufferedRequestBody.buffer().size() &gt; 0) {            bufferedRequestBody.emit();        }        //  向Socket写入请求头 如果还没有的话        if (sentRequestMillis == -1) {            if (OkHeaders.contentLength(networkRequest) == -1 &amp;&amp; requestBodyOut instanceof RetryableSink) {                long contentLength = ((RetryableSink) requestBodyOut).contentLength();                networkRequest = networkRequest.newBuilder().header(&quot;Content-Length&quot;, Long.toString(contentLength)).build();            }            httpStream.writeRequestHeaders(networkRequest);        }        //  向Socket写入请求体         if (requestBodyOut != null) {            if (bufferedRequestBody != null) {              // This also closes the wrapped requestBodyOut.                bufferedRequestBody.close();            } else {                requestBodyOut.close();            }            if (requestBodyOut instanceof RetryableSink) {                httpStream.writeRequestBody((RetryableSink) requestBodyOut);            }        }        //  读取响应        networkResponse = readNetworkResponse();    }    //  接受请求头 主要是处理Cookie    receiveHeaders(networkResponse.headers());    //  如果我们有缓存起来的响应，那么要做一个条件判断    if (cacheResponse != null) {        if (validate(cacheResponse, networkResponse)) {            //  使用网络响应            userResponse = cacheResponse.newBuilder().request(userRequest).priorResponse(stripBody(priorResponse)).headers(combine(cacheResponse.headers(), networkResponse.headers())).cacheResponse(stripBody(cacheResponse)).networkResponse(stripBody(networkResponse)).build();            //  关闭响应体 释放            networkResponse.body().close();            releaseStreamAllocation();            //  更新缓存列表            InternalCache responseCache = Internal.instance.internalCache(client);            responseCache.trackConditionalCacheHit();            responseCache.update(cacheResponse, stripBody(userResponse));            userResponse = unzip(userResponse);            return;        } else {            closeQuietly(cacheResponse.body());        }    }    //  网络响应    userResponse = networkResponse.newBuilder().request(userRequest).priorResponse(stripBody(priorResponse)).cacheResponse(stripBody(cacheResponse)).networkResponse(stripBody(networkResponse)).build();    if (hasBody(userResponse)) {        //  缓存处理        maybeCache();        userResponse = unzip(cacheWritingResponse(storeRequest, userResponse));    }}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;OkHttp是一个一个处理网络请求的开源项目，是安卓端最火热的轻量级框架，由移动支付Square公司贡献&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://lakeshire.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://lakeshire.github.io/tags/Android/"/>
    
      <category term="开源库" scheme="http://lakeshire.github.io/tags/%E5%BC%80%E6%BA%90%E5%BA%93/"/>
    
      <category term="网络通信" scheme="http://lakeshire.github.io/tags/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>Gson源码分析</title>
    <link href="http://lakeshire.github.io/2016/11/08//archivers/gson/"/>
    <id>http://lakeshire.github.io/2016/11/08//archivers/gson/</id>
    <published>2016-11-08T04:00:00.000Z</published>
    <updated>2017-11-28T03:17:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>Gson是Google开发的Java API,用于转换Java对象和Json对象</p><a id="more"></a><h2 id="Gson源码分析"><a href="#Gson源码分析" class="headerlink" title="Gson源码分析"></a>Gson源码分析</h2><h3 id="Gson"><a href="#Gson" class="headerlink" title="Gson"></a>Gson</h3><p><code>Gson</code>的构造函数接收很多参数，<code>Gson()</code>提供了一些默认的值</p><p>主要有两个方法<code>toJson()</code>和<code>fromJson()</code></p><p><code>toJson()</code>最终调用的是下面这个方法    </p><pre><code>public void toJson(Object src, Type typeOfSrc, JsonWriter writer) throws JsonIOException {    TypeAdapter adapter = this.getAdapter(TypeToken.get(typeOfSrc));    boolean oldLenient = writer.isLenient();    writer.setLenient(true);    boolean oldHtmlSafe = writer.isHtmlSafe();    writer.setHtmlSafe(this.htmlSafe);    boolean oldSerializeNulls = writer.getSerializeNulls();    writer.setSerializeNulls(this.serializeNulls);    try {        adapter.write(writer, src);    } catch (IOException var12) {        throw new JsonIOException(var12);    } finally {        writer.setLenient(oldLenient);        writer.setHtmlSafe(oldHtmlSafe);        writer.setSerializeNulls(oldSerializeNulls);    }}</code></pre><p><code>fromJson()</code>最终调用的是下面这个方法</p><pre><code>public &lt;T&gt; T fromJson(JsonReader reader, Type typeOfT) throws JsonIOException, JsonSyntaxException {    boolean isEmpty = true;    boolean oldLenient = reader.isLenient();    reader.setLenient(true);    TypeAdapter typeAdapter;    try {        reader.peek();        isEmpty = false;        TypeToken e = TypeToken.get(typeOfT);        typeAdapter = this.getAdapter(e);        Object object = typeAdapter.read(reader);        Object var8 = object;        return var8;    } catch (EOFException var14) {        if(!isEmpty) {            throw new JsonSyntaxException(var14);        }        typeAdapter = null;    } catch (IllegalStateException var15) {        throw new JsonSyntaxException(var15);    } catch (IOException var16) {        throw new JsonSyntaxException(var16);    } finally {        reader.setLenient(oldLenient);    }    return typeAdapter;}</code></pre><p>都是通过<code>TypeAdapter</code>的<code>read()</code>和<code>write()</code>完成</p><p>通过<code>getAdapter()</code>方法获得对应类型的适配器</p><pre><code>public &lt;T&gt; TypeAdapter&lt;T&gt; getAdapter(TypeToken&lt;T&gt; type) {    //  首先查找缓存，节省时间    TypeAdapter cached = (TypeAdapter)this.typeTokenCache.get(type);    if(cached != null) {        return cached;    } else {        //  threadCalls是一个type-adapter表        Object threadCalls = (Map)this.calls.get();        boolean requiresThreadLocalCleanup = false;        if(threadCalls == null) {            threadCalls = new HashMap();            this.calls.set(threadCalls);            requiresThreadLocalCleanup = true;        }        //  从列表中拿到对应type的adapter        Gson.FutureTypeAdapter ongoingCall = (Gson.FutureTypeAdapter)((Map)threadCalls).get(type);        if(ongoingCall != null) {            return ongoingCall;        } else {            try {                // 没有就遍历工厂列表，创建一个合适的TypeAdapter                Gson.FutureTypeAdapter call = new Gson.FutureTypeAdapter();                ((Map)threadCalls).put(type, call);                Iterator i$ = this.factories.iterator();                TypeAdapter candidate;                do {                    if(!i$.hasNext()) {                        throw new IllegalArgumentException(&quot;GSON cannot handle &quot; + type);                    }                    TypeAdapterFactory factory = (TypeAdapterFactory)i$.next();                    candidate = factory.create(this, type);                } while(candidate == null);                    call.setDelegate(candidate);                    this.typeTokenCache.put(type, candidate);                    TypeAdapter var10 = candidate;                    return var10;            } finally {                //  清理：从列表中移除这个type对应的adapter，为什么？                ((Map)threadCalls).remove(type);                if(requiresThreadLocalCleanup) {                    //  为何会在这里做移除？                    this.calls.remove();                }            }        }    }}</code></pre><p>这个方法涉及到多线程的处理，不太易懂，使用了一个<code>ThreadLocal</code>来存放<code>Type-Adapter</code>列表</p><h3 id="TypeAdapter"><a href="#TypeAdapter" class="headerlink" title="TypeAdapter"></a>TypeAdapter</h3><pre><code>public abstract class TypeAdapter&lt;T&gt; {    public abstract void write(JsonWriter var1, T var2) throws IOException;    public abstract T read(JsonReader var1) throws IOException;    ......}</code></pre><p>一个抽象的泛型类，用来执行序列化和反序列化，关键的方法是<code>write()</code>和<code>read()</code></p><p>这个东西和创建它的工厂基本是最重要的结构</p><pre><code>public interface TypeAdapterFactory {    &lt;T&gt; TypeAdapter&lt;T&gt; create(Gson var1, TypeToken&lt;T&gt; var2);}</code></pre><p>工厂接口的<code>create()</code>负责创建<code>TypeAdapter</code></p><pre><code>private final List&lt;TypeAdapterFactory&gt; factories;</code></pre><p><code>Gson</code>类中有个工厂的列表，在构造函数中被添加很多的工厂</p><pre><code>INTEGER = new TypeAdapter() {    public Number read(JsonReader in) throws IOException {        if(in.peek() == JsonToken.NULL) {            in.nextNull();            return null;        } else {            try {                return Integer.valueOf(in.nextInt());            } catch (NumberFormatException var3) {                throw new JsonSyntaxException(var3);            }        }    }    public void write(JsonWriter out, Number value) throws IOException {        out.value(value);    }};INTEGER_FACTORY = newFactory(Integer.TYPE, Integer.class, INTEGER);</code></pre><p>上面是解析<code>int</code>的<code>TypeAdapter</code>，里面是通过<code>JsonReader</code>和<code>JsonWriter</code>读写</p><h3 id="JsonReader"><a href="#JsonReader" class="headerlink" title="JsonReader"></a>JsonReader</h3><pre><code>public JsonReader(Reader in);</code></pre><p>构造函数接收<code>Reader</code>作为参数</p><pre><code>public void beginObject() throws IOException {    int p = this.peeked;    if(p == 0) {        p = this.doPeek();    }    if(p == 1) {        this.push(3);        this.peeked = 0;    } else {        throw new IllegalStateException(&quot;Expected BEGIN_OBJECT but was &quot; + this.peek() + &quot; at line &quot; + this.getLineNumber() + &quot; column &quot; + this.getColumnNumber());    }}</code></pre><p>标记对象的开始，提取，如果是对象开始，则进栈3（<code>PEEKED_BEGIN_ARRAY</code>），如果不是则抛出异常</p><pre><code>public void endObject() throws IOException {    int p = this.peeked;    if(p == 0) {        p = this.doPeek();    }    if(p == 2) {        --this.stackSize;        this.peeked = 0;    } else {        throw new IllegalStateException(&quot;Expected END_OBJECT but was &quot; + this.peek() + &quot; at line &quot; + this.getLineNumber() + &quot; column &quot; + this.getColumnNumber());    }}</code></pre><p>标记对象的结束</p><pre><code>public void beginArray() throws IOException {    int p = this.peeked;    if(p == 0) {        p = this.doPeek();    }    if(p == 3) {        this.push(1);        this.peeked = 0;    } else {        throw new IllegalStateException(&quot;Expected BEGIN_ARRAY but was &quot; + this.peek() + &quot; at line &quot; + this.getLineNumber() + &quot; column &quot; + this.getColumnNumber());    }}</code></pre><p> 标记数组的开始，提取，如果是数组开始，则进栈1（<code>PEEKED_BEGIN_OBJECT</code>），如果不是则抛异常</p><pre><code>public void endArray() throws IOException {    int p = this.peeked;    if(p == 0) {        p = this.doPeek();    }    if(p == 4) {        --this.stackSize;        this.peeked = 0;    } else {        throw new IllegalStateException(&quot;Expected END_ARRAY but was &quot; + this.peek() + &quot; at line &quot; + this.getLineNumber() + &quot; column &quot; + this.getColumnNumber());    }}</code></pre><p>标记数组的结束</p><pre><code>public boolean hasNext() throws IOException {    int p = this.peeked;    if(p == 0) {        p = this.doPeek();    }    return p != 2 &amp;&amp; p != 4;}</code></pre><p>判断是否有下一个元素，如果不是对象结束和数组结束则有下一个元素，注意这里在提取后没有<code>this.peeked = 0</code>，所以下一次操作不会再提取一次，而是使用取得的值</p><pre><code>public String nextName() throws IOException {    int p = this.peeked;    if(p == 0) {        p = this.doPeek();    }    String result;    if(p == 14) {   //  PEEKED_UNQUOTED_NAME        result = this.nextUnquotedValue();    } else if(p == 12) {    //  PEEKED_SINGLE_QUOTED_NAME        result = this.nextQuotedValue(&apos;\&apos;&apos;);    } else {        if(p != 13) {   //  PEEKED_DOUBLE_QUOTED_NAME            throw new IllegalStateException(&quot;Expected a name but was &quot; + this.peek() + &quot; at line &quot; + this.getLineNumber() + &quot; column &quot; + this.getColumnNumber());        }        result = this.nextQuotedValue(&apos;\&quot;&apos;);    }    this.peeked = 0;    return result;}</code></pre><p>下一个键，三种形式：无引号、单引号、双引号</p><p>然后是<code>nextXX()</code>系列函数，读取下一个值，读取完成后会设置<code>this.peeked = 0</code>复位</p><pre><code>private int doPeek() throws IOException {    //  获得当前栈顶    int peekStack = this.stack[this.stackSize - 1];    int c;    if(peekStack == 1) {    //  PEEKED_BEGIN_OBJECT        //  再次进入切换为结束构造对象        this.stack[this.stackSize - 1] = 2; //  PEEKED_END_OBJECT    } else if(peekStack == 2) { //  PEEKED_END_OBJECT        c = this.nextNonWhitespace(true);        switch(c) {        case 44:    //  逗号            break;        case 59:    //  分号            this.checkLenient();            break;        case 93:    //  右方括号            return this.peeked = 4; //  PEEKED_END_ARRAY        default:            throw this.syntaxError(&quot;Unterminated array&quot;);        }    } else {        if(peekStack == 3 || peekStack == 5) {  //  PEEKED_BEGIN_ARRAY || PEEKED_TRUE        //  切换为结束数组        //  两种情况，一是目前是开始数组，二是完成一个键值对            this.stack[this.stackSize - 1] = 4; //  PEEKED_END_ARRAY            //  完成键值对的情况，可能有更多键值对，可能就结束了            if(peekStack == 5) {                c = this.nextNonWhitespace(true);                switch(c) {                case 44:    //  逗号                    break;                case 59:    //  分号                    this.checkLenient();                    break;                case 125:   //  右大括号                    return this.peeked = 2; //  PEEKED_END_OBJECT                default:                    throw this.syntaxError(&quot;Unterminated object&quot;);                }            }            c = this.nextNonWhitespace(true);            switch(c) {            case 34:    //  双引号                return this.peeked = 13;    //  PEEKED_DOUBLE_QUOTED_NAME            case 39:    //  单引号                this.checkLenient();                return this.peeked = 12;    //  PEEKED_SINGLE_QUOTED_NAME            case 125:   //  右大括号                if(peekStack != 5) {                    return this.peeked = 2; //  PEEKED_END_OBJECT                }                throw this.syntaxError(&quot;Expected name&quot;);            default:                this.checkLenient();                --this.pos;                if(this.isLiteral((char)c)) {                    return this.peeked = 14;    //  PEEKED_UNQUOTED_NAME                }                throw this.syntaxError(&quot;Expected name&quot;);            }        }        if(peekStack == 4) {    //  PEEKED_END_ARRAY            this.stack[this.stackSize - 1] = 5; //  PEEKED_TRUE            c = this.nextNonWhitespace(true);            switch(c) {            case 58:    //  冒号                break;            case 61:    //  逗号                this.checkLenient();                if((this.pos &lt; this.limit || this.fillBuffer(1)) &amp;&amp; this.buffer[this.pos] == 62) {                    ++this.pos;                }                break;            default:                throw this.syntaxError(&quot;Expected \&apos;:\&apos;&quot;);            }        } else if(peekStack == 6) { //  PEEKED_FALSE            if(this.lenient) {                this.consumeNonExecutePrefix();            }            this.stack[this.stackSize - 1] = 7; //  PEEKED_NULL        } else if(peekStack == 7) { //  PEEKED_NULL            c = this.nextNonWhitespace(false);            if(c == -1) {                return this.peeked = 17;    //  PEEKED_EOF            }            this.checkLenient();            --this.pos;        } else if(peekStack == 8) { //  PEEKED_SINGLE_QUOTED            throw new IllegalStateException(&quot;JsonReader is closed&quot;);        }    }    c = this.nextNonWhitespace(true);    switch(c) {    case 34:    //  双引号        if(this.stackSize == 1) {            this.checkLenient();        }        return this.peeked = 9; //  PEEKED_DOUBLE_QUOTED    case 39:    //  单引号        this.checkLenient();        return this.peeked = 8; //  PEEKED_SINGLE_QUOTED    case 91:    //  左方括号        return this.peeked = 3; //  PEEKED_BEGIN_ARRAY    case 93:    //  右方括号        if(peekStack == 1) {    //  PEEKED_BEGIN_OBJECT            return this.peeked = 4; //  PEEKED_END_ARRAY        }    case 44:    //  逗号    case 59:    //  分号        if(peekStack != 1 &amp;&amp; peekStack != 2) {  //  PEEKED_BEGIN_OBJECT &amp;&amp; PEEKED_END_OBJECT            throw this.syntaxError(&quot;Unexpected value&quot;);        }        this.checkLenient();        --this.pos;        return this.peeked = 7; //  PEEKED_NULL    case 123:   //  左大括号        return this.peeked = 1; //  PEEKED_BEGIN_OBJECT    default:        --this.pos;        if(this.stackSize == 1) {            this.checkLenient();        }        int result = this.peekKeyword();        if(result != 0) {            return result;        } else {            result = this.peekNumber();            if(result != 0) {                return result;            } else if(!this.isLiteral(this.buffer[this.pos])) {                throw this.syntaxError(&quot;Expected value&quot;);            } else {                this.checkLenient();                return this.peeked = 10;            }        }    }}</code></pre><p><code>doPeek()</code>分为两个阶段，首先分析栈顶元素，栈顶元素指示了当前的分析阶段，然后如果前面没返回的话则继续分析下一个字符</p><p><code>beginObject</code>会给栈顶赋值<code>PEEKED_BEGIN_ARRAY</code>，表示开始构造数组?</p><p><code>beginArray</code>会给栈顶赋值<code>PEEKED_BEGIN_OBJECT</code>，表示开始构造对象?</p><p><strong>流程比较难以理解，首先要了解<code>stack</code>的确切意思</strong></p><p>简单的字符串</p><p><img src="http://7xt3ho.com1.z0.glb.clouddn.com/json_1.jpg" alt=""></p><p>带数组的字符串</p><p><img src="http://7xt3ho.com1.z0.glb.clouddn.com/json_2.jpg" alt=""></p><h3 id="JsonWriter"><a href="#JsonWriter" class="headerlink" title="JsonWriter"></a>JsonWriter</h3><p><code>JsonWriter</code>就简单一些，主要是这些方法:</p><pre><code>public JsonWriter beginArray() throws IOException;public JsonWriter endArray() throws IOException;public JsonWriter beginObject() throws IOException;public JsonWriter endObject() throws IOException;public JsonWriter name(String name) throws IOException;public JsonWriter value(String value) throws IOException;</code></pre><h3 id="GsonBuilder"><a href="#GsonBuilder" class="headerlink" title="GsonBuilder"></a>GsonBuilder</h3><p><code>Gson</code>对象的构造器，可以自己进行配置，最终通过<code>create()</code>获得<code>Gson</code>对象</p><pre><code>public GsonBuilder setVersion(double ignoreVersionsAfter);</code></pre><p>忽略给定数字之后的版本号</p><pre><code>public GsonBuilder excludeFieldsWithModifiers(int... modifiers);</code></pre><p>忽略给定的限定符</p><pre><code>public GsonBuilder excludeFieldsWithoutExposeAnnotation();</code></pre><p>忽略不带<code>Expose</code>注解的域</p><pre><code>public GsonBuilder setFieldNamingPolicy(FieldNamingPolicy namingConvention);public GsonBuilder setFieldNamingStrategy(FieldNamingStrategy fieldNamingStrategy);</code></pre><p>设置命名策略</p><pre><code>public GsonBuilder setExclusionStrategies(ExclusionStrategy... strategies);</code></pre><p>设置排除策略</p><pre><code>public GsonBuilder addSerializationExclusionStrategy(ExclusionStrategy strategy);public GsonBuilder addDeserializationExclusionStrategy(ExclusionStrategy strategy);</code></pre><p>对序列化和反序列化分别设置排除策略</p><pre><code>public GsonBuilder registerTypeAdapter(Type type, Object typeAdapter);</code></pre><p>注册类型适配器，可能是<code>InstanceCreator</code>(这个东西在<code>Gson</code>构造函数中提供给各个<code>TypeAdapter</code>，具体干什么的不清楚)、<code>JsonSerializer</code>、<code>JsonDeserializer</code>、<code>TypeAdapter</code></p><h3 id="Excluder"><a href="#Excluder" class="headerlink" title="Excluder"></a>Excluder</h3><p>这个类实现了<code>TypeAdapterFactory</code>接口，可以做一些排除规则</p><p>可以设置版本号、限定符、是否处理内部类、要求暴露</p><p><code>Gson</code>的构造函数里设置了一个默认的<code>Excluder</code>，也可以在<code>GsonBuilder</code>中自己修改</p><pre><code>factories.add(new ReflectiveTypeAdapterFactory(this.constructorConstructor, fieldNamingPolicy, excluder));</code></pre><p>在构造函数中加入了<code>TypeAdapter</code>工厂列表</p><p>明显<code>ReflectiveTypeAdapterFactory</code>就是处理反射相关的东西</p><pre><code>ReflectiveTypeAdapterFactory.BoundField field = (ReflectiveTypeAdapterFactory.BoundField)this.boundFields.get(e);    if(field != null &amp;&amp; field.deserialized) {        field.read(in, instance);    } else {        in.skipValue();    }</code></pre><p>上面是<code>read()</code>中的一段，显然<code>skip</code>了一些不想要的域</p><p>也有个接口<code>ExclusionStrategy</code>，指定了需要跳过的域和类</p><pre><code>public interface ExclusionStrategy {    boolean shouldSkipField(FieldAttributes var1);    boolean shouldSkipClass(Class&lt;?&gt; var1);}</code></pre><p>构造的时候可以提供排除策略</p><pre><code>public GsonBuilder setExclusionStrategies(ExclusionStrategy... strategies);</code></pre><p>调用了下面这个函数</p><pre><code>public Excluder withExclusionStrategy(ExclusionStrategy exclusionStrategy, boolean serialization, boolean deserialization)</code></pre><h3 id="FieldNamingStrategy"><a href="#FieldNamingStrategy" class="headerlink" title="FieldNamingStrategy"></a>FieldNamingStrategy</h3><p>名称映射策略</p><pre><code>public interface FieldNamingStrategy {    String translateName(Field var1);}</code></pre><p>有一个实现的枚举<code>FieldNamingPolicy</code>，提供了五种：</p><ul><li><code>IDENTITY</code></li><li><code>UPPER_CAMEL_CASE</code></li><li><code>UPPER_CAMEL_CASE_WITH_SPACES</code></li><li><code>LOWER_CASE_WITH_UNDERSCORES</code></li><li><code>LOWER_CASE_WITH_DASHES</code></li></ul><p>也是在<code>ReflectiveTypeAdapterFactory</code>中被使用</p><pre><code>private String getFieldName(Field f) {    SerializedName serializedName = (SerializedName)f.getAnnotation(SerializedName.class);    return serializedName == null?this.fieldNamingPolicy.translateName(f):serializedName.value();}</code></pre><p>可以看到，如果没有给出序列化的名字，就使用命名策略来处理，否则使用我们给出的名字</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Gson是Google开发的Java API,用于转换Java对象和Json对象&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://lakeshire.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://lakeshire.github.io/tags/Android/"/>
    
      <category term="开源库" scheme="http://lakeshire.github.io/tags/%E5%BC%80%E6%BA%90%E5%BA%93/"/>
    
      <category term="Json" scheme="http://lakeshire.github.io/tags/Json/"/>
    
  </entry>
  
  <entry>
    <title>Java——Json&amp;Gson</title>
    <link href="http://lakeshire.github.io/2016/11/04//archivers/java-json/"/>
    <id>http://lakeshire.github.io/2016/11/04//archivers/java-json/</id>
    <published>2016-11-04T04:00:00.000Z</published>
    <updated>2017-11-28T03:17:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍Java中的Json相关类</p><a id="more"></a><h2 id="Java的Json包"><a href="#Java的Json包" class="headerlink" title="Java的Json包"></a>Java的Json包</h2><p>在<code>org.json</code>包中</p><p>最重要的是<code>JSONObject</code>和<code>JSONArray</code>两个结构，对应<code>JSON</code>对象和<code>JSON</code>数组</p><h3 id="JSONObject"><a href="#JSONObject" class="headerlink" title="JSONObject"></a>JSONObject</h3><pre><code>JSONObject json = new JSONObject(&quot;{&apos;name&apos; : &apos;Alice&apos;, &apos;age&apos; : 20}&quot;);String name = json.getString(&quot;name&quot;);  int age = json.getInt(&quot;age&quot;);  </code></pre><p>从<code>JSON</code>字符串获得<code>JSONObject</code>，从<code>JSON</code>对象中获得属性</p><pre><code>//  一个空的对象public JSONObject();//  传入键值对public JSONObject(Map copyFrom);//  传入JSON字符串public JSONObject(String json) throws JSONException;//  传入一个Tokenpublic JSONObject(JSONTokener readFrom) throws JSONException;//  应该是从一个已有的对象里取得对应的键值对来形成一个新对象public JSONObject(JSONObject copyFrom, String[] names) throws JSONException;</code></pre><p>一组构造函数 </p><h3 id="JSONArray"><a href="#JSONArray" class="headerlink" title="JSONArray"></a>JSONArray</h3><pre><code>JSONArray array = new JSONArray(&quot;[{&apos;name&apos; : &apos;Alice&apos;, &apos;age&apos; : 20}, {&apos;name&apos; : &apos;Eric&apos;, &apos;age&apos; : 15}]&quot;);  for (int i = 0; i &lt; array.length(); i++){      JSONObject json = array.getJSONObject(i).    String name = json.getString(&quot;name&quot;);      int age = json.getInt(&quot;age&quot;);  } </code></pre><p>从字符串获得<code>JSONArray</code>，遍历其中的<code>JSONObject</code></p><pre><code>public JSONArray() {public JSONArray(Collection copyFrom);public JSONArray(String json) throws JSONException;public JSONArray(Object array) throws JSONException;public JSONArray(JSONTokener readFrom) throws JSONException;</code></pre><p>也有一组不同的构造函数</p><p>可以嵌套使用，通过<code>getJSONArray()</code>获得数组，遍历数组获得<code>JSONObject</code></p><h3 id="JSONStringer"><a href="#JSONStringer" class="headerlink" title="JSONStringer"></a>JSONStringer</h3><p>用来快速构建<code>JSON</code>字符串</p><pre><code>JSONStringer stringer = new JSONStringer();  String str = stringer.object().key(&quot;name&quot;).value(&quot;Eric&quot;).key(&quot;age&quot;).value(20).endObject().toString();</code></pre><h3 id="JSONToken"><a href="#JSONToken" class="headerlink" title="JSONToken"></a>JSONToken</h3><p><code>JSONTokener</code>方法获得一个对象，根据括号类型或引号决定是什么(<code>JSONObject</code>或<code>JSONArray</code>或字符串)</p><pre><code>//  可以从文件中读取一个JSONObjectJSONObject obj = new JSONObject( new JSONTokener(java.io.Reader));//  可以从文件中读取一个JSONArrayJSONArray obj = new JSONArray( new JSONTokener(java.io.Reader)); </code></pre><h3 id="JSONWriter"><a href="#JSONWriter" class="headerlink" title="JSONWriter"></a>JSONWriter</h3><p>用来输出<code>JSON</code></p><pre><code>PrintWriter out = new PrintWriter(System.out);  new JSONWriter(out).object().key(&quot;name&quot;).value(&quot;Alice&quot;).endObject();  out.flush();  out.close();  </code></pre><h2 id="GSON"><a href="#GSON" class="headerlink" title="GSON"></a>GSON</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><pre><code>Gson gson = new Gson();//  基础类型int i = gson.fromJson(&quot;100&quot;, int.class);double d = gson.fromJson(&quot;99.99&quot;, double.class);boolean b = gson.fromJson(&quot;true&quot;, boolean.class);String s = gson.fromJson(&quot;Hello&quot;, String.class);</code></pre><p>定义一个类</p><pre><code>public class User {    public String name;    public int id;}</code></pre><p>解析</p><pre><code>Gson gson = new Gson();User user = gson.fromJson(&quot;{&apos;name&apos; : &apos;Alice&apos;, &apos;id&apos; : 1}&quot;, User.class);</code></pre><p>生成</p><pre><code>User user = new User;user.name = &apos;Eric&apos;;user.id = 1;Gson gson = new Gson();String string = gson.toJson(user);</code></pre><h4 id="SerializedName"><a href="#SerializedName" class="headerlink" title="SerializedName"></a>SerializedName</h4><p>后台开发经常会用到下划线命名变量，这时需要使用<code>@SerializedName</code>来标记一下对应关系</p><pre><code>{&quot;name&quot; : &quot;Alice&quot;, &quot;email_address&quot; : &quot;alice@example.com&quot;}</code></pre><p>这时的类应该是</p><pre><code>public class User {    public String name;    @SerializedName(&quot;email_address&quot;)    public String emailAddress;}</code></pre><p>另外可以提供备选名</p><pre><code>@SerializedName(&quot;email_address&quot;, alternate = {&quot;email&quot;})public String emailAddress;</code></pre><h4 id="对象数组"><a href="#对象数组" class="headerlink" title="对象数组"></a>对象数组</h4><pre><code>Gson gson = new Gson();String string = &quot;[&apos;Android&apos;, &apos;Java&apos;, &apos;PHP&apos;]&quot;;String[] langs = gson.fromJson(string, String[].class);</code></pre><p>因为泛型擦除机制，列表不能这样用，需要使用<code>TypeToken</code></p><pre><code>List&lt;String&gt; langs = gson.fromJson(string, new TypeToken&lt;List&lt;String&gt;&gt;(){}.getType());</code></pre><h4 id="引入泛型"><a href="#引入泛型" class="headerlink" title="引入泛型"></a>引入泛型</h4><p>泛型的引入可以减少无关的代码，很多时候后台返回的结果是这样的</p><pre><code>{&quot;code&quot; : &quot;0&quot;, &quot;message&quot; : &quot;success&quot;, &quot;data&quot; : {}}</code></pre><p><code>data</code>中的东西可能不一样，但不需要每个都定义一个类，定义泛型类就好了</p><pre><code>public class Result&lt;T&gt; {    public int code;    public String message;    public T data;}</code></pre><p>返回的东西是个<code>User</code>就写<code>Result&lt;User&gt;</code>，是个<code>List&lt;User&gt;</code>就写<code>Result&lt;List&lt;User&gt;&gt;</code></p><h3 id="自定义"><a href="#自定义" class="headerlink" title="自定义"></a>自定义</h3><h4 id="手动反序列化"><a href="#手动反序列化" class="headerlink" title="手动反序列化"></a>手动反序列化</h4><pre><code>String json = &quot;{&apos;name&apos; : &apos;Alice&apos;, &apos;age&apos; : 24}&quot;;User user = new User();JsonReader reader = new JsonReader(new StringReader(json));reader.beginObject(); while (reader.hasNext()) {    String s = reader.nextName();    switch (s) {        case &quot;name&quot;:            user.name = reader.nextString();            break;        case &quot;age&quot;:            user.age = reader.nextInt();            break;    }}reader.endObject();</code></pre><p>自动方式最后也是通过<code>JsonReader</code>来实现的</p><h4 id="手动序列化"><a href="#手动序列化" class="headerlink" title="手动序列化"></a>手动序列化</h4><pre><code>JsonWriter writer = new JsonWriter(new OutputStreamWriter(System.out));writer.beginObject().name(&quot;name&quot;).value(&quot;Alice&quot;).name(&quot;age&quot;).value(24).endObject();writer.flush();</code></pre><h4 id="GsonBuilder"><a href="#GsonBuilder" class="headerlink" title="GsonBuilder"></a>GsonBuilder</h4><p>可以用来自定义<code>Gson</code></p><pre><code>Gson gson = new GsonBuilder().create();</code></pre><p><code>Gson</code>默认不输出<code>null</code>值，可以用<code>serializeNulls()</code>来配置</p><p>通过<code>setDateFormat(&quot;yyyy-MM-dd&quot;)</code>格式化日期</p><p><code>disableInnerClassSerialization()</code>禁止序列化内部类</p><h3 id="字段过滤"><a href="#字段过滤" class="headerlink" title="字段过滤"></a>字段过滤</h3><p>字段过滤是比较常用的技巧，在处理业务逻辑时可能需要在设置的<code>POJO</code>中加入一些字段，但显然在序列化的过程中是不需要的，并且如果序列化还可能带来一个问题就是循环引用</p><h4 id="Expose注解"><a href="#Expose注解" class="headerlink" title="@Expose注解"></a>@Expose注解</h4><p>这个注解必须和<code>GsonBuilder</code>结合使用，需要导出的加该注解，不需要的不加</p><pre><code>public class Category {    @Expose     public int id;    @Expose     public String name;    @Expose     public List&lt;Category&gt; children;    public Category parent; }</code></pre><p>序列化的方法也要改</p><pre><code>Gson gson = new GsonBuilder().excludeFieldsWithoutExposeAnnotation().create();</code></pre><h4 id="基于版本"><a href="#基于版本" class="headerlink" title="基于版本"></a>基于版本</h4><p>使用<code>@Since</code>和<code>@Until</code>注解导出指定版本的字段，与<code>setVersion()</code>一起使用</p><pre><code>class SinceUntilSample {    //  版本不小于4时导出    @Since(4)    public String since;    //  版本不大于5时导出    @Until(5)    public String until;}Gson gson = new GsonBuilder().setVersion(version).create();</code></pre><h4 id="基于访问修饰符"><a href="#基于访问修饰符" class="headerlink" title="基于访问修饰符"></a>基于访问修饰符</h4><pre><code>Gson gson = new GsonBuilder().excludeFieldsWithModifiers(Modifier.FINAL, Modifier.STATIC, Modifier.PRIVATE).create();</code></pre><h4 id="基于策略"><a href="#基于策略" class="headerlink" title="基于策略"></a>基于策略</h4><pre><code>Gson gson = new GsonBuilder().addSerializationExclusionStrategy(new ExclusionStrategy() {    @Override    public boolean shouldSkipField(FieldAttributes f) {        if (&quot;finalField&quot;.equals(f.getName())) {            return true;        }        Expose expose = f.getAnnotation(Expose.class);         if (expose != null &amp;&amp; expose.deserialize() == false) {     return true;        }        return false;    }    @Override    public boolean shouldSkipClass(Class&lt;?&gt; clazz) {        return (clazz == int.class || clazz == Integer.class);    }}).create();</code></pre><h3 id="终极：TypeAdapter"><a href="#终极：TypeAdapter" class="headerlink" title="终极：TypeAdapter"></a>终极：TypeAdapter</h3><pre><code>public abstract class TypeAdapter&lt;T&gt; {    public abstract void write(JsonWriter out, T value) throws IOException;    public abstract T read(JsonReader in) throws IOException;    ......}</code></pre><p>这个类接管某种类型的序列化和反序列化</p><pre><code>public class UserTypeAdapter extends TypeAdapter&lt;User&gt; {    @Override    public void write(JsonWriter out, User value) throws IOException {        out.beginObject();        out.name(&quot;name&quot;).value(value.name);        out.name(&quot;age&quot;).value(value.age);        out.endObject();    }    @Override    public User read(JsonReader in) throws IOException {        User user = new User();        in.beginObject();        while (in.hasNext()) {            switch (in.nextName()) {                case &quot;name&quot;:                    user.name = in.nextString();                    break;                case &quot;age&quot;:                    user.age = in.nextInt();                    break;            }        }        in.endObject();        return user;    }}Gson gson = new GsonBuilder().registerTypeAdapter(User.class, new UserTypeAdapter()).create();</code></pre><p>这个类的处理优先级最高，会覆盖之前的所有注解</p><pre><code>class JsonDeserializer&lt;T&gt;() {    @Override    public T deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException;}class JsonSerializer&lt;T&gt;() {    @Override    public JsonElement serialize(T src, Type typeOfSrc, JsonSerializationContext context);};</code></pre><p>如果只想接管其中一个过程，则只需要实现上面的一个</p><pre><code>Gson gson = new GsonBuilder().registerTypeAdapterFactory(new TypeAdapterFactory() {    @Override    public &lt;T&gt; TypeAdapter&lt;T&gt; create(Gson gson, TypeToken&lt;T&gt; type) {        ......    }}).create();</code></pre><p>对应的工厂，获取对应<code>type</code>的<code>TypeAdapter</code></p><pre><code>@JsonAdapter(UserTypeAdapter.class)public class User {    ......}</code></pre><p>使用<code>@JsonAdapter</code>注解可以省去注册的代码</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍Java中的Json相关类&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://lakeshire.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://lakeshire.github.io/tags/Android/"/>
    
      <category term="Json" scheme="http://lakeshire.github.io/tags/Json/"/>
    
      <category term="Java" scheme="http://lakeshire.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>ButterKnife框架解析</title>
    <link href="http://lakeshire.github.io/2016/11/02//archivers/java-butterknife/"/>
    <id>http://lakeshire.github.io/2016/11/02//archivers/java-butterknife/</id>
    <published>2016-11-02T04:00:00.000Z</published>
    <updated>2017-11-28T03:04:47.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>ButterKnife</code>是使用注解的代码生成框架，在编译期生成代码，没有使用反射，不会造成运行时的性能问题</p><a id="more"></a><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>使用<code>ButterKnife</code>的例子</p><pre><code>class ExampleActivity extends Activity {    @Bind(R.id.user)     EditText username;    @Bind(R.id.pass)     EditText password;    @BindString(R.string.login_error)     String loginErrorMessage;    @OnClick(R.id.submit)     void submit() {        ...    }    @Override     public void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.simple_activity);        ButterKnife.bind(this);        ...    }}</code></pre><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p>最基本的<code>Bind.java</code></p><pre><code>@Retention(CLASS) @Target(FIELD)public @interface Bind {    @IdRes int value();}</code></pre><p>定义的<code>Bind</code>注解，存在于编译期，目标是<code>FIELD</code>，提供一个资源ID</p><h2 id="处理"><a href="#处理" class="headerlink" title="处理"></a>处理</h2><p>处理过程是在<code>ButterKnifeProcessor.java</code>中</p><p><code>AbstractProcessor</code>是<code>Processor</code>的子类，就是注解处理器</p><pre><code>public final class ButterKnifeProcessor extends AbstractProcessor {    @Override     public boolean process(Set&lt;? extends TypeElement&gt; elements, RoundEnvironment env) {        Map&lt;TypeElement, BindingClass&gt; targetClassMap = findAndParseTargets(env);        for (Map.Entry&lt;TypeElement, BindingClass&gt; entry : targetClassMap.entrySet()) {            TypeElement typeElement = entry.getKey();            BindingClass bindingClass = entry.getValue();            try {                JavaFileObject jfo = filer.createSourceFile(bindingClass.getFqcn(), typeElement);                Writer writer = jfo.openWriter();                writer.write(bindingClass.brewJava());                writer.flush();                writer.close();            } catch (IOException e) {                error(typeElement, &quot;Unable to write view binder for type %s: %s&quot;, typeElement, e.getMessage());            }        }        return true;      }}</code></pre><p>关键方法是<code>process()</code></p><p>首先<code>findAndParseTargets()</code>解析注解，保存到一个表里面，然后遍历表，自动生成类似<code>ExampleActivity$$ViewBinder</code>这样的类文件</p><pre><code>private Map&lt;TypeElement, BindingClass&gt; findAndParseTargets(RoundEnvironment env) {    Map&lt;TypeElement, BindingClass&gt; targetClassMap = new LinkedHashMap&lt;TypeElement, BindingClass&gt;();    Set&lt;String&gt; erasedTargetNames = new LinkedHashSet&lt;String&gt;();    for (Element element : env.getElementsAnnotatedWith(Bind.class)) {        try {            parseBind(element, targetClassMap, erasedTargetNames);        } catch (Exception e) {            logParsingError(element, Bind.class, e);        }    }    ......}</code></pre><p>挨个处理每个注解，在<code>parseBind()</code>中对<code>Bind</code>这个注解进行处理</p><pre><code>private void parseBind(Element element, Map&lt;TypeElement, BindingClass&gt; targetClassMap, Set&lt;String&gt; erasedTargetNames) {    //  判断一下是否可以处理    if (isInaccessibleViaGeneratedCode(Bind.class, &quot;fields&quot;, element) || isBindingInWrongPackage(Bind.class, element)) {        return;    }    TypeMirror elementType = element.asType();    if (elementType.getKind() == TypeKind.ARRAY) {        parseBindMany(element, targetClassMap, erasedTargetNames);    } else if (LIST_TYPE.equals(doubleErasure(elementType))) {        parseBindMany(element, targetClassMap, erasedTargetNames);    } else if (isSubtypeOfType(elementType, ITERABLE_TYPE)) {        error(element, &quot;@%s must be a List or array. (%s.%s)&quot;, Bind.class.getSimpleName(), ((TypeElement) element.getEnclosingElement()).getQualifiedName(), element.getSimpleName());    } else {        parseBindOne(element, targetClassMap, erasedTargetNames);    }}</code></pre><p>一般也就对应一个，进入<code>parseBindOne()</code></p><pre><code>private void parseBindOne(Element element, Map&lt;TypeElement, BindingClass&gt; targetClassMap, Set&lt;String&gt; erasedTargetNames) {    boolean hasError = false;    TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();    //  验证是不是View的子类    TypeMirror elementType = element.asType();    if (elementType.getKind() == TypeKind.TYPEVAR) {        TypeVariable typeVariable = (TypeVariable) elementType;        elementType = typeVariable.getUpperBound();    }    if (!isSubtypeOfType(elementType, VIEW_TYPE) &amp;&amp; !isInterface(elementType)) {        error(element, &quot;@%s fields must extend from View or be an interface. (%s.%s)&quot;, Bind.class.getSimpleName(), enclosingElement.getQualifiedName(), element.getSimpleName());        hasError = true;    }    // 获得id，明显资源id只能是一个    int[] ids = element.getAnnotation(Bind.class).value();    if (ids.length != 1) {        error(element, &quot;@%s for a view must only specify one ID. Found: %s. (%s.%s)&quot;, Bind.class.getSimpleName(), Arrays.toString(ids), enclosingElement.getQualifiedName(), element.getSimpleName());        hasError = true;    }    if (hasError) {        return;    }    int id = ids[0];    //  获取生成的绑定类    BindingClass bindingClass = targetClassMap.get(enclosingElement);    if (bindingClass != null) {        //  获取对应id的元素，看有没有，有的话就不用重复添加        ViewBindings viewBindings = bindingClass.getViewBinding(id);        if (viewBindings != null) {            Iterator&lt;FieldViewBinding&gt; iterator = viewBindings.getFieldBindings().iterator();            if (iterator.hasNext()) {                FieldViewBinding existingBinding = iterator.next();                error(element, &quot;Attempt to use @%s for an already bound ID %d on &apos;%s&apos;. (%s.%s)&quot;,                Bind.class.getSimpleName(), id, existingBinding.getName(),                enclosingElement.getQualifiedName(), element.getSimpleName());                return;            }        }    } else {        //  获取或创建绑定类        bindingClass = getOrCreateTargetClass(targetClassMap, enclosingElement);    }    //  根据注解信息来生成注入关系    String name = element.getSimpleName().toString();    String type = elementType.toString();    boolean required = isRequiredBinding(element);    FieldViewBinding binding = new FieldViewBinding(name, type, required);    bindingClass.addField(id, binding);    erasedTargetNames.add(enclosingElement.toString());}</code></pre><p>解析注释时是往对应的绑定类中添加注入关系，绑定类通过<code>getOrCreateTargetClass()</code>获得</p><pre><code>private BindingClass getOrCreateTargetClass(Map&lt;TypeElement, BindingClass&gt; targetClassMap, TypeElement enclosingElement) {    BindingClass bindingClass = targetClassMap.get(enclosingElement);    if (bindingClass == null) {        //  不存在的话生成，这里就是添加一个$$ViewBinder的地方        String targetType = enclosingElement.getQualifiedName().toString();        String classPackage = getPackageName(enclosingElement);        String className = getClassName(enclosingElement, classPackage) + SUFFIX;        bindingClass = new BindingClass(classPackage, className, targetType);        targetClassMap.put(enclosingElement, bindingClass);    }    return bindingClass;}</code></pre><p>结果就是获得了一个<code>ViewBinder</code>类，并且获得了该类中需要包含的绑定关系</p><p>这个方法里提供了对特定注释的支持</p><pre><code>@Override public Set&lt;String&gt; getSupportedAnnotationTypes() {    Set&lt;String&gt; types = new LinkedHashSet&lt;String&gt;();    types.add(Bind.class.getCanonicalName());    for (Class&lt;? extends Annotation&gt; listener : LISTENERS) {        types.add(listener.getCanonicalName());    }    types.add(BindBool.class.getCanonicalName());    types.add(BindColor.class.getCanonicalName());    types.add(BindDimen.class.getCanonicalName());    types.add(BindDrawable.class.getCanonicalName());    types.add(BindInt.class.getCanonicalName());    types.add(BindString.class.getCanonicalName());    return types;}</code></pre><h2 id="生成代码"><a href="#生成代码" class="headerlink" title="生成代码"></a>生成代码</h2><p><code>process()</code>里面的这句代码是生成代码的</p><pre><code>writer.write(bindingClass.brewJava());</code></pre><p>那么看一下<code>brewJava()</code></p><pre><code>String brewJava() {    StringBuilder builder = new StringBuilder();    builder.append(&quot;// Generated code from Butter Knife. Do not modify!\n&quot;);    builder.append(&quot;package &quot;).append(classPackage).append(&quot;;\n\n&quot;);    if (!resourceBindings.isEmpty()) {        builder.append(&quot;import android.content.res.Resources;\n&quot;);    }    if (!viewIdMap.isEmpty() || !collectionBindings.isEmpty()) {        builder.append(&quot;import android.view.View;\n&quot;);    }    builder.append(&quot;import butterknife.ButterKnife.Finder;\n&quot;);    if (parentViewBinder == null) {        builder.append(&quot;import butterknife.ButterKnife.ViewBinder;\n&quot;);    }    builder.append(&apos;\n&apos;);    builder.append(&quot;public class &quot;).append(className);    builder.append(&quot;&lt;T extends &quot;).append(targetClass).append(&quot;&gt;&quot;);    if (parentViewBinder != null) {        builder.append(&quot; extends&quot;).append(parentViewBinder).append(&quot;&lt;T&gt;&quot;);    } else {        builder.append(&quot; implements ViewBinder&lt;T&gt;&quot;);    }    builder.append(&quot; {\n&quot;);    emitBindMethod(builder);    builder.append(&apos;\n&apos;);    emitUnbindMethod(builder);    builder.append(&quot;}\n&quot;);    return builder.toString();}</code></pre><p>可以看到生成了代码注释、包名、导包、生成类这些代码</p><p>两个花括号之间还通过<code>emitBindMethod()</code>和<code>emitUnbindMethod()</code>方法添加了绑定和解绑代码</p><p>下面是<code>View</code>绑定的细节生成代码</p><pre><code>private void emitViewBindings(StringBuilder builder, ViewBindings bindings) {    builder.append(&quot;    view = &quot;);    List&lt;ViewBinding&gt; requiredViewBindings = bindings.getRequiredBindings();    if (requiredViewBindings.isEmpty()) {      builder.append(&quot;finder.findOptionalView(source, &quot;).append(bindings.getId()).append(&quot;, null);\n&quot;);    } else {      if (bindings.getId() == View.NO_ID) {        builder.append(&quot;target;\n&quot;);      } else {        builder.append(&quot;finder.findRequiredView(source, &quot;).append(bindings.getId()).append(&quot;, \&quot;&quot;);        emitHumanDescription(builder, requiredViewBindings);        builder.append(&quot;\&quot;);\n&quot;);      }    }    emitFieldBindings(builder, bindings);    emitMethodBindings(builder, bindings);}</code></pre><blockquote><p>我看的这个版本是拼接字符串，好像还有的版本是用<code>JavaPoet</code>生成，更加直观</p></blockquote><p>最后生成的代码是类似这样的</p><pre><code>@Overridepublic void bind(final Finder finder, final T target, Object source) {    super.bind(finder, target, source);    Unbinder unbinder = new Unbinder(target);    View view;    view = finder.findRequiredView(source, 2130968576, &quot;field &apos;title&apos;&quot;);    target.title = finder.castView(view, 2130968576, &quot;field &apos;title&apos;&quot;);    ......    target.unbinder = unbinder;}</code></pre><h2 id="APT"><a href="#APT" class="headerlink" title="APT"></a>APT</h2><p>由于<code>Butterknife</code>用到了注解处理器，所以，比起一般的框架，配置稍微多了些</p><pre><code>buildscript {    repositories {        mavenCentral()    }    dependencies {        classpath &apos;com.android.tools.build:gradle:1.3.1&apos;        classpath &apos;com.neenbedankt.gradle.plugins:android-apt:1.8&apos;    }}apply plugin: &apos;com.neenbedankt.android-apt&apos;dependencies {    compile &apos;com.jakewharton:butterknife:8.1.0&apos;    apt &apos;com.jakewharton:butterknife-compiler:8.1.0&apos;}</code></pre><p>可以看到用到了<code>APT</code>插件，它是一个命令行工具，它对源代码文件进行检测找出其中的注解后，使用注解处理器来处理，而注解处理器使用了一套反射API</p><p>首先，<code>APT</code>运行注解处理器，根据提供的源文件中的注解生成源代码文件和其它的文件，接着<code>APT</code>将生成的源代码文件和提供的源文件进行编译生成类文件</p><p><code>APT</code>就像一个在编译时处理注解的<code>javac</code>，实际上，<code>APT</code>在<code>Java 8</code>中已经被移除，它的功能已经完全集成到<code>javac</code>编译器中去了</p><h3 id="APT工作过程"><a href="#APT工作过程" class="headerlink" title="APT工作过程"></a>APT工作过程</h3><p>从整个过程来讲，首先<code>APT</code>检测在源代码文件中哪些注解存在。然后APT将查找我们编写的注解处理器工厂类，并且要求工厂类提供注解处理器以处理源文件中所涉及的注解。接下来，一个合适的注解处理器将被执行，如果在处理器生成源代码文件时，该文件中含有注解，则<code>APT</code>将重复上面的过程直到没有新文件生成</p><h3 id="编写注解处理器"><a href="#编写注解处理器" class="headerlink" title="编写注解处理器"></a>编写注解处理器</h3><p>处理器需要实现<code>AnnotationProcessor</code>接口，这个接口有一个名为<code>process()</code>的方法，该方法是在<code>APT</code>调用处理器时将被用到的</p><p>一个处理器实例被其相应的工厂返回，此工厂为<code>AnnotationProcessorFactory</code>接口的实现。<code>APT</code>将调用工厂类的<code>getProcessorFor()</code>方法来获得处理器。在调用过程中，<code>APT</code>将提供给工厂类一个<code>AnnotationProcessorEnvironment</code> 类型的环境类对象，在这个环境对象中，将找到其执行所需要的每件东西，包括对所操作的程序结构的参考，与<code>APT</code>通讯并合作一同完成新文件的建立和警告/错误信息的传输</p><p>提供工厂类有两个方式：通过<code>APT</code>的<code>-factory</code>命令行参数提供，或者让工厂类在<code>APT</code>的发现过程中被自动定位。前者对于一个已知的工厂来讲是一种主动而又简单的方式；而后者则是需要在<code>jar</code>文件的<code>META-INF/services</code>目录中提供一个特定的发现路径：在包含工厂类的<code>jar</code>文件中作以下的操作：在<code>META-INF/services</code>目录中建立一个名为<code>com.sun.mirror.apt.AnnotationProcessorFactory</code>的UTF-8编码文件，在文件中写入所有要使用到的工厂类全名，每个类为一个单独行</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;ButterKnife&lt;/code&gt;是使用注解的代码生成框架，在编译期生成代码，没有使用反射，不会造成运行时的性能问题&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://lakeshire.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://lakeshire.github.io/tags/Android/"/>
    
      <category term="ButterKnife" scheme="http://lakeshire.github.io/tags/ButterKnife/"/>
    
      <category term="开源库" scheme="http://lakeshire.github.io/tags/%E5%BC%80%E6%BA%90%E5%BA%93/"/>
    
  </entry>
  
</feed>
