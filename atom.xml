<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>湖畔镇</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://lakeshire.github.io/"/>
  <updated>2017-12-26T03:07:01.000Z</updated>
  <id>http://lakeshire.github.io/</id>
  
  <author>
    <name>刘晗</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android插件化</title>
    <link href="http://lakeshire.github.io/2017/12/25//archivers/android-plugin/"/>
    <id>http://lakeshire.github.io/2017/12/25//archivers/android-plugin/</id>
    <published>2017-12-25T09:00:00.000Z</published>
    <updated>2017-12-26T03:07:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>现在的应用功能越来越多，代码膨胀，应用体积太大，为解耦模块方便开发，插件化有其必要性</p><a id="more"></a><h1 id="插件化"><a href="#插件化" class="headerlink" title="插件化"></a>插件化</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>应用功能越来越多，代码膨胀，触及65535方法数的上限，应用体积太大</p><p>实时更新独立模块的需求越来越强</p><p>功能模块的解耦，方便维护</p><p>H5和Hybrid可以解决一些问题，但是体验比不上Native代码，因此插件化有其必要性</p><h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><p>代理可以用来进行方法增强或拦截</p><h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IAct</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">act</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Agent</span> <span class="keyword">implements</span> <span class="title">IAct</span> </span>&#123;</span><br><span class="line">    IAct base;</span><br><span class="line">  </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Agent</span>(<span class="title">IActor</span> <span class="title">agent</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.base = agent;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">act</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 干点啥</span></span><br><span class="line">        base.act();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Actor</span> <span class="keyword">implements</span> <span class="title">IAct</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">book</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>传统的静态代理模式需要为每一个需要代理的类写一个代理类，比较麻烦，为了更优雅地实现代理模式，JDK提供了动态代理方式，可以简单理解为JVM可以在运行时帮我们动态生成一系列的代理类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IAct impl = <span class="keyword">new</span> Actor();</span><br><span class="line">IAct proxy = (IAct) Proxy.newProxyInstance(IAct.class.getClassLoader(), <span class="keyword">new</span> Class[] &#123; IAct.class &#125;, <span class="keyword">new</span> ActHandler(impl));</span><br></pre></td></tr></table></figure><p>动态代理主要处理<code>InvocationHandler</code>和<code>Proxy</code>类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ActHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    IAct base;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ActHandler</span><span class="params">(ActImpl impl)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.base = impl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">// 干点啥</span></span><br><span class="line">        <span class="keyword">return</span> method.invoke(base);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Hook"><a href="#Hook" class="headerlink" title="Hook"></a>Hook</h2><p>通过创建代理对象替代原始对象，进行功能增强，称为Hook，以<code>startActivity()</code>为例</p><p>找到被Hook的对象，称为Hook点，静态变量和单例比较适合，因为相对不容易变化</p><p><code>Context.startActivity()</code>实际调用了<code>ActivityThread</code>类的<code>mInstrumentation</code>的<code>execStartActivity()</code> 方法，<code>ActivityThread</code>是主线程，一个程序只有一个，因此是个良好的Hook点</p><p>把<code>mInstrumentation</code>替换成代理对象，首先需要获得主线程对象，可以通过<code>ActivityThread.currentActivityThread()</code>获得，<code>ActivityThread</code>是一个隐藏类，需要反射获取</p><p><em>HookInstrumentation.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HookInstrumentation</span> <span class="keyword">extends</span> <span class="title">Instrumentation</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Instrumentation mBase;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HookInstrumentation</span><span class="params">(Instrumentation base)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mBase = base;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> ActivityResult <span class="title">execStartActivity</span><span class="params">(Context who, IBinder contextThread, IBinder token, Activity target, Intent intent, <span class="keyword">int</span> requestCode, Bundle options)</span> </span>&#123;</span><br><span class="line">        intent.setComponent(<span class="keyword">new</span> ComponentName(MyApplication.APP, HookActivity.class));</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Method method = Instrumentation.class.getDeclaredMethod(<span class="string">"execStartActivity"</span>, Context.class, IBinder.class, IBinder.class, Activity.class, Intent.class, <span class="keyword">int</span>.class, Bundle.class);</span><br><span class="line">            method.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">return</span> (ActivityResult) method.invoke(mBase, who, contextThread, token, target, intent, requestCode, options);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们加了一句打印，并把目标换成了<code>HookActivity</code>，反射获取<code>Instrumentation</code>类的<code>execStartActivity()</code>方法并调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   Class&lt;?&gt; clazz = Class.forName(<span class="string">"android.app.ActivityThread"</span>);</span><br><span class="line">   Method method = clazz.getDeclaredMethod(<span class="string">"currentActivityThread"</span>);</span><br><span class="line">   method.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">   Object currentActivityThread = method.invoke(<span class="keyword">null</span>);</span><br><span class="line">   Field instrumentationField = currentActivityThread.getClass().getDeclaredField(<span class="string">"mInstrumentation"</span>);</span><br><span class="line">   instrumentationField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">   Instrumentation instrumentation = (Instrumentation) instrumentationField.get(currentActivityThread);</span><br><span class="line">   HookInstrumentation hookInstrumentation = <span class="keyword">new</span> HookInstrumentation(instrumentation);</span><br><span class="line">   instrumentationField.set(currentActivityThread, hookInstrumentation);</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">   e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">   e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">   e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">   e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">   e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获得<code>ActivityThread</code>类，找到<code>currentActivityThread()</code>方法，调用方法获得<code>ActivityThread</code>对象，然后找到<code>mInstrumentation</code>字段，获取对象，用代理对象替代并设置进去，就完成了Hook</p><h2 id="Binder-Hook"><a href="#Binder-Hook" class="headerlink" title="Binder Hook"></a>Binder Hook</h2><p>Hook系统服务的机制称之为Binder Hook，因为本质上这些服务提供者都是存在于系统各个进程的Binder对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取原始的IBinder对象</span></span><br><span class="line">IBinder b = ServiceManager.getService(<span class="string">"activity"</span>);</span><br><span class="line"><span class="comment">// 转换为Service</span></span><br><span class="line">IActivityManager in = asInterface(b);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> android.content.<span class="function">IClipboard <span class="title">asInterface</span><span class="params">(android.os.IBinder obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((obj == <span class="keyword">null</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);</span><br><span class="line">    <span class="keyword">if</span> (((iin != <span class="keyword">null</span>) &amp;&amp; (iin <span class="keyword">instanceof</span> android.content.IClipboard))) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((android.content.IClipboard) iin);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> android.content.IClipboard.Stub.Proxy(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以通过修改<code>queryLocalInterface()</code>来替换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IBinder <span class="title">getService</span><span class="params">(String name)</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">try</span> &#123;        </span><br><span class="line">        IBinder service = sCache.get(name);        </span><br><span class="line">        <span class="keyword">if</span> (service != <span class="keyword">null</span>) &#123;            </span><br><span class="line">            <span class="keyword">return</span> service;        </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;            </span><br><span class="line">            <span class="keyword">return</span> getIServiceManager().getService(name);        </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;        </span><br><span class="line">        Log.e(TAG, <span class="string">"error in getService"</span>, e);    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinderHookHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object mBase;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BinderHookHandler</span><span class="params">(IBinder base, Class&lt;?&gt; stubClass)</span> </span>&#123;</span><br><span class="line">        Method method = stubClass.getDeclaredMethod(<span class="string">"asInterface"</span>, IBinder.class);</span><br><span class="line">        <span class="keyword">this</span>.mBase = method.invoke(<span class="keyword">null</span>, base);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (method.getName().equals(<span class="string">"getPrimaryClip"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> ClipData.newPlainText(<span class="keyword">null</span>,<span class="string">"你被黑了"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.getName().equals(<span class="string">"hasPrimaryClip"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> method.invoke(mBase, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>剪贴板接口<code>IClipboard</code>的动态代理，替换了<code>getPrimaryClip()</code>和<code>hasPrimaryClip()</code>两个方法，构造方法中调用<code>Clipboard$Stub</code>的<code>asInterface()</code>方法，把传入的<code>IBinder</code>转为<code>IClipboard</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinderProxyHookHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt; mIInterface;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt; mStub;</span><br><span class="line">    <span class="keyword">private</span> IBinder mBase;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BinderProxyHookHandler</span><span class="params">(IBinder base)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mBase = base;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.mStub = Class.forName(<span class="string">"android.content.IClipboard$Stub"</span>);</span><br><span class="line">            <span class="keyword">this</span>.mIInterface = Class.forName(<span class="string">"android.content.IClipboard"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (method.getName().equals(<span class="string">"queryLocalInterface"</span>)) &#123;</span><br><span class="line">            <span class="comment">// 第二个参数表示代理类需要实现的接口</span></span><br><span class="line">            <span class="keyword">return</span> Proxy.newProxyInstance(proxy.getClass().getClassLoader(), <span class="keyword">new</span> Class[]&#123;IBinder.class, IInterface.class, <span class="keyword">this</span>.mIInterface&#125;, <span class="keyword">new</span> BinderHookHandler(mBase, mStub));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> method.invoke(mBase, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代理替换<code>IBinder</code>，修改其<code>queryLocalInterface()</code>方法，使其返回Hook后的剪贴板管理器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获得ServiceManager类 从中获得getService方法</span></span><br><span class="line">Class&lt;?&gt; serviceManager = Class.forName(<span class="string">"android.os.ServiceManager"</span>);</span><br><span class="line">Method getService = serviceManager.getDeclaredMethod(<span class="string">"getService"</span>, String.class);</span><br><span class="line">   </span><br><span class="line"><span class="comment">// 调用getService方法 获得剪贴板服务的IBinder Hook之改写其queryLocalInterface()方法 使其返回一个实际被重写的剪贴板服务</span></span><br><span class="line">IBinder rawBinder = (IBinder) getService.invoke(<span class="keyword">null</span>, <span class="string">"clipboard"</span>);</span><br><span class="line"> IBinder hookBinder = (IBinder) Proxy.newProxyInstance(serviceManager.getClassLoader(), <span class="keyword">new</span> Class[] &#123; IBinder.class &#125;, <span class="keyword">new</span> BinderProxyHookHandler(rawBinder));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得sCache字段 往里面填入Hook过的剪贴板IBinder</span></span><br><span class="line"> Field cacheField = serviceManager.getDeclaredField(<span class="string">"sCache"</span>);</span><br><span class="line"> cacheField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"> Map&lt;String, IBinder&gt; cache = (Map&lt;String, IBinder&gt;) cacheField.get(<span class="keyword">null</span>);</span><br><span class="line"> cache.put(<span class="string">"clipboard"</span>, hookBinder);</span><br></pre></td></tr></table></figure><h3 id="AMS"><a href="#AMS" class="headerlink" title="AMS"></a>AMS</h3><p><code>ActivityManagerNative</code>实际上是<code>ActivityManagerService</code>这个远程对象的Binder代理对象，因为比较常用，所以有一个<code>gDefault</code>的全局变量保存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获得ActivityManagerNative 获得其gDefault字段</span></span><br><span class="line">Class&lt;?&gt; activityManagerNative = Class.forName(<span class="string">"android.app.ActivityManagerNative"</span>);</span><br><span class="line"> Field gDefaultField = activityManagerNative.getDeclaredField(<span class="string">"gDefault"</span>);</span><br><span class="line"> gDefaultField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"> Object gDefault = gDefaultField.get(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// gDefault是一个Sigleton 获得其mInstance字段</span></span><br><span class="line"> Class&lt;?&gt; singleton = Class.forName(<span class="string">"android.util.Singleton"</span>);</span><br><span class="line"> Field mInstanceField = singleton.getDeclaredField(<span class="string">"mInstance"</span>);</span><br><span class="line"> mInstanceField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得ActivityManagerProxy</span></span><br><span class="line"><span class="comment">// 代理Hook掉并设置回去</span></span><br><span class="line"> Object rawActivityManager = mInstanceField.get(gDefault);</span><br><span class="line"> Class&lt;?&gt; iActivityManagerInterface = Class.forName(<span class="string">"android.app.IActivityManager"</span>);</span><br><span class="line"> Object proxy = Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(), <span class="keyword">new</span> Class[]&#123; iActivityManagerInterface &#125;, <span class="keyword">new</span> ActivityManagerHandler(rawActivityManager));</span><br><span class="line"> mInstanceField.set(gDefault, proxy);</span><br></pre></td></tr></table></figure><h3 id="PMS"><a href="#PMS" class="headerlink" title="PMS"></a>PMS</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> PackageManager <span class="title">getPackageManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mPackageManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> mPackageManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    IPackageManager pm = ActivityThread.getPackageManager();</span><br><span class="line">    <span class="keyword">if</span> (pm != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (mPackageManager = <span class="keyword">new</span> ApplicationPackageManager(<span class="keyword">this</span>, pm));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见由<code>Activity.getPackageManager()</code>获得，并经由<code>ApplicationPackagemanager</code> 包装</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IPackageManager <span class="title">getPackageManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sPackageManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> sPackageManager;</span><br><span class="line">    &#125;</span><br><span class="line">    IBinder b = ServiceManager.getService(<span class="string">"package"</span>);</span><br><span class="line">    sPackageManager = IPackageManager.Stub.asInterface(b);</span><br><span class="line">    <span class="keyword">return</span> sPackageManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见可以Hook掉这个静态对象<code>sPackageManager</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; activityThreadClass = Class.forName(<span class="string">"android.app.ActivityThread"</span>);</span><br><span class="line">Method currentActivityThreadMethod = activityThreadClass.getDeclaredMethod(<span class="string">"currentActivityThread"</span>);</span><br><span class="line">Object currentActivityThread = currentActivityThreadMethod.invoke(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">Field sPackageManagerField = activityThreadClass.getDeclaredField(<span class="string">"sPackageManager"</span>);</span><br><span class="line">sPackageManagerField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">Object sPackageManager = sPackageManagerField.get(currentActivityThread);</span><br><span class="line"></span><br><span class="line">Class&lt;?&gt; iPackageManagerInterface = Class.forName(<span class="string">"android.content.pm.IPackageManager"</span>);</span><br><span class="line">Object proxy = Proxy.newProxyInstance(iPackageManagerInterface.getClassLoader(), <span class="keyword">new</span> Class[] &#123; iPackageManagerInterface &#125;, <span class="keyword">new</span> PackageManagerHandler(sPackageManager));</span><br><span class="line"> sPackageManagerField.set(currentActivityThread, proxy);</span><br></pre></td></tr></table></figure><p>使用同样的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PackageManagerHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object mBase;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PackageManagerHandler</span><span class="params">(Object base)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mBase = base;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (method.getName().equals(<span class="string">"getPackageInfo"</span>)) &#123;</span><br><span class="line">            PackageInfo info = (PackageInfo) method.invoke(mBase, args);</span><br><span class="line">            info.packageName = <span class="string">"hook"</span>;</span><br><span class="line">            <span class="keyword">return</span> info;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.getName().equals(<span class="string">"getInstalledApplications"</span>)) &#123;</span><br><span class="line">            Object result = method.invoke(mBase, args);</span><br><span class="line"></span><br><span class="line">            Class&lt;?&gt; parceledListSliceClass = Class.forName(<span class="string">"android.content.pm.ParceledListSlice"</span>);</span><br><span class="line">            Field mListField = parceledListSliceClass.getDeclaredField(<span class="string">"mList"</span>);</span><br><span class="line"></span><br><span class="line">            mListField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            List mList = (List) mListField.get(result);</span><br><span class="line"></span><br><span class="line">            List&lt;ApplicationInfo&gt; apps = (List&lt;ApplicationInfo&gt;) mList;</span><br><span class="line">            <span class="keyword">for</span> (ApplicationInfo info : apps) &#123;</span><br><span class="line">                info.packageName += <span class="string">".hook"</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> method.invoke(mBase, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Hook掉了<code>getPackageInfo()</code>方法，修改了包名，Hook掉<code>getInstalledApplications()</code>方法，在每个包名后面加了<code>.hook</code></p><h3 id="Activity生命周期管理"><a href="#Activity生命周期管理" class="headerlink" title="Activity生命周期管理"></a>Activity生命周期管理</h3><p>Activity必须在清单中显示声明，而清单不可能预先声明插件中的Activity</p><p>解决：可以预先注册一个中间Activity欺骗系统，然后替换成真正的Activity</p><p>首先处理ActivityManagerNative</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityManagerHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object mBase;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ActivityManagerHandler</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mBase = object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (method.getName().equals(<span class="string">"startActivity"</span>)) &#123;</span><br><span class="line">            <span class="comment">// 拿到Intent参数</span></span><br><span class="line">          Intent rawIntent;</span><br><span class="line">            <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (args[i] <span class="keyword">instanceof</span> Intent) &#123;</span><br><span class="line">                    index = i;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            rawIntent = (Intent) args[index];</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 伪装一个Intent 目标Activity设置为StubActivity</span></span><br><span class="line">            Intent hookIntent = <span class="keyword">new</span> Intent();</span><br><span class="line">            ComponentName componentName = <span class="keyword">new</span> ComponentName(MyApplication.APP, StubActivity.class.getCanonicalName());</span><br><span class="line">            hookIntent.setComponent(componentName);</span><br><span class="line">          <span class="comment">// 把真正的Intent保存下来</span></span><br><span class="line">            hookIntent.putExtra(Constants.EXTRA_TARGET_INTENT, rawIntent);</span><br><span class="line">            args[index] = hookIntent;</span><br><span class="line">            <span class="keyword">return</span> method.invoke(mBase, args);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> method.invoke(mBase, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样AMS侧就会认为启动了一个清单中注册的Activity，接下来在AMS对应用的回调里替换实际的Activity，所有的操作会在<code>ActivityThread.H</code>里分发处理，因为<code>Handler</code>的处理顺序是先<code>Message.handleMessage()</code>，再使用全局<code>mCallback</code>的<code>handleMessage()</code>，最后调用<code>Handler.handleMessage()</code>，所以可以Hook这个全局<code>mCallback</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HookHandlerCallback</span> <span class="keyword">implements</span> <span class="title">Handler</span>.<span class="title">Callback</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt; mActivityClientRecordClass;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> LAUNCH_ACTIVITY;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HookHandlerCallback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 先反射拿到需要的类和变量</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class&lt;?&gt; HClass = Class.forName(<span class="string">"android.app.ActivityThread$H"</span>);</span><br><span class="line">            Field LAUNCH_ACTIVITY_FIELD = HClass.getDeclaredField(<span class="string">"LAUNCH_ACTIVITY"</span>);</span><br><span class="line">            LAUNCH_ACTIVITY_FIELD.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            LAUNCH_ACTIVITY = (<span class="keyword">int</span>) LAUNCH_ACTIVITY_FIELD.get(<span class="keyword">null</span>);</span><br><span class="line">            mActivityClientRecordClass = Class.forName(<span class="string">"android.app.ActivityThread$ActivityClientRecord"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (msg.what == LAUNCH_ACTIVITY) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="comment">// 拿到ActivityClientRecord的intent字段 获得intent</span></span><br><span class="line">                Field intentField = mActivityClientRecordClass.getDeclaredField(<span class="string">"intent"</span>);</span><br><span class="line">                intentField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                Intent intent = (Intent) intentField.get(msg.obj);</span><br><span class="line">              </span><br><span class="line">              <span class="comment">// 获得实际的intent 并设置到intent字段里</span></span><br><span class="line">                Intent realIntent = intent.getParcelableExtra(Constants.EXTRA_TARGET_INTENT);</span><br><span class="line">                <span class="keyword">if</span> (realIntent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    intentField.set(msg.obj, realIntent);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为AMS和应用之间并不传递具体的Activity信息，而是通过一个token关联，所以AMS侧仍然操作着伪造的Activity，应用侧则操作着真实的Activity，并且拥有正常的生命周期</p><h3 id="ClassLoader"><a href="#ClassLoader" class="headerlink" title="ClassLoader"></a>ClassLoader</h3><p>Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校检、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制，是运行时动态加载的</p><p>Android通过DexClassLoader直接加载dex或apk</p><h2 id="插件Activity"><a href="#插件Activity" class="headerlink" title="插件Activity"></a>插件Activity</h2><h3 id="多ClassLoader方案"><a href="#多ClassLoader方案" class="headerlink" title="多ClassLoader方案"></a>多ClassLoader方案</h3><p>Activity的实例是在<code>ActivityThread.performLaunchActivity()</code>中创建的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Activity <span class="title">performLaunchActivity</span><span class="params">(ActivityClientRecord r, Intent customIntent)</span> </span>&#123;</span><br><span class="line">    ActivityInfo aInfo = r.activityInfo;</span><br><span class="line">    <span class="keyword">if</span> (r.packageInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">        r.packageInfo = getPackageInfo(aInfo.applicationInfo, r.compatInfo, Context.CONTEXT_INCLUDE_CODE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ComponentName component = r.intent.getComponent();</span><br><span class="line">    <span class="keyword">if</span> (component == <span class="keyword">null</span>) &#123;</span><br><span class="line">        component = r.intent.resolveActivity(mInitialApplication.getPackageManager());</span><br><span class="line">        r.intent.setComponent(component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r.activityInfo.targetActivity != <span class="keyword">null</span>) &#123;</span><br><span class="line">        component = <span class="keyword">new</span> ComponentName(r.activityInfo.packageName, r.activityInfo.targetActivity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ContextImpl appContext = createBaseContextForActivity(r);</span><br><span class="line">    Activity activity = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        java.lang.ClassLoader cl = appContext.getClassLoader();</span><br><span class="line">        activity = mInstrumentation.newActivity(cl, component.getClassName(), r.intent);</span><br><span class="line">      ......</span><br><span class="line">    &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见需要拿到一个ClassLoader和类名</p><p>这里的<code>ClassLoader</code>是由<code>r.packageInfo</code>的<code>getClassLoader()</code>获得</p><p><code>r.packageInfo</code>是一个<code>LoadedApk</code>对象，代表一个当前加载了的apk的本地状态，是apk在内存中的表示</p><p>在<code>ActivityThread.H.handleMessage()</code>里，可以看到<code>r.pakcageInfo</code> 的来源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> LAUNCH_ACTIVITY: &#123;</span><br><span class="line">    <span class="keyword">final</span> ActivityClientRecord r = (ActivityClientRecord) msg.obj;</span><br><span class="line">    r.packageInfo = getPackageInfoNoCheck(r.activityInfo.applicationInfo, r.compatInfo);</span><br><span class="line">    handleLaunchActivity(r, <span class="keyword">null</span>, <span class="string">"LAUNCH_ACTIVITY"</span>);</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后调用了<code>getPackageInfo()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> LoadedApk <span class="title">getPackageInfo</span><span class="params">(ApplicationInfo aInfo, CompatibilityInfo compatInfo, ClassLoader baseLoader, <span class="keyword">boolean</span> securityViolation, <span class="keyword">boolean</span> includeCode, <span class="keyword">boolean</span> registerPackage)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断调用方和自己是不是一个UserId，是的话可以共享缓存数据</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> differentUser = (UserHandle.myUserId() != UserHandle.getUserId(aInfo.uid));</span><br><span class="line">    <span class="keyword">synchronized</span> (mResourcesManager) &#123;</span><br><span class="line">     WeakReference&lt;LoadedApk&gt; ref;</span><br><span class="line">        <span class="keyword">if</span> (differentUser) &#123;</span><br><span class="line">            ref = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (includeCode) &#123;</span><br><span class="line">            <span class="comment">// 调用进来传的includeCode是true 所以走这里</span></span><br><span class="line">            ref = mPackages.get(aInfo.packageName);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ref = mResourcePackages.get(aInfo.packageName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从缓存拿LoadedApk</span></span><br><span class="line">        LoadedApk packageInfo = ref != <span class="keyword">null</span> ? ref.get() : <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 未命中或者需要更新资源则创建一个</span></span><br><span class="line">       <span class="keyword">if</span> (packageInfo == <span class="keyword">null</span> || (packageInfo.mResources != <span class="keyword">null</span> &amp;&amp; !packageInfo.mResources.getAssets().isUpToDate())) &#123;</span><br><span class="line">            packageInfo ＝ <span class="keyword">new</span> LoadedApk(<span class="keyword">this</span>, aInfo, compatInfo, baseLoader, securityViolation, includeCode &amp;&amp; (aInfo.flags&amp;ApplicationInfo.FLAG_HAS_CODE) != <span class="number">0</span>, registerPackage);</span><br><span class="line">        </span><br><span class="line">            <span class="comment">// 系统线程和系统包的处理</span></span><br><span class="line">            <span class="keyword">if</span> (mSystemThread &amp;&amp; <span class="string">"android"</span>.equals(aInfo.packageName)) &#123;</span><br><span class="line">              packageInfo.installSystemApplicationInfo(aInfo, getSystemContext().mPackageInfo.getClassLoader());</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">            <span class="comment">// 缓存</span></span><br><span class="line">            <span class="keyword">if</span> (differentUser) &#123;</span><br><span class="line">          </span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (includeCode) &#123;</span><br><span class="line">                mPackages.put(aInfo.packageName, <span class="keyword">new</span> WeakReference&lt;LoadedApk&gt;(packageInfo));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mResourcePackages.put(aInfo.packageName, <span class="keyword">new</span> WeakReference&lt;LoadedApk&gt;(packageInfo));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的<code>mPackages</code> 就是一个Hook点，可以构造自己的<code>LoadedApk</code>添加进去</p><p><code>LoadedApk</code>又可以通过<code>getPackageInfoNoCheck()</code>获得</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> LoadedApk <span class="title">getPackageInfoNoCheck</span><span class="params">(ApplicationInfo ai, CompatibilityInfo compatInfo)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getPackageInfo(ai, compatInfo, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要构造<code>ApplicationInfo</code>和<code>CompatibilityInfo</code>两个参数</p><p>前者描述了由清单的<code>application</code>标签描述的信息，可以使用<code>PackageParser</code>的<code>generateApplication()</code>方法获得，然而这个类的兼容性非常差</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ApplicationInfo <span class="title">generateApplicationInfo</span><span class="params">(Package p, <span class="keyword">int</span> flags, PackageUserState state)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">｝</span><br></pre></td></tr></table></figure><p>参数<code>Package</code>需要分析apk文件，可使用<code>PackageParser.parsePackage()</code>获得</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Package <span class="title">parsePackage</span><span class="params">(File packageFile, <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> PackageParserException </span>&#123;</span><br><span class="line">  ......</span><br><span class="line">｝</span><br></pre></td></tr></table></figure><p>需要传入apk文件和标志位</p><p>后者代表不同用户中包的信息，这里用默认的即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获得当前的ActivityThread对象</span></span><br><span class="line">Class&lt;?&gt; activityThreadClass = Class.forName(<span class="string">"android.app.ActivityThread"</span>);</span><br><span class="line">Method currentActivityThreadMethod = activityThreadClass.getDeclaredMethod(<span class="string">"currentActivityThread"</span>);</span><br><span class="line">Object currentActivityThread = currentActivityThreadMethod.invoke(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得ActivityThread中的mPackages字段</span></span><br><span class="line">ArrayMap&lt;String, WeakReference&lt;Object&gt;&gt; mPackages = (ArrayMap&lt;String, WeakReference&lt;Object&gt;&gt;) ReflectUtil.getField(<span class="string">"android.app.ActivityThread"</span>, <span class="string">"mPackages"</span>, currentActivityThread);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得PackageParser.generateApplicationInfo方法</span></span><br><span class="line">Method generateApplication = ReflectUtil.getMethod(<span class="string">"android.content.pm.PackageParser"</span>, <span class="string">"generateApplicationInfo"</span>, <span class="string">"android.content.pm.PackageParser$Package"</span>, <span class="keyword">int</span>.class, <span class="string">"android.content.pm.PackageUserState"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得PackageUserState类</span></span><br><span class="line">Class&lt;?&gt; packageUserStateClass = ReflectUtil.getClass(<span class="string">"android.content.pm.PackageUserState"</span>);</span><br><span class="line">Object packageUserState = packageUserStateClass.newInstance();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得CompatibilityInfo的DEFAULT_COMPATIBILITY_INFO字段 即默认实现</span></span><br><span class="line">Class&lt;?&gt; compatibilityInfoClass = ReflectUtil.getClass(<span class="string">"android.content.res.CompatibilityInfo"</span>);</span><br><span class="line">Object compatibilityInfo = ReflectUtil.getField(<span class="string">"android.content.res.CompatibilityInfo"</span>, <span class="string">"DEFAULT_COMPATIBILITY_INFO"</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得PackageParser类 并构造一个对象</span></span><br><span class="line">Class&lt;?&gt; packageParserClass = ReflectUtil.getClass(<span class="string">"android.content.pm.PackageParser"</span>);</span><br><span class="line">Object packageParser = packageParserClass.newInstance();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得PackageParser.parsePackage()方法并调用</span></span><br><span class="line">File apkFile = <span class="keyword">new</span> File(dstDir, <span class="string">"plugin.apk"</span>);</span><br><span class="line">Method parsePackage = ReflectUtil.getMethod(<span class="string">"android.content.pm.PackageParser"</span>, <span class="string">"parsePackage"</span>, File.class, <span class="keyword">int</span>.class);</span><br><span class="line">Object pack = parsePackage.invoke(packageParser, apkFile, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用前面拿到的方法和构造的参数得到ApplicationInfo</span></span><br><span class="line">ApplicationInfo applicationInfo = (ApplicationInfo) generateApplication.invoke(packageParser, pack, <span class="number">0</span>, packageUserState);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入插件Apk路径信息</span></span><br><span class="line">applicationInfo.sourceDir = apkFile.getPath();</span><br><span class="line">applicationInfo.publicSourceDir = apkFile.getPath();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得ActivityThread.getPackageInfoNoCheck()方法并调用得到LoadedApk</span></span><br><span class="line">Method getPackageInfoNoCheck = ReflectUtil.getMethod(<span class="string">"android.app.ActivityThread"</span>, <span class="string">"getPackageInfoNoCheck"</span>, ApplicationInfo.class, compatibilityInfoClass);</span><br><span class="line">Object loadedApk = getPackageInfoNoCheck.invoke(currentActivityThread, applicationInfo, compatibilityInfo);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造一个自定义的ClassLoader</span></span><br><span class="line">String optimizedDirectory = getFilesDir() + File.separator + <span class="string">"plugin"</span>;</span><br><span class="line">File optimizedFile = <span class="keyword">new</span> File(optimizedDirectory);</span><br><span class="line"><span class="keyword">if</span> (!optimizedFile.exists()) &#123;</span><br><span class="line">    optimizedFile.mkdir();</span><br><span class="line">&#125;</span><br><span class="line">ClassLoader classLoader = <span class="keyword">new</span> HookClassLoader(apkFile.getPath(), optimizedDirectory, <span class="keyword">null</span>, <span class="keyword">this</span>.getClassLoader());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改LoadedApk的mClassLoader字段</span></span><br><span class="line">ReflectUtil.setField(<span class="string">"android.app.LoadedApk"</span>, <span class="string">"mClassLoader"</span>, classLoader, loadedApk);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 强引用保存一份 防止被回收</span></span><br><span class="line">sLoadedApk.put(applicationInfo.packageName, loadedApk);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以包名为键存放到mPackages字段中</span></span><br><span class="line">mPackages.put(applicationInfo.packageName, <span class="keyword">new</span> WeakReference&lt;&gt;(loadedApk));</span><br></pre></td></tr></table></figure><p>这样调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line"><span class="comment">// 填入想要调用的插件包名和类名</span></span><br><span class="line">intent.setComponent(<span class="keyword">new</span> ComponentName(<span class="string">"com.example.liuhan.subproject"</span>, <span class="string">"com.example.liuhan.subproject.MainActivity"</span>));</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure><p>按照教程这么做，后来一直找不到对应的类，堆栈中显示ClassLoader并不是我们提供的自定义ClassLoader，而<code>mPackages</code>中确实加入了插件信息</p><p>所以只可能是传入的键有问题，实际使用的是<code>ActivityInfo.applicationInfo.packageName</code>，通过拦截AMS回调发现这个值仍然是宿主包名，在Hook后的<code>ActivityThread.H</code> 中修改之</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拿到真实包名</span></span><br><span class="line">String packageName = realIntent.getPackage();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改一个ActivityInfo并保存起来 后用</span></span><br><span class="line">Field activityInfoField = mActivityClientRecordClass.getDeclaredField(<span class="string">"activityInfo"</span>);</span><br><span class="line">activityInfoField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">ActivityInfo activityInfo = (ActivityInfo) activityInfoField.get(msg.obj);</span><br><span class="line">activityInfo.packageName = packageName;</span><br><span class="line">activityInfo.applicationInfo.packageName = packageName;</span><br><span class="line">activityInfoField.set(msg.obj, activityInfo);</span><br></pre></td></tr></table></figure><p>前面也要传一下真实包名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">intent.setPackage(<span class="string">"com.example.liuhan.subproject"</span>);</span><br><span class="line">intent.setComponent(<span class="keyword">new</span> ComponentName(<span class="string">"com.example.liuhan.subproject"</span>, <span class="string">"com.example.liuhan.subproject.MainActivity"</span>));</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure><p>再次启动会遇到无法实例化Application，，追踪发现系统会向PMS查询包信息，因为没有而抛出异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Application <span class="title">makeApplication</span><span class="params">(<span class="keyword">boolean</span> forceDefaultAppClass, Instrumentation instrumentation)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (!mPackageName.equals(<span class="string">"android"</span>)) &#123;</span><br><span class="line">        initializeJavaContextClassLoader();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initializeJavaContextClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IPackageManager pm = ActivityThread.getPackageManager();</span><br><span class="line">    android.content.pm.PackageInfo pi;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        pi = pm.getPackageInfo(mPackageName, PackageManager.MATCH_DEBUG_TRIAGED_MISSING, UserHandle.myUserId());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pi == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unable to get package info for "</span> + mPackageName + <span class="string">"; is package not installed?"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getParentActivityName</span><span class="params">(Context context, ComponentName componentName)</span> <span class="keyword">throws</span> NameNotFoundException </span>&#123;</span><br><span class="line">    PackageManager pm = context.getPackageManager();</span><br><span class="line">    ActivityInfo info = pm.getActivityInfo(componentName, PackageManager.GET_META_DATA);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要Hook一下PMS做处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (method.getName().equals(<span class="string">"getPackageInfo"</span>)) &#123;</span><br><span class="line">    String packageName = (String) args[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> (packageName.equals(<span class="string">"com.example.liuhan.subproject"</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PackageInfo();</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拦截<code>getPackageInfo()</code>命令，改为在本地查找，找到则返回，否则交给系统做，这样就骗过去了</p><p>最后碰到一个问题，堆栈涉及<code>AppCompatActivity</code>，把插件Activity的基类改为<code>Activity</code>就好了，尚不清楚为什么</p><h3 id="单ClassLoader方案"><a href="#单ClassLoader方案" class="headerlink" title="单ClassLoader方案"></a>单ClassLoader方案</h3><p>对宿主的ClassLoader做修改，使其可以找到我们插件中的类</p><p>在Application类中有一个成员变量<code>mLoadedApk</code>，表示宿主的LoadedApk，而这个变量是从ContextImpl中获取的；ContextImpl重写了getClassLoader方法，因此我们在Context环境中<code>getClassLoader()</code>获取到的就是宿主程序的ClassLoader</p><p><em>LoadedApk.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ClassLoader <span class="title">getClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mClassLoader == <span class="keyword">null</span>) &#123;</span><br><span class="line">            createOrUpdateClassLoaderLocked(<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mClassLoader;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createOrUpdateClassLoaderLocked</span><span class="params">(List&lt;String&gt; addedPaths)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    mClassLoader = ApplicationLoaders.getDefault().getClassLoader(<span class="string">""</span>, mApplicationInfo.targetSdkVersion, isBundledApp, librarySearchPath, libraryPermittedPath, mBaseClassLoader);</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>ApplicationLoaders.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ClassLoader <span class="title">getClassLoader</span><span class="params">(String zip, <span class="keyword">int</span> targetSdkVersion, <span class="keyword">boolean</span> isBundled, String librarySearchPath, String libraryPermittedPath, ClassLoader parent, String cacheKey)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    PathClassLoader pathClassloader = PathClassLoaderFactory.createClassLoader(zip, librarySearchPath, libraryPermittedPath, parent, targetSdkVersion, isBundled);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>PathClassLoader.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PathClassLoader</span> <span class="keyword">extends</span> <span class="title">BaseDexClassLoader</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>BaseDexClassLoader.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    List&lt;Throwable&gt; suppressedExceptions = <span class="keyword">new</span> ArrayList&lt;Throwable&gt;();</span><br><span class="line">    Class c = pathList.findClass(name, suppressedExceptions);</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">        ClassNotFoundException cnfe = <span class="keyword">new</span> ClassNotFoundException(<span class="string">"Didn't find class \""</span> + name + <span class="string">"\" on path: "</span> + pathList);</span><br><span class="line">        <span class="keyword">for</span> (Throwable t : suppressedExceptions) &#123;</span><br><span class="line">            cnfe.addSuppressed(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> cnfe;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到它在一个<code>pathList</code>里面查找类，是一个<code>DexPathList</code>对象</p><p><em>DexPathList.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Class <span class="title">findClass</span><span class="params">(String name, List&lt;Throwable&gt; suppressed)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">for</span> (Element element : dexElements) &#123;</span><br><span class="line">       DexFile dex = element.dexFile;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (dex != <span class="keyword">null</span>) &#123;</span><br><span class="line">           Class clazz = dex.loadClassBinaryName(name, definingContext, suppressed);</span><br><span class="line">           <span class="keyword">if</span> (clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">return</span> clazz;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (dexElementsSuppressedExceptions != <span class="keyword">null</span>) &#123;</span><br><span class="line">       suppressed.addAll(Arrays.asList(dexElementsSuppressedExceptions));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会遍历它的<code>dexElements</code>数组来查找类，可以在这里做修改</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获得DexClassLoader的pathList字段</span></span><br><span class="line">Field pathListField = DexClassLoader.class.getSuperclass().getDeclaredField(<span class="string">"pathList"</span>);</span><br><span class="line">pathListField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">Object pathList = pathListField.get(loader);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得DexList的dexElements字段</span></span><br><span class="line">Field dexElementsField = pathList.getClass().getDeclaredField(<span class="string">"dexElements"</span>);</span><br><span class="line">dexElementsField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">Object[] dexElements = (Object[]) dexElementsField.get(pathList);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建新Element数组</span></span><br><span class="line">Class&lt;?&gt; elementClass = dexElements.getClass().getComponentType();</span><br><span class="line">Object[] newDexElements = (Object[]) Array.newInstance(elementClass, dexElements.length + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造插件的Element</span></span><br><span class="line">Constructor&lt;?&gt; constructor = elementClass.getConstructor(File.class, <span class="keyword">boolean</span>.class, File.class, DexFile.class);</span><br><span class="line">Object element = constructor.newInstance(apk, <span class="keyword">false</span>, apk, DexFile.loadDex(apk.getCanonicalPath(), optDex.getAbsolutePath(), <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插件Element数组</span></span><br><span class="line">Object[] toAdd = <span class="keyword">new</span> Object[] &#123; element &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将原数组和插件数组都拷贝到新数组</span></span><br><span class="line">System.arraycopy(dexElements, <span class="number">0</span>, newDexElements, <span class="number">0</span>, dexElements.length);</span><br><span class="line">System.arraycopy(toAdd, <span class="number">0</span>, newDexElements, newDexElements.length - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置回去</span></span><br><span class="line">dexElementsField.set(pathList, newDexElements);</span><br></pre></td></tr></table></figure><p>多ClassLoader构架，每一个插件都有一个自己的ClassLoader，因此类的隔离性非常好——如果不同的插件使用了同一个库的不同版本，它们相安无事</p><p>单ClassLoader方案，插件和宿主程序的类全部都通过宿主的ClasLoader加载，虽然代码简单，但是鲁棒性很差；无法避免插件之间甚至插件与宿主之间使用的类库有冲突</p><p>多ClassLoader还有一个优点可以真正完成代码的热加载，如果插件需要升级，直接重新创建一个自定的ClassLoader加载新的插件，然后替换掉原来的版本即可（Java中，不同ClassLoader加载的同一个类被认为是不同的类）</p><p>多ClassLoader架构在大多数情况下是明智之举</p><h3 id="插件BroadcastReceiver"><a href="#插件BroadcastReceiver" class="headerlink" title="插件BroadcastReceiver"></a>插件BroadcastReceiver</h3><p>静态注册的接收器在清单文件里，解析后保存在PMS中，以供AMS使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List receivers = <span class="keyword">null</span>;</span><br><span class="line">List&lt;BroadcastFilter&gt; registeredReceivers = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> ((intent.getFlags()&amp;Intent.FLAG_RECEIVER_REGISTERED_ONLY) == <span class="number">0</span>) &#123;</span><br><span class="line">    receivers = collectReceiverComponents(intent, resolvedType, callingUid, users);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (intent.getComponent() == <span class="keyword">null</span>) &#123;</span><br><span class="line">    registeredReceivers = mReceiverResolver.queryIntent(intent, resolvedType, <span class="keyword">false</span>, userId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>receivers</code>里就是从PMS获得的静态注册的接收器，<code>registeredReceivers</code>是动态注册的接收器</p><h3 id="动态注册接收器"><a href="#动态注册接收器" class="headerlink" title="动态注册接收器"></a>动态注册接收器</h3><p>只需要反射即可使用</p><h3 id="静态注册接收器"><a href="#静态注册接收器" class="headerlink" title="静态注册接收器"></a>静态注册接收器</h3><p>分析插件清单文件中的<code>receiver</code>然后集中动态注册</p><blockquote><p>缺点是无法在应用未运行时接收到广播</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerPluginReceiver</span><span class="params">(File apkFile)</span> <span class="keyword">throws</span> IllegalAccessException, InstantiationException, InvocationTargetException, ClassNotFoundException </span>&#123;</span><br><span class="line">  <span class="comment">// 拿到PackageParser类 调用其parsePackage方法分析apk文件</span></span><br><span class="line">    Class&lt;?&gt; packageParserClass = ReflectUtil.getClass(<span class="string">"android.content.pm.PackageParser"</span>);</span><br><span class="line">    Object packageParser = packageParserClass.newInstance();</span><br><span class="line">    Method parsePackage = ReflectUtil.getMethod(<span class="string">"android.content.pm.PackageParser"</span>, <span class="string">"parsePackage"</span>, File.class, <span class="keyword">int</span>.class);</span><br><span class="line">    Object pack = parsePackage.invoke(packageParser, apkFile, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 取出Package的receivers字段</span></span><br><span class="line">    ArrayList receivers = (ArrayList) ReflectUtil.getField(<span class="string">"android.content.pm.PackageParser$Package"</span>, <span class="string">"receivers"</span>, pack);</span><br><span class="line">    <span class="keyword">for</span> (Object receiver : receivers) &#123;</span><br><span class="line">      <span class="comment">// 取出className字段 创建一个广播接收器</span></span><br><span class="line">        String className = (String) ReflectUtil.getField(<span class="string">"android.content.pm.PackageParser$Component"</span>, <span class="string">"className"</span>, receiver);</span><br><span class="line">        Class&lt;?&gt; receiverClass = Class.forName(className);</span><br><span class="line">        BroadcastReceiver r = (BroadcastReceiver) receiverClass.newInstance();</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 取出intents字段 里面保存的是IntentFilter 注册广播接收器</span></span><br><span class="line">        ArrayList intents = (ArrayList) ReflectUtil.getField(<span class="string">"android.content.pm.PackageParser$Component"</span>, <span class="string">"intents"</span>, receiver);</span><br><span class="line">        <span class="keyword">for</span> (Object intent : intents) &#123;</span><br><span class="line">            registerReceiver(r, (IntentFilter) intent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在插件的ClassLoader信息添加之后执行上面的方法，动态注册所有静态的广播接收器</p><h2 id="插件Service"><a href="#插件Service" class="headerlink" title="插件Service"></a>插件Service</h2><p>Service和Activity一样，都需要通过AMS管理，但Service不能简单的套用Activity的插件化方案，因为Activity有栈管理，有限的StubActivity可以满足需求，而Service的数量可能无法被有限的StubService满足</p><p>可以使用手动管理Service：拦截到<code>startService()</code>或<code>bindService()</code>，没有创建Service则创建并调用<code>onCreate</code>和<code>onStartCommand()</code>，如果创建了则调用<code>onStartCommand()</code>，拦截到<code>stopService()</code>则调用<code>onDestroy()</code></p><p>为了仍能使用Service的独立进程特性，可以在清单中声明一些不同进程中的Service，启动代理Service，在其<code>onStartCommand()</code>中分发执行插件Service中的<code>onStartCommand()</code>方法</p><h3 id="启动Service"><a href="#启动Service" class="headerlink" title="启动Service"></a>启动Service</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">service</span> <span class="attr">android:name</span>=<span class="string">".ProxyService"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>清单中定义代理Service</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">onStartCommand</span><span class="params">(Intent intent, <span class="keyword">int</span> flags, <span class="keyword">int</span> startId)</span> </span>&#123;</span><br><span class="line">        ServiceManager.getInstance().onStartCommand(intent, flags, startId);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onStartCommand(intent, flags, startId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代理Service的<code>onStartCommand()</code>里分发到真实Service里</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStartCommand</span><span class="params">(Intent intent, <span class="keyword">int</span> flags, <span class="keyword">int</span> startId)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 取得真实Intent</span></span><br><span class="line">    Intent realIntent = intent.getParcelableExtra(Constants.EXTRA_TARGET_INTENT);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 根据Intent信息找到ServiceInfo</span></span><br><span class="line">    ServiceInfo serviceInfo = selectPluginService(realIntent);</span><br><span class="line">    <span class="keyword">if</span> (serviceInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从Service表中查找对应类名的Service</span></span><br><span class="line">    <span class="keyword">if</span> (!sServiceMap.containsKey(serviceInfo.name)) &#123;</span><br><span class="line">      <span class="comment">// 没找到就创建</span></span><br><span class="line">        createService(intent, serviceInfo);</span><br><span class="line">    &#125;</span><br><span class="line">    Service service = sServiceMap.get(serviceInfo.name);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 调用Service的onStartCommand()</span></span><br><span class="line">    service.onStartCommand(intent, flags, startId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createService</span><span class="params">(Intent intent, ServiceInfo serviceInfo)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 获得CreateServiceData类 构造之</span></span><br><span class="line">        Class&lt;?&gt; createServiceDataClass = ReflectUtil.getClass(<span class="string">"android.app.ActivityThread$CreateServiceData"</span>);</span><br><span class="line">        Constructor&lt;?&gt; constructor = createServiceDataClass.getDeclaredConstructor();</span><br><span class="line">        constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Object createServiceData = constructor.newInstance();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 填写token/info/intent/compatInfo字段</span></span><br><span class="line">        IBinder token = <span class="keyword">new</span> Binder();</span><br><span class="line">        ReflectUtil.setField(<span class="string">"android.app.ActivityThread$CreateServiceData"</span>, <span class="string">"token"</span>, token, createServiceData);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 因为使用的单ClassLoader方案 是找不到插件对应的ClassLoader的 所以需要把其应用名改成宿主的 使用宿主ClassLoader</span></span><br><span class="line">        serviceInfo.applicationInfo.packageName = MyApplication.APP.getPackageName();</span><br><span class="line">        ReflectUtil.setField(<span class="string">"android.app.ActivityThread$CreateServiceData"</span>, <span class="string">"info"</span>, serviceInfo, createServiceData);</span><br><span class="line">        Object compatibilityInfo = ReflectUtil.getField(<span class="string">"android.content.res.CompatibilityInfo"</span>, <span class="string">"DEFAULT_COMPATIBILITY_INFO"</span>, <span class="keyword">null</span>);</span><br><span class="line">        ReflectUtil.setField(<span class="string">"android.app.ActivityThread$CreateServiceData"</span>, <span class="string">"compatInfo"</span>, compatibilityInfo, createServiceData);</span><br><span class="line">        ReflectUtil.setField(<span class="string">"android.app.ActivityThread$CreateServiceData"</span>, <span class="string">"intent"</span>, intent, createServiceData);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 调用ActivityThread.handleCreateService()方法</span></span><br><span class="line">        Method handleCreateService = ReflectUtil.getMethod(<span class="string">"android.app.ActivityThread"</span>, <span class="string">"handleCreateService"</span>, createServiceDataClass);</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; activityThreadClass = Class.forName(<span class="string">"android.app.ActivityThread"</span>);</span><br><span class="line">        Method currentActivityThreadMethod = activityThreadClass.getDeclaredMethod(<span class="string">"currentActivityThread"</span>);</span><br><span class="line">        Object currentActivityThread = currentActivityThreadMethod.invoke(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        handleCreateService.invoke(currentActivityThread, createServiceData);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 因为创建Service方法无返回 而是把Service保存在了ActivityThread的mServices中 故取出并找到对应Service 保存在我们自己的表中</span></span><br><span class="line">        ArrayMap mServices = (ArrayMap) ReflectUtil.getField(<span class="string">"android.app.ActivityThread"</span>, <span class="string">"mServices"</span>, currentActivityThread);</span><br><span class="line">        Service service = (Service) mServices.get(token);</span><br><span class="line">        sServiceMap.put(serviceInfo.name, service);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> ServiceInfo <span class="title">selectPluginService</span><span class="params">(Intent pluginIntent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (String className: sServiceInfoMap.keySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (className.equals(pluginIntent.getComponent().getClassName())) &#123;</span><br><span class="line">            <span class="keyword">return</span> sServiceInfoMap.get(className);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分发<code>onStartCommand()</code>给实际Service</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (method.getName().equals(<span class="string">"startService"</span>)) &#123;</span><br><span class="line">    Intent rawIntent;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (args[i] <span class="keyword">instanceof</span> Intent) &#123;</span><br><span class="line">            index = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    rawIntent = (Intent) args[index];</span><br><span class="line"></span><br><span class="line">    Intent hookIntent = <span class="keyword">new</span> Intent();</span><br><span class="line">    hookIntent.setPackage(rawIntent.getPackage());</span><br><span class="line">    ComponentName componentName = <span class="keyword">new</span> ComponentName(MyApplication.APP, ProxyService.class.getName());</span><br><span class="line">    hookIntent.setComponent(componentName);</span><br><span class="line">    hookIntent.putExtra(Constants.EXTRA_TARGET_INTENT, rawIntent);</span><br><span class="line">    args[index] = hookIntent;</span><br><span class="line">    <span class="keyword">return</span> method.invoke(mBase, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Hook掉AMS，拦截<code>startService()</code>，修改Intent的目标Service为代理Service，并将真实Intent保存起来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ArrayList services = (ArrayList) ReflectUtil.getField(<span class="string">"android.content.pm.PackageParser$Package"</span>, <span class="string">"services"</span>, pack);</span><br><span class="line"><span class="keyword">for</span> (Object service : services) &#123;</span><br><span class="line">    String className = (String) ReflectUtil.getField(<span class="string">"android.content.pm.PackageParser$Component"</span>, <span class="string">"className"</span>, service);</span><br><span class="line">    ServiceInfo info = (ServiceInfo) ReflectUtil.getField(<span class="string">"android.content.pm.PackageParser$Service"</span>, <span class="string">"info"</span>, service);</span><br><span class="line">    ServiceManager.sServiceInfoMap.put(className, info);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解析插件apk，把清单中的Service的信息保存起来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">intent.setComponent(<span class="keyword">new</span> ComponentName(<span class="string">"com.example.liuhan.subproject"</span>, <span class="string">"com.example.liuhan.subproject.PluginService"</span>));</span><br><span class="line">startService(intent);</span><br></pre></td></tr></table></figure><p>填入包名和类名，启动Service</p><h3 id="绑定Service"><a href="#绑定Service" class="headerlink" title="绑定Service"></a>绑定Service</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ServiceConnection mConnection = <span class="keyword">new</span> ServiceConnection() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;</span><br><span class="line">        ProxyService s = ((ProxyService.MyBinder) service).getService();</span><br><span class="line">        <span class="keyword">int</span> result = (<span class="keyword">int</span>) s.invoke(<span class="string">"com.example.liuhan.subproject.PluginService"</span>, <span class="string">"add"</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName name)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">intent.setComponent(<span class="keyword">new</span> ComponentName(<span class="string">"com.example.liuhan.subproject"</span>, <span class="string">"com.example.liuhan.subproject.PluginService"</span>));</span><br><span class="line">bindService(intent, mConnection, Context.BIND_AUTO_CREATE);</span><br></pre></td></tr></table></figure><p>这里绑定了指定包名和类名的服务，在绑定成功后通过传递包名、方法名和参数调用其方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 因为不会调用onStartCommand() 所以在这里把实际的Intent保存起来</span></span><br><span class="line">        Intent realIntent = intent.getParcelableExtra(Constants.EXTRA_TARGET_INTENT);</span><br><span class="line">        <span class="keyword">if</span> (realIntent != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ServiceManager.getInstance().addIntent(realIntent);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyBinder();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBinder</span> <span class="keyword">extends</span> <span class="title">Binder</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> ProxyService <span class="title">getService</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> ProxyService.<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 提供一个调用函数的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(String className, String methodName, Object... args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ServiceManager.getInstance().invoke(className, methodName, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在代理服务里添加相关代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(String className, String methodName, Object... args)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 在服务表里面查包名 没查找就创建服务</span></span><br><span class="line">    <span class="keyword">if</span> (!sServiceMap.containsKey(className)) &#123;</span><br><span class="line">        Intent intent = <span class="keyword">null</span>;</span><br><span class="line">      <span class="comment">// 从Intent表里面查对应Intent</span></span><br><span class="line">        <span class="keyword">if</span> (sIntentMap.containsKey(className)) &#123;</span><br><span class="line">            intent = sIntentMap.get(className);</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 根据Intent查ServiceInfo 根据ServiceInfo和Intent创建服务</span></span><br><span class="line">        <span class="keyword">if</span> (intent != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ServiceInfo serviceInfo = selectPluginService(intent);</span><br><span class="line">            <span class="keyword">if</span> (serviceInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">                createService(intent, serviceInfo);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Service service = sServiceMap.get(className);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 获得传入参数的类信息</span></span><br><span class="line">    Class&lt;?&gt;[] argClass = <span class="keyword">new</span> Class&lt;?&gt;[args.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">        argClass[i] = args[i].getClass();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 反射调用服务的函数</span></span><br><span class="line">    Method method = ReflectUtil.getMethod(className, methodName, argClass);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object result = method.invoke(service, args);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际服务只是一个普通的对象，反射调用其方法即可，至于跨进程的Binder机制其实由代理服务完成了，这里还是只做了一个分发而已</p><h2 id="插件ContentProvider"><a href="#插件ContentProvider" class="headerlink" title="插件ContentProvider"></a>插件ContentProvider</h2><p>ContentProvider的初始化在Application启动时，比<code>onCreate()</code>还要早，所以可以在<code>attachBaseContext()</code>中进行插件ContentProvider的安装</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">installContentProvider</span><span class="params">(File apkFile)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 获得PackageParser类 调用parsePackage()方法获得Package</span></span><br><span class="line">        Class&lt;?&gt; packageParserClass = ReflectUtil.getClass(<span class="string">"android.content.pm.PackageParser"</span>);</span><br><span class="line">        Object packageParser;</span><br><span class="line">        packageParser = packageParserClass.newInstance();</span><br><span class="line">        Method parsePackage = ReflectUtil.getMethod(<span class="string">"android.content.pm.PackageParser"</span>, <span class="string">"parsePackage"</span>, File.class, <span class="keyword">int</span>.class);</span><br><span class="line">        Object pack = parsePackage.invoke(packageParser, apkFile, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 获得providers字段</span></span><br><span class="line">        ArrayList providers = (ArrayList) ReflectUtil.getField(<span class="string">"android.content.pm.PackageParser$Package"</span>, <span class="string">"providers"</span>, pack);</span><br><span class="line">        List&lt;ProviderInfo&gt; providerInfos = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Object provider : providers) &#123;</span><br><span class="line">          <span class="comment">// 获得info字段</span></span><br><span class="line">            ProviderInfo providerInfo = (ProviderInfo) ReflectUtil.getField(<span class="string">"android.content.pm.PackageParser$Provider"</span>, <span class="string">"info"</span>, provider);</span><br><span class="line">          <span class="comment">// 需要修改这个 否则会出现安全异常 追踪代码即指导</span></span><br><span class="line">            providerInfo.applicationInfo = getApplicationInfo();</span><br><span class="line">            providerInfos.add(providerInfo);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 获得ActivityThread的installContentProviders()方法</span></span><br><span class="line">      <span class="comment">// 调用之安装插件ContentProvider</span></span><br><span class="line">        Method installContentProviders = ReflectUtil.getMethod(<span class="string">"android.app.ActivityThread"</span>, <span class="string">"installContentProviders"</span>, Context.class, List.class);</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; activityThreadClass = Class.forName(<span class="string">"android.app.ActivityThread"</span>);</span><br><span class="line">        Method currentActivityThreadMethod = activityThreadClass.getDeclaredMethod(<span class="string">"currentActivityThread"</span>);</span><br><span class="line">        Object currentActivityThread = currentActivityThreadMethod.invoke(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        installContentProviders.invoke(currentActivityThread, <span class="keyword">this</span>, providerInfos);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仍然可以使用分发代理的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyContentProvider</span> <span class="keyword">extends</span> <span class="title">ContentProvider</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Cursor <span class="title">query</span><span class="params">(@NonNull Uri uri, @Nullable String[] projection, @Nullable String selection, @Nullable String[] selectionArgs, @Nullable String sortOrder)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 构造实际的Uri</span></span><br><span class="line">      String newUri = <span class="string">"content:/"</span> + uri.getPath();</span><br><span class="line">      <span class="comment">// 实际的查询</span></span><br><span class="line">      <span class="keyword">return</span> getContext().getContentResolver().query(Uri.parse(newUri), projection, selection, selectionArgs, sortOrder);</span><br><span class="line">    &#125;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在清单中注册代理ContentProvider</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">provider</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:authorities</span>=<span class="string">"com.example.liuhan.plugin.ProxyContentProvider"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">".ProxyContentProvider"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:exported</span>=<span class="string">"true"</span> /&gt;</span></span><br></pre></td></tr></table></figure><h2 id="插件资源"><a href="#插件资源" class="headerlink" title="插件资源"></a>插件资源</h2><p>不做处理无法加载插件资源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initResource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String apkPath = getExternalFilesDir(<span class="keyword">null</span>) + File.separator + <span class="string">"plugin"</span> + File.separator + <span class="string">"plugin.apk"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mAssetManager = AssetManager.class.newInstance();</span><br><span class="line">        Method addAssetPathMethod = mAssetManager.getClass().getDeclaredMethod(<span class="string">"addAssetPath"</span>, String.class);</span><br><span class="line">        addAssetPathMethod.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        addAssetPathMethod.invoke(mAssetManager, apkPath);</span><br><span class="line"></span><br><span class="line">        Method ensureStringBlocks = AssetManager.class.getDeclaredMethod(<span class="string">"ensureStringBlocks"</span>);</span><br><span class="line">        ensureStringBlocks.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        ensureStringBlocks.invoke(mAssetManager);</span><br><span class="line"></span><br><span class="line">        Resources supResource = getResources();</span><br><span class="line">        mResource = <span class="keyword">new</span> Resources(mAssetManager, supResource.getDisplayMetrics(), supResource.getConfiguration());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在插件的Activity内，处理资源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AssetManager <span class="title">getAssets</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mAssetManager == <span class="keyword">null</span> ? <span class="keyword">super</span>.getAssets() : mAssetManager;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Resources <span class="title">getResources</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mResource == <span class="keyword">null</span> ? <span class="keyword">super</span>.getResources() : mResource;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>插件Activity如果继承自AppCompatActivity，主题还是有问题……</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现在的应用功能越来越多，代码膨胀，应用体积太大，为解耦模块方便开发，插件化有其必要性&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://lakeshire.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://lakeshire.github.io/tags/Android/"/>
    
      <category term="插件化" scheme="http://lakeshire.github.io/tags/%E6%8F%92%E4%BB%B6%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>DLNA开源库——Cling</title>
    <link href="http://lakeshire.github.io/2017/12/12//archivers/dlna-cling/"/>
    <id>http://lakeshire.github.io/2017/12/12//archivers/dlna-cling/</id>
    <published>2017-12-12T04:00:00.000Z</published>
    <updated>2017-12-12T10:27:25.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="DLNA开源库——Cling"><a href="#DLNA开源库——Cling" class="headerlink" title="DLNA开源库——Cling"></a>DLNA开源库——Cling</h2><p>目前主流的智能网络设备解决方案有<code>DLNA</code>，<code>AirPlay</code> ，<code>Miracast</code></p><p>DLNA的全称是<code>Digital Living Network Alliance</code>(数字生活网络联盟)，旨在解决个人PC，消费电器，移动设备在内的无线网络和有线网络的互联互通</p><a id="more"></a><p>DLNA将其整个应用规定成5个功能组件，从下到上依次为：</p><ol><li>网络互连：802.3以太网，802.11WiFi，802.15蓝牙</li><li>网络协议：IPV4</li><li>设备的发现控制和管理：UPnP</li><li>媒体传输：Http</li><li>媒体格式</li></ol><p>DLNA不是一种协议，但包括了实现相关标准所需要的一系列协议栈，<code>UPnP</code>是其中的关键协议</p><h3 id="DLNA原理"><a href="#DLNA原理" class="headerlink" title="DLNA原理"></a>DLNA原理</h3><p>参考<a href="http://www.jianshu.com/p/fbc7c700cdb5" target="_blank" rel="noopener">基于DLNA的移动端网络视频投屏技术初探</a></p><p>要实现从移动端将网络视频投放至智能电视或机顶盒，首先要保证这些设备在同一个局域网的相同网段下，即共享同一个网关，这样所有设备都能够拥有独立的IP，从而具备相互通信的基础了</p><h4 id="设备发现"><a href="#设备发现" class="headerlink" title="设备发现"></a>设备发现</h4><p>当一个新的<code>Control Point)</code>加入一个局域网时，为了获取当前网段里都有哪些智能设备，需要遵循<code>SSDP</code>向默认多播IP和端口发送获取信息的请求，这是一个UDP消息，所以建议在设备搜索过程多做几次发现请求，以免丢包带来的遗漏</p><p>控制点可以获得的信息是：有一台设备，它的IP和端口号，设备描述文档(<code>DDD</code>)在什么位置、UUID是什么</p><h4 id="请求设备描述文档"><a href="#请求设备描述文档" class="headerlink" title="请求设备描述文档"></a>请求设备描述文档</h4><p><code>DDD</code>以及后面要说到的服务描述文档 (<code>SDD, Service Description Document</code>)都是以XML格式返回给请求端的，这一步的通信则是基于TCP /HTTP进行可靠传输的。我们请求<code>Location</code>字段的内容即</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://10.2.9.152:49152/TxMediaRenderer_desc.xml</span><br></pre></td></tr></table></figure><p>响应</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">root</span> <span class="attr">xmlns</span>=<span class="string">"urn:schemas-upnp-org:device-1-0"</span> <span class="attr">xmlns:dlna</span>=<span class="string">"urn:schemas-dlna-org:device-1-0"</span> <span class="attr">configId</span>=<span class="string">"499354"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">specVersion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">major</span>&gt;</span>1<span class="tag">&lt;/<span class="name">major</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">minor</span>&gt;</span>1<span class="tag">&lt;/<span class="name">minor</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">specVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">device</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">deviceType</span>&gt;</span>urn:schemas-upnp-org:device:MediaRenderer:1<span class="tag">&lt;/<span class="name">deviceType</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">friendlyName</span>&gt;</span>我的设备<span class="tag">&lt;/<span class="name">friendlyName</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">manufacturer</span>&gt;</span>Plutinosoft LLC<span class="tag">&lt;/<span class="name">manufacturer</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">manufacturerURL</span>&gt;</span>http://www.plutinosoft.com<span class="tag">&lt;/<span class="name">manufacturerURL</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">modelDescription</span>&gt;</span>Plutinosoft AV Media Renderer Device<span class="tag">&lt;/<span class="name">modelDescription</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">modelName</span>&gt;</span>AV Renderer Device<span class="tag">&lt;/<span class="name">modelName</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">modelURL</span>&gt;</span>http://www.plutinosoft.com/platinum<span class="tag">&lt;/<span class="name">modelURL</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">UDN</span>&gt;</span>uuid:9c443d47158b-dmr<span class="tag">&lt;/<span class="name">UDN</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dlna:X_DLNADOC</span> <span class="attr">xmlns:dlna</span>=<span class="string">"urn:schemas-dlna-org:device-1-0"</span>&gt;</span>DMR-1.50<span class="tag">&lt;/<span class="name">dlna:X_DLNADOC</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">serviceList</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">service</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">serviceType</span>&gt;</span>urn:schemas-upnp-org:service:AVTransport:1<span class="tag">&lt;/<span class="name">serviceType</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">serviceId</span>&gt;</span>urn:upnp-org:serviceId:AVTransport<span class="tag">&lt;/<span class="name">serviceId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">SCPDURL</span>&gt;</span>/AVTransport/9c443d47158b-dmr/scpd.xml<span class="tag">&lt;/<span class="name">SCPDURL</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">controlURL</span>&gt;</span>/AVTransport/9c443d47158b-dmr/control.xml<span class="tag">&lt;/<span class="name">controlURL</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">eventSubURL</span>&gt;</span>/AVTransport/9c443d47158b-dmr/event.xml<span class="tag">&lt;/<span class="name">eventSubURL</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">service</span>&gt;</span></span><br><span class="line">            ...</span><br><span class="line">        <span class="tag">&lt;/<span class="name">serviceList</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">device</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br></pre></td></tr></table></figure><p>返回设备的详细信息：设备名称、设备类型、UUID、服务列表，每个服务都有<code>serviceType</code>，<code>SCPDURL</code>，<code>serviceId</code>， <code>controlURL</code>和<code>eventSubURL</code></p><h4 id="请求服务描述文档"><a href="#请求服务描述文档" class="headerlink" title="请求服务描述文档"></a>请求服务描述文档</h4><p>如何使用这个服务需要参考该服务的<code>SDD</code>。<code>SCPDURL</code>这个字段的内容就是请求<code>SDD</code>的路径地址，我们将其与之前在发现设备阶段获取到的响应消息中的Location字段内容中设备的IP和端口号拿过来，拼接成完整URL字符串</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://10.2.9.152:49152/AVTransport/9c443d47158b-dmr/scpd.xml</span><br></pre></td></tr></table></figure><p>返回一个动作列表，一个服务会包含一个或多个功能请求动作</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">scpd</span> <span class="attr">xmlns</span>=<span class="string">"urn:schemas-upnp-org:service-1-0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">specVersion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">major</span>&gt;</span>1<span class="tag">&lt;/<span class="name">major</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">minor</span>&gt;</span>0<span class="tag">&lt;/<span class="name">minor</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">specVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">actionList</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>SetAVTransportURI<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">argumentList</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">argument</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">name</span>&gt;</span>InstanceID<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">direction</span>&gt;</span>in<span class="tag">&lt;/<span class="name">direction</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">relatedStateVariable</span>&gt;</span>A_ARG_TYPE_InstanceID<span class="tag">&lt;/<span class="name">relatedStateVariable</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">argument</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">argument</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">name</span>&gt;</span>CurrentURI<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">direction</span>&gt;</span>in<span class="tag">&lt;/<span class="name">direction</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">relatedStateVariable</span>&gt;</span>AVTransportURI<span class="tag">&lt;/<span class="name">relatedStateVariable</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">argument</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">argument</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">name</span>&gt;</span>CurrentURIMetaData<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">direction</span>&gt;</span>in<span class="tag">&lt;/<span class="name">direction</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">relatedStateVariable</span>&gt;</span>AVTransportURIMetaData<span class="tag">&lt;/<span class="name">relatedStateVariable</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">argument</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">argumentList</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">actionList</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">serviceStateTable</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">stateVariable</span> <span class="attr">sendEvents</span>=<span class="string">"no"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>AVTransportURI<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataType</span>&gt;</span>string<span class="tag">&lt;/<span class="name">dataType</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">stateVariable</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">serviceStateTable</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">scpd</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如<code>SetAVTransportURI</code>这个请求的功能是将一个音视频资源的URI发送给渲染端。一个<code>Action</code>就好比一个API请求，你还需要传递一些要求的参数，这时就会用到该Action后面参数列表里规定的参数</p><h4 id="服务动作请求"><a href="#服务动作请求" class="headerlink" title="服务动作请求"></a>服务动作请求</h4><p>有了动作所需要的全部信息，就可以按照DLNA规定的方式发给设备请求服务</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">POST /AVTransport/9c443d47158b-dmr/control.xml HTTP/1.1</span><br><span class="line">HOST: 10.2.9.152</span><br><span class="line">Content-Type: text/xml; charset="utf-8"</span><br><span class="line">SOAPAction: "urn:schemas-upnp-org:service:AVTransport:1#SetAVTransportURI"</span><br><span class="line">&lt;?xml version="1.0"?&gt;</span><br><span class="line">    <span class="tag">&lt;<span class="name">s:Envelope</span> <span class="attr">xmlns:s</span>=<span class="string">"http://schemas.xmlsoap.org/soap/envelope/"</span> <span class="attr">s:encodingStyle</span>=<span class="string">"http://schemas.xmlsoap.org/soap/encoding/"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">s:Body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">u:SetAVTransportURI</span> <span class="attr">xmlns:u</span>=<span class="string">"urn:schemas-upnp-org:service:AVTransport:1"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">InstanceID</span>&gt;</span>0<span class="tag">&lt;/<span class="name">InstanceID</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">CurrentURI</span>&gt;</span>yourAVURI<span class="tag">&lt;/<span class="name">CurrentURI</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">u:SetAVTransportURI</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">s:Body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">s:Envelope</span>&gt;</span></span><br></pre></td></tr></table></figure><p>响应</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: text/xml; charset="utf-8"</span><br><span class="line">Date: Thu, 16 Feb 2017 09:09:45 GMT</span><br><span class="line">Server: OS/version UPnP/1.1 product/version</span><br><span class="line">&lt;?xml version="1.0"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">s:Envelope</span> <span class="attr">xmlns:s</span>=<span class="string">"http://schemas.xmlsoap.org/soap/envelope/"</span> <span class="attr">s:encodingStyle</span>=<span class="string">"http://schemas.xmlsoap.org/soap/encoding/"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">s:Body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">u:SetAVTransportURI</span> <span class="attr">xmlns:u</span>=<span class="string">"urn:schemas-upnp-org:service:AVTransport:1"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">u:SetAVTransportURIResponse</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">_xmlns:u</span>&gt;</span>"urn:schemas-upnp-org:service:AVTransport:1"<span class="tag">&lt;/<span class="name">_xmlns:u</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">u:SetAVTransportURIResponse</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">u:SetAVTransportURI</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">s:Body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">s:Envelope</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="UPnP工作原理"><a href="#UPnP工作原理" class="headerlink" title="UPnP工作原理"></a>UPnP工作原理</h3><p>UPnP的工作分为6个步骤……</p><h4 id="寻址"><a href="#寻址" class="headerlink" title="寻址"></a>寻址</h4><p>当设备首次与网络建立连接后，利用DHCP服务，使设备得到一个IP地址。这个IP地址可以是DHCP系统指定的，也可以是由设备选择的。设备还可以使用Friendly Name，这就需要DNS来转换得到IP</p><h4 id="发现"><a href="#发现" class="headerlink" title="发现"></a>发现</h4><p>当一个设备被添加到网络后，UPnP的发现协议允许该设备向网络上的控制点(Control Point, CP)通知自己拥有的服务。同样，当一个CP被添加到网络后，UPnP发现协议允许该CP搜索网络上可用的设备。这两种情况下的组播消息一般是设备和服务的基本信息，如设备类型，唯一标识符，状态参数等等。要注意设备信息和服务信息都是要组播出去的</p><p>发现过程使用的协议是SSDP(Simple Service Discovery Protocol，简单服务发现协议)，采用UDP传输</p><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>描述分为两部分：一个是设备描述，另一个是服务描述</p><h4 id="控制"><a href="#控制" class="headerlink" title="控制"></a>控制</h4><p>在设备描述部分，还有关于如何控制设备的描述，会给出一个Control URL，CP可以向这个URL发送不同的控制信息就可以控制了，然后设备也可以返回一个信息反馈。</p><p>这种CP和设备之间沟通信息按照SOAP(Simple Object Access Protocol)的格式来写。消息体里面就可以写想调用的动作了，叫做Action Invocation，可能还要传参数，比如想播放一个视频，要把视频的URL传过去，设备收到后会响应，表示能不能执行调用，出错的话会返回一个错误代码</p><h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><p>在服务进行的整个时间内，只要变量值发生了变化或者模式的状态发生了改变，就产生了一个事件，该事件服务提供者(某设备的某个服务)会把该事件向整个网络进行多播。而且，CP也可以事先向事件服务器订阅事件信息，保证将该CP感兴趣的事件及时准确地单播传送过来</p><p>事件的订阅和推送这块用的通信协议是General Event Notification Architecture(GENA)，通过HTTP/TCP/IP传送。订阅过程如下：</p><ol><li>订阅。Subscriber发送订阅消息主要包含事件URL，服务ID号，这两个可以在设备服务描述信息中找到，以及寄送URL，还会包含一个订阅期限Duration</li><li>成功订阅。Publisher收到订阅信息，如果同意订阅的话就会为每个新Subscriber生成一个唯一的ID并记录Subscriber的Duration和Delivery URL。还会记录一个顺序增长EventKey用来保证事件确实推送到Subscriber那里</li><li>首次推送。订阅同意订阅之后还会向Subscriber发送一组初始变量或状态值，进行首次同步</li><li>续订。Subscriber必须在订阅到期前发送Renewal续订</li><li>订阅到期。订阅到期后Publisher会把Subscriber的信息删除，Subscriber又回到订阅前的状态。</li><li>退订。Subscriber发送Cancel信息将会取消订阅。Subscriber因非正常退出网络的话，则不会退订直到订阅到期</li><li>订阅操作失败信息。当订阅、续订和退订不能被Publisher接收或者出现错误时，Publisher会发送一个错误代码</li></ol><h4 id="表达"><a href="#表达" class="headerlink" title="表达"></a>表达</h4><p>只要得到了设备的URL，就可以取得该设备表达的URL，取得该设备表达的HTML，然后可以将此HTML纳入CP的本地浏览器上。这部分还包括与用户对话的界面，以及与用户进行会话的处理。因此设备表达可以理解成“遥控器”。这部分定义描述界面，规范界面以及传输界面内容。远程界面是供CP用户使用的，CP用户通过远程界面完成设备描述的获取，控制设备，订阅收取设备事件等等</p><h3 id="Cling"><a href="#Cling" class="headerlink" title="Cling"></a>Cling</h3><p>Cling类库是由JAVA实现的DLNA/UPnP协议栈</p><h4 id="重要组件"><a href="#重要组件" class="headerlink" title="重要组件"></a>重要组件</h4><h5 id="UpnpService"><a href="#UpnpService" class="headerlink" title="UpnpService"></a>UpnpService</h5><p>通过<code>UpnpService</code>接口获得<code>ControlPoint</code>，基于<code>ControlPoint</code>进行操作</p><p><em>UpnpService.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UpnpService</span> </span>&#123;</span><br><span class="line">   <span class="function">UpnpServiceConfiguration <span class="title">getConfiguration</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function">ControlPoint <span class="title">getControlPoint</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function">ProtocolFactory <span class="title">getProtocolFactory</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function">Registry <span class="title">getRegistry</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function">Router <span class="title">getRouter</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要提供控制点、协议工厂、注册表、路由和配置信息，<code>UpnpServiceImpl</code>是<code>UpnpService</code>的实现类</p><h5 id="ControlPoint"><a href="#ControlPoint" class="headerlink" title="ControlPoint"></a>ControlPoint</h5><p><em>ControlPoint.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ControlPoint</span> </span>&#123;</span><br><span class="line">    <span class="function">UpnpServiceConfiguration <span class="title">getConfiguration</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">ProtocolFactory <span class="title">getProtocolFactory</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Registry <span class="title">getRegistry</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(UpnpHeader searchType)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> mxSeconds)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(UpnpHeader searchType, <span class="keyword">int</span> mxSeconds)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(ActionCallback callback)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(SubscriptionCallback callback)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要包含搜索和执行命令两个功能</p><h5 id="UpnpServiceConfiguration"><a href="#UpnpServiceConfiguration" class="headerlink" title="UpnpServiceConfiguration"></a>UpnpServiceConfiguration</h5><p> UPnP协议栈的配置信息，<code>AndroidUpnpServiceConfiguration</code>是Android平台上的实现类，继承了<code>DefaultUpnpServiceConfiguration</code></p><h5 id="ProtocoFactory"><a href="#ProtocoFactory" class="headerlink" title="ProtocoFactory"></a>ProtocoFactory</h5><p>UPnP协议的工厂类，用于根据收到的协议或是本地设备的信息，创建一个可执行的协议</p><h5 id="Registry"><a href="#Registry" class="headerlink" title="Registry"></a>Registry</h5><p>设备资源管理器，用于设备、资源、订阅消息的管理，包括添加、更新、移除、查询</p><h4 id="情景分析"><a href="#情景分析" class="headerlink" title="情景分析"></a>情景分析</h4><h5 id="搜索设备"><a href="#搜索设备" class="headerlink" title="搜索设备"></a>搜索设备</h5><p><code>ControlPoint()</code>进行<code>search()</code>，需要两个东西：</p><ol><li>通过<code>UpnpServiceConfiguration.getAsyncProtocolExecutor()</code>获得的UPnP协议栈的异步线程池</li><li>通过<code>ProtocoFactory.createSendingSearch()</code>获得的执行内容即搜索动作</li></ol><p>得到的搜索命令就是<code>SendingSearch</code></p><p><em>SendingSearch.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    OutgoingSearchRequest msg = <span class="keyword">new</span> OutgoingSearchRequest(searchTarget, getMxSeconds());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; getBulkRepeat(); i++) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            getUpnpService().getRouter().send(msg);</span><br><span class="line">            Thread.sleep(getBulkIntervalMilliseconds());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">      </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 可见搜索就是是构造了一个<code>OutgoingSearchRequest</code>，它是一个<code>OutgoingDatagramMessage</code>，可见是一个UDP数据报消息，然后循环发送了若干次</p><p><code>Router.send()</code> 开始了网络传输过程</p><p><em>RouterImpl.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(OutgoingDatagramMessage msg)</span></span>&#123;</span><br><span class="line">   <span class="keyword">for</span> (DatagramIO datagramIO : getDatagramIOs().values()) &#123;</span><br><span class="line">      datagramIO.send(msg);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在所有的UDP端口上发送消息</p><p><em>DatagramIOImpl.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(OutgoingDatagramMessage message)</span></span>&#123;</span><br><span class="line">    DatagramPacket packet = datagramProcessor.write(message);</span><br><span class="line">    send(packet);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先由<code>DatagramProcessor</code>  把传入的<code>OutgoingDatagramMessage</code>转化成了一个<code>DatagramPacket</code>，然后发送出去</p><p><em>DatagramIOImpl.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(DatagramPacket datagram)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        socket.send(datagram);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">       </span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用了<code>DatagramSocket.send()</code>发送消息</p><p><code>DatagramIOImpl</code> 是一个<code>Runnable</code>，在运行时一直接收数据报</p><p><em>DatagramIOImpl.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[getConfiguration().getMaxDatagramBytes()];</span><br><span class="line">          DatagramPacket datagram = <span class="keyword">new</span> DatagramPacket(buf, buf.length);</span><br><span class="line">          socket.receive(datagram);</span><br><span class="line">          router.received(datagramProcessor.read(localAddress.getAddress(), datagram));</span><br><span class="line">      &#125; <span class="keyword">catch</span> (SocketException ex) &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (UnsupportedDataException ex) &#123;</span><br><span class="line">        </span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!socket.isClosed()) &#123;</span><br><span class="line">            socket.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>DatagramSocket.receive()</code>接收数据报，<code>Router.received()</code>处理接收的数据报</p><p><em>RouterImpl.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">received</span><span class="params">(IncomingDatagramMessage msg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ReceivingAsync protocol = getProtocolFactory().createReceivingAsync(msg);</span><br><span class="line">        <span class="keyword">if</span> (protocol == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;    </span><br><span class="line">        getConfiguration().getAsyncProtocolExecutor().execute(protocol);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ProtocolCreationException ex) &#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>ProtocolFactory.createReceivingAsync()</code>创建一个异步消息，并放入异步线程池中</p><p><em>ProtocolFactory.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ReceivingAsync <span class="title">createReceivingAsync</span><span class="params">(IncomingDatagramMessage message)</span> <span class="keyword">throws</span> ProtocolCreationException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (message.getOperation() <span class="keyword">instanceof</span> UpnpRequest) &#123;</span><br><span class="line">        IncomingDatagramMessage&lt;UpnpRequest&gt; incomingRequest = message;</span><br><span class="line">        <span class="keyword">switch</span> (incomingRequest.getOperation().getMethod()) &#123;</span><br><span class="line">            <span class="keyword">case</span> NOTIFY:</span><br><span class="line">                <span class="keyword">return</span> isByeBye(incomingRequest) || isSupportedServiceAdvertisement(incomingRequest) ? <span class="keyword">new</span> ReceivingNotification(getUpnpService(), incomingRequest) : <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">case</span> MSEARCH:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> ReceivingSearch(getUpnpService(), incomingRequest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (message.getOperation() <span class="keyword">instanceof</span> UpnpResponse) &#123;</span><br><span class="line">        IncomingDatagramMessage&lt;UpnpResponse&gt; incomingResponse = message;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ReceivingSearchResponse(getUpnpService(), incomingResponse);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ProtocolCreationException(<span class="string">"Protocol for incoming datagram message not found: "</span> + message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据消息是UPnP请求还是UPnP响应，创建不同的接受消息<code>ReceivingNotification</code>/<code>ReceivingSearch</code>/<code>ReceivingSearchResponse</code>，这里是接收的<code>ReceivingSearchResponse</code>（搜索响应，不是搜索命令）</p><p><em>ReceivingSearchResponse</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (getInputMessage().getHeaders().containsKey(<span class="string">"Easylink"</span>)) &#123;</span><br><span class="line">        matchEasylink(getInputMessage());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!getInputMessage().isSearchResponseMessage()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    UDN udn = getInputMessage().getRootDeviceUDN();</span><br><span class="line">    <span class="keyword">if</span> (udn == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    RemoteDeviceIdentity rdIdentity = <span class="keyword">new</span> RemoteDeviceIdentity(getInputMessage());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (getUpnpService().getRegistry().update(rdIdentity)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    RemoteDevice rd;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        rd = <span class="keyword">new</span> RemoteDevice(rdIdentity);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ValidationException ex) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (rdIdentity.getDescriptorURL() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (rdIdentity.getMaxAgeSeconds() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    getUpnpService().getConfiguration().getAsyncProtocolExecutor().execute(<span class="keyword">new</span> RetrieveRemoteDescriptors(getUpnpService(), rd));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先处理EasyLink消息，然后更新设备列表，最后发送消息请求设备描述文件</p><p><em>RegistryImpl.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">update</span><span class="params">(RemoteDeviceIdentity rdIdentity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> remoteItems.update(rdIdentity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="发送命令"><a href="#发送命令" class="headerlink" title="发送命令"></a>发送命令</h5><p><code>ControlPoint()</code>通过<code>execute()</code>发送命令，同样的，也需要两个东西：</p><ol><li>通过<code>UpnpServiceConfiguration.getSyncProtocolExecutor()</code>获得命令的同步线程池</li><li>获得命令，通常传入的<code>ActionCallback</code>就是，它是一个<code>Runnable</code></li></ol><p><em>ActionCallback.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Service service = actionInvocation.getAction().getService();</span><br><span class="line">    <span class="keyword">if</span> (service <span class="keyword">instanceof</span> LocalService) &#123;</span><br><span class="line">        LocalService localService = (LocalService) service;</span><br><span class="line">        localService.getExecutor(actionInvocation.getAction()).execute(actionInvocation);</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">if</span> (actionInvocation.getFailure() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            failure(actionInvocation, <span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            success(actionInvocation);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (service <span class="keyword">instanceof</span> RemoteService) &#123;</span><br><span class="line">        <span class="keyword">if</span> (getControlPoint() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Callback must be executed through ControlPoint"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        RemoteService remoteService = (RemoteService) service;</span><br><span class="line">        URL controLURL = remoteService.getDevice().normalizeURI(remoteService.getControlURI());</span><br><span class="line">        SendingAction prot = getControlPoint().getProtocolFactory().createSendingAction(actionInvocation, controLURL);</span><br><span class="line">        prot.run();</span><br><span class="line">      </span><br><span class="line">        IncomingActionResponseMessage response = prot.getOutputMessage();</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">if</span> (response == <span class="keyword">null</span>) &#123;</span><br><span class="line">            failure(actionInvocation, <span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (response.getOperation().isFailed()) &#123;</span><br><span class="line">            failure(actionInvocation, response.getOperation());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          success(actionInvocation);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先获得服务，如果是本地服务，就用本地的线程池执行，等待响应；如果是远程服务，拿到控制URL，构造命令发送并等待响应</p><p><code>ActionInvocation.getAction().getService()</code>如何获得服务？</p><p>是执行命令的时候由外部传入的，以播放命令为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">getControlPoint().execute(<span class="keyword">new</span> PlayActionCallback(device.getAVservice()) &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">failure</span><span class="params">(ActionInvocation invocation, UpnpResponse response, String arg2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">success</span><span class="params">(ActionInvocation invocation)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 可见是从设备获得了所需的服务，通过<code>Device.findDevice()</code> 找到对应描述的服务</p><p>然后通过<code>ProtocolFactory.createSendingAction()</code>创建发送命令，并执行</p><p><em>SendingAction.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> IncomingActionResponseMessage <span class="title">executeSync</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> invokeRemote(getInputMessage());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> IncomingActionResponseMessage <span class="title">invokeRemote</span><span class="params">(OutgoingActionRequestMessage requestMessage)</span> </span>&#123;</span><br><span class="line">    Device device = actionInvocation.getAction().getService().getDevice();</span><br><span class="line">  </span><br><span class="line">    IncomingActionResponseMessage responseMessage = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        StreamResponseMessage streamResponse = sendRemoteRequest(requestMessage);</span><br><span class="line">        <span class="keyword">if</span> (streamResponse == <span class="keyword">null</span>) &#123;</span><br><span class="line">            actionInvocation.setFailure(<span class="keyword">new</span> ActionException(ErrorCode.ACTION_FAILED, <span class="string">"Connection error or no response received"</span>));</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        responseMessage = <span class="keyword">new</span> IncomingActionResponseMessage(streamResponse);</span><br><span class="line">        <span class="keyword">if</span> (responseMessage.isFailedNonRecoverable()) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> ActionException(ErrorCode.ACTION_FAILED, <span class="string">"Non-recoverable remote execution failure: "</span> + responseMessage.getOperation().getResponseDetails());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (responseMessage.isFailedRecoverable()) &#123;</span><br><span class="line">          handleResponseFailure(responseMessage);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          handleResponse(responseMessage);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> responseMessage;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ActionException ex) &#123;</span><br><span class="line">        actionInvocation.setFailure(ex);</span><br><span class="line">        <span class="keyword">if</span> (responseMessage == <span class="keyword">null</span> || !responseMessage.getOperation().isFailed()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> IncomingActionResponseMessage(<span class="keyword">new</span> UpnpResponse(UpnpResponse.Status.INTERNAL_SERVER_ERROR));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> responseMessage;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> StreamResponseMessage <span class="title">sendRemoteRequest</span><span class="params">(OutgoingActionRequestMessage requestMessage)</span> <span class="keyword">throws</span> ActionException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        getUpnpService().getConfiguration().getSoapActionProcessor().writeBody(requestMessage, actionInvocation);</span><br><span class="line">        <span class="keyword">return</span> getUpnpService().getRouter().send(requestMessage);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedDataException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ActionException(ErrorCode.ACTION_FAILED, <span class="string">"Error writing request message. "</span> + ex.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>sendRemoteRequest()</code> 发送请求，处理结果</p><p>用SOAP处理器转换得到SOAP消息，然后发送</p><p><em>RouteImpl.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> StreamResponseMessage <span class="title">send</span><span class="params">(StreamRequestMessage msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (getStreamClient() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> getStreamClient().sendRequest(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>StreamClientImpl.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> StreamResponseMessage <span class="title">sendRequest</span><span class="params">(StreamRequestMessage requestMessage)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> UpnpRequest requestOperation = requestMessage.getOperation();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        HttpUriRequest httpRequest = createHttpRequest(requestMessage, requestOperation);</span><br><span class="line">        HttpParams requestParams = getRequestParams(requestMessage);</span><br><span class="line">        HttpConnectionParams.setConnectionTimeout(requestParams, <span class="number">20000</span>);</span><br><span class="line">        HttpConnectionParams.setSoTimeout(requestParams, <span class="number">20000</span>);</span><br><span class="line">        httpRequest.setParams(requestParams);</span><br><span class="line">        HeaderUtil.add(httpRequest, requestMessage.getHeaders());</span><br><span class="line">        <span class="keyword">return</span> httpClient.execute(httpRequest, createResponseHandler());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (MethodNotSupportedException ex) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClientProtocolException ex) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建请求，添加参数并调用<code>HttpClient.execute()</code> 处理，<code>createResponseHandler()</code>处理响应并返回</p><p>然后回到<code>SendingAction</code>处理返回值</p><p><em>SendingAction.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">handleResponse</span><span class="params">(IncomingActionResponseMessage responseMsg)</span> <span class="keyword">throws</span> ActionException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        getUpnpService().getConfiguration().getSoapActionProcessor().readBody(responseMsg, actionInvocation);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedDataException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ActionException(ErrorCode.ACTION_FAILED, <span class="string">"Error reading response message. "</span> + ex.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">handleResponseFailure</span><span class="params">(IncomingActionResponseMessage responseMsg)</span> <span class="keyword">throws</span> ActionException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        getUpnpService().getConfiguration().getSoapActionProcessor().readBody(responseMsg, actionInvocation);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedDataException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ActionException(ErrorCode.ACTION_FAILED, <span class="string">"Error reading response failure message. "</span> + ex.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用SOAP处理器读取响应体，最终通过<code>ActionInvocation.setOutput()</code>将解析得到的响应字段设置到<code>ActionInvocation</code> 里</p><p>总结：</p><ol><li>获得信息，构造命令</li><li>通过SOAP处理器转换为SOAP消息</li><li>通过Http发送消息</li><li>接受Http响应消息</li><li>通过SOAP处理器解析SOAP消息</li><li>将解析的字段回传</li></ol><h5 id="订阅事件"><a href="#订阅事件" class="headerlink" title="订阅事件"></a>订阅事件</h5><p><code>ControlPoint()</code>通过<code>execute()</code>订阅事件</p><ol><li>通过<code>UpnpServiceConfiguration.getSyncProtocolExecutor()</code>获得同步线程池</li><li>传入<code>SubscriptionCallback</code></li></ol><p><em>SubscriptionCallback.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (getControlPoint() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Callback must be executed through ControlPoint"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (getService() <span class="keyword">instanceof</span> LocalService) &#123;</span><br><span class="line">        establishLocalSubscription((LocalService) service);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (getService() <span class="keyword">instanceof</span> RemoteService) &#123;</span><br><span class="line">        establishRemoteSubscription((RemoteService) service);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">establishRemoteSubscription</span><span class="params">(RemoteService service)</span> </span>&#123;</span><br><span class="line">    RemoteGENASubscription remoteSubscription = <span class="keyword">new</span> RemoteGENASubscription(service, requestedDurationSeconds) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(UpnpResponse responseStatus)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (SubscriptionCallback.<span class="keyword">this</span>) &#123;</span><br><span class="line">                SubscriptionCallback.<span class="keyword">this</span>.setSubscription(<span class="keyword">null</span>);</span><br><span class="line">                SubscriptionCallback.<span class="keyword">this</span>.failed(<span class="keyword">this</span>, responseStatus, <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">established</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (SubscriptionCallback.<span class="keyword">this</span>) &#123;</span><br><span class="line">                SubscriptionCallback.<span class="keyword">this</span>.setSubscription(<span class="keyword">this</span>);</span><br><span class="line">                SubscriptionCallback.<span class="keyword">this</span>.established(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ended</span><span class="params">(CancelReason reason, UpnpResponse responseStatus)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (SubscriptionCallback.<span class="keyword">this</span>) &#123;</span><br><span class="line">                SubscriptionCallback.<span class="keyword">this</span>.setSubscription(<span class="keyword">null</span>);</span><br><span class="line">                SubscriptionCallback.<span class="keyword">this</span>.ended(<span class="keyword">this</span>, reason, responseStatus);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eventReceived</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (SubscriptionCallback.<span class="keyword">this</span>) &#123;</span><br><span class="line">                SubscriptionCallback.<span class="keyword">this</span>.eventReceived(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eventsMissed</span><span class="params">(<span class="keyword">int</span> numberOfMissedEvents)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (SubscriptionCallback.<span class="keyword">this</span>) &#123;</span><br><span class="line">                SubscriptionCallback.<span class="keyword">this</span>.eventsMissed(<span class="keyword">this</span>, numberOfMissedEvents);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    getControlPoint().getProtocolFactory().createSendingSubscribe(remoteSubscription).run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造一个GENA订阅回调，通过<code>ProtocolFactory.createSendingSubscribe()</code> 创建订阅消息并发送</p><p><em>SendingSubscribe.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> IncomingSubscribeResponseMessage <span class="title">executeSync</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!getInputMessage().hasCallbackURLs()) &#123;         </span><br><span class="line">        getUpnpService().getConfiguration().getRegistryListenerExecutor().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                subscription.fail(<span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">try</span> &#123;          </span><br><span class="line">        getUpnpService().getRegistry().lockRemoteSubscriptions();</span><br><span class="line">        StreamResponseMessage response = getUpnpService().getRouter().send(getInputMessage());  </span><br><span class="line">        <span class="keyword">if</span> (response == <span class="keyword">null</span>) &#123;</span><br><span class="line">            getUpnpService().getConfiguration().getRegistryListenerExecutor().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">              <span class="meta">@Override</span></span><br><span class="line">              <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                  subscription.fail(<span class="keyword">null</span>);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> IncomingSubscribeResponseMessage responseMessage = <span class="keyword">new</span> IncomingSubscribeResponseMessage(response);</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">if</span> (response.getOperation().isFailed()) &#123;            </span><br><span class="line">            getUpnpService().getConfiguration().getRegistryListenerExecutor().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;                           </span><br><span class="line">                    subscription.fail(responseMessage.getOperation());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!responseMessage.isVaildHeaders()) &#123;           </span><br><span class="line">            getUpnpService().getConfiguration().getRegistryListenerExecutor().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;                           </span><br><span class="line">                    subscription.fail(responseMessage.getOperation());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;           </span><br><span class="line">            subscription.setSubscriptionId(responseMessage.getSubscriptionId());            </span><br><span class="line">            subscription.setActualSubscriptionDurationSeconds(responseMessage.getSubscriptionDurationSeconds());       </span><br><span class="line">            getUpnpService().getRegistry().addRemoteSubscription(subscription);            </span><br><span class="line">            getUpnpService().getConfiguration().getRegistryListenerExecutor().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    subscription.establish();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> responseMessage;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;        </span><br><span class="line">        getUpnpService().getRegistry().unlockRemoteSubscriptions();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用<code>Router.send()</code>发送订阅消息，并接收响应，通过<code>Registry.addRemoteSubscription()</code>添加订阅</p><h5 id="接收消息"><a href="#接收消息" class="headerlink" title="接收消息"></a>接收消息</h5><p>UDP数据报的接收上面说过了，这里看Http数据流</p><p><code>SteamServer</code>接口描述了接收Http数据流的能力，<code>SteamServerImpl</code>是其实现类</p><p>创建监听Socket，通过<code>accept()</code>接收连接，并创建新的通信Socket</p><p><em>StreamServerImpl.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UpnpStream connectionStream = <span class="keyword">new</span> HttpServerConnectionUpnpStream(router.getProtocolFactory(), httpServerConnection, globalParams);</span><br><span class="line">router.received(connectionStream);</span><br></pre></td></tr></table></figure><p>从连接中得到一个UpnpStream，交给Router，放到同步线程池中执行</p><p><em>Router.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">received</span><span class="params">(UpnpStream stream)</span></span>&#123;</span><br><span class="line">    getConfiguration().getSyncProtocolExecutor().execute(stream);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>HttpServerConnectionUpnpStream.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    httpService.handleRequest(connection, context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>UpnpHttpService.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doService</span><span class="params">(HttpRequest httpRequest, HttpResponse httpResponse, HttpContext ctx)</span> <span class="keyword">throws</span> HttpException, IOException </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    responseMsg = process(requestMessage);</span><br><span class="line">    ...</span><br><span class="line">    responseSent(responseMsg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>UpnpStream.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> StreamResponseMessage <span class="title">process</span><span class="params">(StreamRequestMessage requestMsg)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    syncProtocol = getProtocolFactory().createReceivingSync(requestMsg);</span><br><span class="line">    syncProtocol.run();</span><br><span class="line">    StreamResponseMessage responseMsg = syncProtocol.getOutputMessage();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>ProtocolFactoryImpl.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ReceivingSync <span class="title">createReceivingSync</span><span class="params">(StreamRequestMessage message)</span> <span class="keyword">throws</span> ProtocolCreationException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (message.getOperation().getMethod().equals(UpnpRequest.Method.GET)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ReceivingRetrieval(getUpnpService(), message);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (getUpnpService().getConfiguration().getNamespace().isControlPath(message.getUri())) &#123;</span><br><span class="line">        <span class="keyword">if</span> (message.getOperation().getMethod().equals(UpnpRequest.Method.POST))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ReceivingAction(getUpnpService(), message);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (getUpnpService().getConfiguration().getNamespace().isEventSubscriptionPath(message.getUri())) &#123;</span><br><span class="line">        <span class="keyword">if</span> (message.getOperation().getMethod().equals(UpnpRequest.Method.SUBSCRIBE)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ReceivingSubscribe(getUpnpService(), message);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (message.getOperation().getMethod().equals(UpnpRequest.Method.UNSUBSCRIBE)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ReceivingUnsubscribe(getUpnpService(), message);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (getUpnpService().getConfiguration().getNamespace().isEventCallbackPath(message.getUri())) &#123;</span><br><span class="line">        <span class="keyword">if</span> (message.getOperation().getMethod().equals(UpnpRequest.Method.NOTIFY))</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> ReceivingEvent(getUpnpService(), message);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ProtocolCreationException(<span class="string">"Protocol for message type not found: "</span> + message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据UPNP消息头构造不同的接收消息</p><p>以收到事件为例</p><p><em>ReceivingEvent.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> OutgoingEventResponseMessage <span class="title">executeSync</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    getUpnpService().getConfiguration().getGenaEventProcessor().readBody(requestMessage);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">final</span> RemoteGENASubscription subscription = getUpnpService().getRegistry().getRemoteSubscription(requestMessage.getSubscrptionId());</span><br><span class="line">    getUpnpService().getConfiguration().getRegistryListenerExecutor().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            subscription.receive(requestMessage.getSequence(), requestMessage.getStateVariableValues());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;                                                                      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终通知到注册的监听器上</p><h4 id="重要的类"><a href="#重要的类" class="headerlink" title="重要的类"></a>重要的类</h4><h5 id="UpnpOperation"><a href="#UpnpOperation" class="headerlink" title="UpnpOperation"></a>UpnpOperation</h5><p>UPnP操作，有<code>UpnpRequest</code>和<code>UpnpResponse</code>两个子类</p><h5 id="UpnpMessage"><a href="#UpnpMessage" class="headerlink" title="UpnpMessage"></a>UpnpMessage</h5><p>UPnP消息，类结构如下：</p><ul><li><code>StreamRequestMessage</code> 请求数据流</li><li><code>StreamResponseMessage</code> 响应数据流</li><li><code>IncomingDatagramMessage</code> 接收数据报</li><li><code>OutgoingDatagramMessage</code> 发送数据报</li></ul><p>有很多具体的消息类如<br><code>OutgoingSubscribeRequestMessage</code>/<code>OutgoingSearchRequest</code>/<code>OutgoingActionRequestMessage</code>等</p><h5 id="Device"><a href="#Device" class="headerlink" title="Device"></a>Device</h5><p>设备类，有<code>LocalDevice</code>和<code>RemoteDevice</code> 两个子类，表示本地和网络设备</p><h5 id="SendingAsync"><a href="#SendingAsync" class="headerlink" title="SendingAsync"></a>SendingAsync</h5><p>异步命令，类结构如下：</p><ul><li><code>SendingSync</code> 同步命令<ul><li><code>SendingSubscribe</code></li><li><code>SendingRenewal</code></li><li><code>SendingEvent</code></li><li><code>SendingAction</code></li><li><code>SendingUnsubscribe</code></li></ul></li><li><code>SendingNotification</code>  通知<ul><li><code>SendingNotificationByebye</code></li><li><code>SendingNotificationAlive</code></li></ul></li><li><code>SendingSearch</code> 搜索</li></ul><h5 id="ReceivingAsync"><a href="#ReceivingAsync" class="headerlink" title="ReceivingAsync"></a>ReceivingAsync</h5><p>接收异步消息，类结构如下</p><ul><li><code>ReceivingSearch</code> 接收搜索请求</li><li><code>ReceivingNotification</code> 接收通知</li><li><code>ReceivingSearchResponse</code> 接收搜索响应</li><li><code>ReceivingSync</code> 接收同步消息<ul><li><code>ReceivingEvent</code></li><li><code>ReceivingAction</code></li><li><code>ReceivingSubscribe</code></li><li><code>ReceivingRetrieval</code></li><li><code>ReceivingUnsubscribe</code></li></ul></li></ul><h5 id="协议相关"><a href="#协议相关" class="headerlink" title="协议相关"></a>协议相关</h5><p><code>org.teleal.cling.transport</code>包里包含大量涉及到的协议的接口和实现类，如SOAP/GENA/TCP/UDP等</p><h5 id="应用相关"><a href="#应用相关" class="headerlink" title="应用相关"></a>应用相关</h5><p><code>org.teleal.cling.support</code>包含应用层方面的代码，可以看到一些基本的服务<code>AVTransport</code>/<code>MediaManager</code>/<code>PlayQueue</code>/<code>RenderingControl</code></p><p><code>callback</code>子目录里面都是相关命令，是<code>ActionCallback</code>的子类</p><p>还有个<code>lastchange</code>子目录，里面是XML的解析器，是<code>LastChangeParser</code>的子类，收到订阅事件时，<code>GENASubscription</code>的<code>currentValues</code>保存了一张表，里面的<code>LastChange</code>则描述了事件变化，需要用<code>LastChangeParser</code>解析，得到<code>Event</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;DLNA开源库——Cling&quot;&gt;&lt;a href=&quot;#DLNA开源库——Cling&quot; class=&quot;headerlink&quot; title=&quot;DLNA开源库——Cling&quot;&gt;&lt;/a&gt;DLNA开源库——Cling&lt;/h2&gt;&lt;p&gt;目前主流的智能网络设备解决方案有&lt;code&gt;DLNA&lt;/code&gt;，&lt;code&gt;AirPlay&lt;/code&gt; ，&lt;code&gt;Miracast&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;DLNA的全称是&lt;code&gt;Digital Living Network Alliance&lt;/code&gt;(数字生活网络联盟)，旨在解决个人PC，消费电器，移动设备在内的无线网络和有线网络的互联互通&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://lakeshire.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://lakeshire.github.io/tags/Android/"/>
    
      <category term="DLNA" scheme="http://lakeshire.github.io/tags/DLNA/"/>
    
  </entry>
  
  <entry>
    <title>蓝牙学习笔记</title>
    <link href="http://lakeshire.github.io/2017/12/06//archivers/bluetooth/"/>
    <id>http://lakeshire.github.io/2017/12/06//archivers/bluetooth/</id>
    <published>2017-12-06T04:00:00.000Z</published>
    <updated>2017-12-06T07:08:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>蓝牙是一种无线技术标准，可实现固定设备、移动设备和楼宇个域网之间的短距离数据交换，传输距离近、低功耗</p><a id="more"></a><h2 id="蓝牙学习笔记"><a href="#蓝牙学习笔记" class="headerlink" title="蓝牙学习笔记"></a>蓝牙学习笔记</h2><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p>蓝牙是一种无线技术标准，可实现固定设备、移动设备和楼宇个域网之间的短距离数据交换（使用2.4—2.485GHz的ISM波段的UHF无线电波）。蓝牙技术最初由电信巨头爱立信公司1994年创制，当时是作为RS232数据线的替代方案。蓝牙可连接多个设备，克服了数据同步的难题。蓝牙是一个标准的无线通讯协议，基于设备低成本的收发器芯片，传输距离近、低功耗</p><p>蓝牙使用跳频技术，将传输的数据分割成数据包，通过79个指定的蓝牙频道分别传输数据包。每个频道的频宽为1 MHz。蓝牙4.0使用2 MHz 间距，可容纳40个频道</p><p>最初，高斯频移键控GFSK调制是唯一可用的调制方案。然而蓝牙2.0+EDR 使得 π/4-DQPSK和8DPSK 调制在兼容设备中的使用变为可能</p><p>蓝牙是基于数据包、有着主从架构的协议。一个主设备至多可和同一微微网中的七个从设备通讯。所有设备共享主设备的时钟</p><h4 id="蓝牙Profile"><a href="#蓝牙Profile" class="headerlink" title="蓝牙Profile"></a>蓝牙Profile</h4><p>Bluetooth的一个很重要特性，就是所有的Bluetooth产品都无须实现全部的Bluetooth规范。为了更容易的保持Bluetooth设备之间的兼容，Bluetooth规范中定义了Profile。Profile定义了设备如何实现一种连接或者应用，你可以把Profile理解为连接层或者应用层协议</p><p>在所有的Profile中，有四种是基本的Profile，这些Profile会被其它的Profile使用：</p><ul><li><code>GAP</code> Generic Access Profile，该Profile保证不同的设备可以互相发现对方并建立连接，它具有强制性，并作为所有其它蓝牙应用规范的基础</li><li><code>SDAP</code>  Service Discovery Application Profile，通过该Profile，一个设备可以找到其它设备提供的服务，以及查询相关的信息</li><li><code>SPP</code> Serial Port Profile，定义了如何在两台设备之间建立虚拟串口并进行连接</li><li><code>GOEP</code> Generic Object Exchange Profile，通用对象交换。这个Profile的名字有些费解，它定义的是数据的传输，包括同步，文件传输，或者推送其它的数据。可以理解为与内容无关的传输层协议，可以被任何应用用来传输自己定义的数据对象</li><li><code>A2DP</code> Advenced Audio Distribution Profile，蓝牙音频传输模型协定。A2DP 规定了使用蓝牙非同步传输信道方式，传输高质量音乐文件数据的协议堆栈软件和使用方法，基于该协议就能通过以蓝牙方式传输高品质的音乐了。这个技术可以利用立体声蓝牙耳机来收听手机中的音乐了</li><li><code>DUN</code> Dial-up Networking Profile，实现一台蓝牙设备通过另外一个带无线功能的蓝牙设备共享上网</li><li><code>GATT</code> Generic Attribute Profile，是一个在蓝牙连接之上的发送和接收很短的数据段的通用规范，用于低功耗蓝牙BLE</li></ul><h4 id="BLE"><a href="#BLE" class="headerlink" title="BLE"></a>BLE</h4><p>BLE(Bluetooth Low Energy)，蓝牙4.0核心特性，Android4.3以上才支持，主要特点是快速搜索，快速连接，超低功耗保持连接和数据传输，缺点：数据传输速率低，由于其具有低功耗特点，所以经常用在可穿戴设备之中</p><ol><li>Profile：可以理解为一种规范，一个标准的通信协议，其存在于手机中，蓝牙组织规定了一些标准的Profile，每个Profile中包含了多个Service</li><li>Service：可以理解为一个服务，在BLE从机中有多个服务，电量信息，系统服务信息等，每一个Service中包含了多个Characteristic特征值，每一个具体的Characteristic特征值才是BLE通信的主题</li><li>Characteristic特征值：BLE主机从机通信均是通过Characteristic进行，可以将其理解为一个标签，通过该标签可以读取或写入相关信息</li><li>UUID：Service和Characteristic均需要这个唯一的UUID进行标识，识别符有通用的，也可以自定义，也可以随机生成，每一个特征都有其属性和权限<code>READ</code>/<code>WRITE</code>/<code>NOTIFY</code>/<code>INDICATE</code>，特征根据属性可读可写</li></ol><p>任何设备都可以单独作为中心或外设角色。一个没有被链接的外设角色，会向外界发出广播，这个时候可以被多个中心角色发现，一旦外设角色被某个中心角色链接后，外设角色就会停止广播，其他中心角色就无法在链接到这个外设角色。中心角色可以扫描外设角色，可以监听接收广播或主动链接，一个中心角色可以与多个外设同时链接。</p><h3 id="Android蓝牙开发"><a href="#Android蓝牙开发" class="headerlink" title="Android蓝牙开发"></a>Android蓝牙开发</h3><p>首先在AndroidManifest.xml中加入权限</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permissionandroid:name="android.permission.BLUETOOTH_ADMIN"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permissionandroid:name="android.permission.BLUETOOTH"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-feature</span> <span class="attr">android:name</span>=<span class="string">"android.hardware.bluetooth_le"</span> <span class="attr">android:required</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 当android:required为true的时候，app只能强制运行在支持BLE功能的设备商，为false的时候，可以运行在所有设备上 --&gt;</span></span><br></pre></td></tr></table></figure><h4 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h4><ul><li><code>BluetoothAdapter</code> 蓝牙适配器，可以通过它进行基础的蓝牙任务<ol><li>初始化设备发现</li><li>获得配对的设备列表</li><li>使用MAC初始化蓝牙设备</li><li>初始化Socket监听蓝牙连接</li><li>扫描BLE设备等</li></ol></li><li><code>BluetoothDevice</code> 蓝牙设备</li><li><code>BluetoothServerSocket</code> 蓝牙服务端Socket，类似TCP，服务端使用一个BluetoothServerSocket监听连接请求，接受连接后返回一个新的BluetoothSocket用于通讯，客户端使用一个单独的BluetoothSocket进行连接，最常见的蓝牙Socket是<code>RFCOMM</code>，是Android支持的，<code>RFCOMM</code>是一个蓝牙上面向连接的流传输，也被称为<code>SPP</code> </li><li><code>BluetoothSocket</code> 蓝牙客户端Socket</li></ul><h4 id="基础开发流程"><a href="#基础开发流程" class="headerlink" title="基础开发流程"></a>基础开发流程</h4><h5 id="获得蓝牙适配器"><a href="#获得蓝牙适配器" class="headerlink" title="获得蓝牙适配器"></a>获得蓝牙适配器</h5><p><code>API17</code>及以下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BluetoothAdapter mAdapter = BluetoothAdapter.getDefaultAdapter();</span><br></pre></td></tr></table></figure><p><code>API17</code>以上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BluetoothManager bm = (BluetoothManager) mContext.getSystemService(Context.BLUETOOTH_SERVICE);</span><br><span class="line">BluetoothAdapter mAdapter = bm.getAdapter();</span><br></pre></td></tr></table></figure><h5 id="打开蓝牙"><a href="#打开蓝牙" class="headerlink" title="打开蓝牙"></a>打开蓝牙</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!mBluetoothAdapter.isEnabled()) &#123;</span><br><span class="line">  <span class="comment">// 跳转到系统设置打开</span></span><br><span class="line">  Intent intent = <span class="keyword">new</span> Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE);</span><br><span class="line">  startActivityForResult(intent, REQUEST_ENABLE_BLUETOOTH);</span><br><span class="line">  <span class="comment">// 强行打开</span></span><br><span class="line">  <span class="comment">// mAdapter.enable()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="获取配对设备"><a href="#获取配对设备" class="headerlink" title="获取配对设备"></a>获取配对设备</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;BluetoothDevice&gt; devices = mBluetoothAdapter.getBondedDevices();</span><br></pre></td></tr></table></figure><h5 id="搜索设备"><a href="#搜索设备" class="headerlink" title="搜索设备"></a>搜索设备</h5><p>搜索设备得到的结果会通过广播通知，所以先注册广播接收器，然后开始搜索</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IntentFilter filter = <span class="keyword">new</span> IntentFilter();</span><br><span class="line">filter.addAction(BluetoothDevice.ACTION_FOUND);</span><br><span class="line">filter.addAction(BluetoothDevice.ACTION_BOND_STATE_CHANGED);</span><br><span class="line">filter.addAction(BluetoothAdapter.ACTION_STATE_CHANGED);</span><br><span class="line">getActivity().registerReceiver(mBluetoothReceiver, filter);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mBluetoothAdapter.startDiscovery();</span><br></pre></td></tr></table></figure><h5 id="配对"><a href="#配对" class="headerlink" title="配对"></a>配对</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">  btDev.createBond();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样在广播中检测配对状态</p><h5 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h5><p>建立连接会阻塞线程，需要在新线程中进行</p><p>服务端和客户端需要指定相同的UUID才能连接</p><p><em>服务端</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BluetoothServerSocket serverSocket = mAdapter.listenUsingRfcommWithServiceRecord(serverSocketName, UUID);</span><br><span class="line">serverSocket.accept();</span><br></pre></td></tr></table></figure><p><em>客户端</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BluetoothSocket clienSocket = dcvice.createRfcommSocketToServiceRecord(UUID);</span><br><span class="line">clienSocket.connect();</span><br></pre></td></tr></table></figure><h5 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h5><p>获取输入输出流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">inputStream = socket.getInputStream();</span><br><span class="line">outputStream = socket.getOutputStream();</span><br></pre></td></tr></table></figure><h5 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mAdapter.getProfileConnectionState(BluetoothProfile.A2DP) == BluetoothProfile.STATE_CONNECTED) &#123;</span><br><span class="line">  mAdapter.getProfileProxy(context, <span class="keyword">new</span> BluetoothProfile.ServiceListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(<span class="keyword">int</span> profile, BluetoothProfile proxy)</span> </span>&#123;</span><br><span class="line">      List&lt;BluetoothDevice&gt; devicesList = proxy.getConnectedDevices();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>getProfileConnectionState()</code>获得某种特定协议的连接状态，比如判断是不是有蓝牙音箱设备连接</p><p><code>getProfileProxy()</code>获得协议的代理对象</p><p><code>BluetoothProfile.getConnectedDevices()</code>获得该协议连接的设备</p><h4 id="BLE开发"><a href="#BLE开发" class="headerlink" title="BLE开发"></a>BLE开发</h4><h5 id="检查是否支持BLE"><a href="#检查是否支持BLE" class="headerlink" title="检查是否支持BLE"></a>检查是否支持BLE</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getPackageManager().hasSystemFeature(PackageManager.FEATURE_BLUETOOTH_LE);</span><br></pre></td></tr></table></figure><p>对于<code>6.0</code>以上，需要动态申请一个定位权限</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.checkSelfPermission(Manifest.permission.ACCESS_COARSE_LOCATION) != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">    requestPermissions(<span class="keyword">new</span> String[]&#123;Manifest.permission.ACCESS_COARSE_LOCATION&#125;, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="扫描设备"><a href="#扫描设备" class="headerlink" title="扫描设备"></a>扫描设备</h5><p>通用的搜索方法可以搜索所有的蓝牙设备，这里只扫描BLE设备</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> BluetoothAdapter.LeScanCallback mLeScanCallback= <span class="keyword">new</span> BluetoothAdapter.LeScanCallback()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLeScan</span><span class="params">(BluetoothDevice device, <span class="keyword">int</span> rssi, <span class="keyword">byte</span>[] scanRecord)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 不能执行耗时操作，不宜执行复杂运算操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这是个过时的方法，但仍可用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ScanCallback mScanCallback = <span class="keyword">new</span> ScanCallback() &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onScanResult</span><span class="params">(<span class="keyword">int</span> callbackType, ScanResult result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onScanResult(callbackType, result);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBatchScanResults</span><span class="params">(List&lt;ScanResult&gt; results)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onBatchScanResults(results);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onScanFailed</span><span class="params">(<span class="keyword">int</span> errorCode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onScanFailed(errorCode);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">mBluetoothAdapter.getBluetoothLeScanner().startScan(mScanCallback);</span><br></pre></td></tr></table></figure><p>所有搜索都会对流畅性有影响，都需要在子线程进行<br><code>Android4.3</code>开始支持BLE，<code>Android5.0</code>开始支持手机端作为从设备</p><h5 id="连接BLE设备"><a href="#连接BLE设备" class="headerlink" title="连接BLE设备"></a>连接BLE设备</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> BluetoothGattCallback mBluetoothGattCallback = <span class="keyword">new</span> BluetoothGattCallback() &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onConnectionStateChange</span><span class="params">(BluetoothGatt gatt, <span class="keyword">int</span> status, <span class="keyword">int</span> newState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onConnectionStateChange(gatt, status, newState);</span><br><span class="line">    <span class="comment">//当设备与中心连接状态发生改变时</span></span><br><span class="line">    <span class="keyword">switch</span> (status) &#123;</span><br><span class="line">      <span class="keyword">case</span> BluetoothProfile.STATE_CONNECTED:</span><br><span class="line">        <span class="comment">//这里表示已经成功连接，如果成功连接，就去发现设备所包含的服务</span></span><br><span class="line">    gatt.discoverServices();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> BluetoothProfile.STATE_DISCONNECTED:</span><br><span class="line">        <span class="comment">//表示GATT连接已经断开。</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServicesDiscovered</span><span class="params">(BluetoothGatt gatt, <span class="keyword">int</span> status)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onServicesDiscovered(gatt, status);</span><br><span class="line">    <span class="comment">//当发现设备服务时，会回调到此处</span></span><br><span class="line">    <span class="keyword">if</span> (status == BluetoothGatt.GATT_SUCCESS) &#123;</span><br><span class="line">      <span class="comment">// 获得并遍历服务</span></span><br><span class="line">      <span class="keyword">for</span> (BluetoothGattService service : gatt.getServices()) &#123;</span><br><span class="line">        <span class="comment">// 获得并遍历特征</span></span><br><span class="line">        <span class="keyword">for</span> (BluetoothGattCharacteristic characteristic : service.getCharacteristics()) &#123;</span><br><span class="line">          <span class="comment">// 下面是一个例子 使能从设备的通知 并拿到某个写通道</span></span><br><span class="line">          <span class="keyword">if</span> (character.getUuid() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (character.getUuid().toString().startsWith(<span class="string">"0000fec8"</span>)) &#123;                                            </span><br><span class="line">              <span class="comment">// 允许notification</span></span><br><span class="line">              mBluetoothGatt.setCharacteristicNotification(character, <span class="keyword">true</span>);</span><br><span class="line">              BluetoothGattDescriptor descriptor = character.getDescriptor(UUID.fromString(<span class="string">"00002902-0000-1000-8000-00805f9b34fb"</span>));                                         </span><br><span class="line">              <span class="comment">// 允许indication</span></span><br><span class="line">              descriptor.setValue(BluetoothGattDescriptor.ENABLE_INDICATION_VALUE);</span><br><span class="line">              mBluetoothGatt.writeDescriptor(descriptor);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (character.getUuid().toString().startsWith(<span class="string">"0000fec7"</span>)) &#123;</span><br><span class="line">              mWriteCharacter = character;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//当方法执行完后，我们就获取了设备所有的特征了。</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCharacteristicRead</span><span class="params">(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic, <span class="keyword">int</span> status)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCharacteristicRead(gatt, characteristic, status);</span><br><span class="line">    <span class="comment">//读取特征后回调到此处</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCharacteristicWrite</span><span class="params">(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic, <span class="keyword">int</span> status)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCharacteristicWrite(gatt, characteristic, status);</span><br><span class="line">    <span class="comment">//写入特征后回调到此处</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCharacteristicChanged</span><span class="params">(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCharacteristicChanged(gatt, characteristic);</span><br><span class="line">    <span class="comment">//当特征（值）发生变化时回调到此处</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDescriptorRead</span><span class="params">(BluetoothGatt gatt, BluetoothGattDescriptor descriptor, <span class="keyword">int</span> status)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onDescriptorRead(gatt, descriptor, status);</span><br><span class="line">    <span class="comment">//读取描述符后回调到此处</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDescriptorWrite</span><span class="params">(BluetoothGatt gatt, BluetoothGattDescriptor descriptor, <span class="keyword">int</span> status)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onDescriptorWrite(gatt, descriptor, status);</span><br><span class="line">    <span class="comment">//写入描述符后回调到此处</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReliableWriteCompleted</span><span class="params">(BluetoothGatt gatt, <span class="keyword">int</span> status)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onReliableWriteCompleted(gatt, status);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReadRemoteRssi</span><span class="params">(BluetoothGatt gatt, <span class="keyword">int</span> rssi, <span class="keyword">int</span> status)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onReadRemoteRssi(gatt, rssi, status);</span><br><span class="line">    <span class="comment">//RSSI表示设备与中心的信号强度，发生变化时回调到此处</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMtuChanged</span><span class="params">(BluetoothGatt gatt, <span class="keyword">int</span> mtu, <span class="keyword">int</span> status)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onMtuChanged(gatt, mtu, status);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">BluetoothGatt mBluetoothGatt = device.connectGatt(BluetoothLeService.<span class="keyword">this</span>, <span class="keyword">false</span>, mBluetoothGattCallback);</span><br></pre></td></tr></table></figure><h5 id="数据交互"><a href="#数据交互" class="headerlink" title="数据交互"></a>数据交互</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读取特征，相当简单，读取结果会回调到mGattCallback中的onCharacteristicRead。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readCharacteristic</span><span class="params">(BluetoothGattCharacteristic characteristic)</span></span>&#123;</span><br><span class="line">  mBluetoothGatt.readCharacteristic(characteristic);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写入特征，也相当简单，写入结果会回调到mGattCallback中的onCharacteristicWrite</span></span><br><span class="line"><span class="comment">//一次传输20字节，但貌似不需要做手动处理</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readCharacteristic</span><span class="params">(BluetoothGattCharacteristic characteristic)</span></span>&#123;</span><br><span class="line">  characteristic.setValue(value);</span><br><span class="line">  mBluetoothGatt.writeCharacteristic(characteristic);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>系统回调<code>BluetoothGattCallback.onCharacteristicWrite()</code>方法通知数据已经完成写入。此时，我们需要执行<code>BluetoothGattCharactristic.getValue()</code>方法检查一下写入的数据是否我们需要发送的数据，如果不是按照项目的需要判断是否需要重发</p><p>蓝牙的写入操作，取操作必须序列化进行。写入数据和读取数据是不能同时进行的，如果调用了写入数据的方法，马上调用写入数据或者读取数据的方法，第二次调用的方法会立即返回 <code>false</code>， 代表当前无法进行操作. 断开连接</p><p>BLE蓝牙连接断开非常重要，因为主设备支持的设备数量有限，如果没有释放，后面连接可能总是失败</p><p>当蓝牙成功连接之后，通过<code>BluetoothGatt.disconnect()</code>断开蓝牙的连接，紧接着在 <code>BluetoothGattCallback.onConnectionStateChange()</code> 执行<code>BluetoothGatt.close()</code> 方法释放资源</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;蓝牙是一种无线技术标准，可实现固定设备、移动设备和楼宇个域网之间的短距离数据交换，传输距离近、低功耗&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://lakeshire.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://lakeshire.github.io/tags/Android/"/>
    
      <category term="Bluetooth" scheme="http://lakeshire.github.io/tags/Bluetooth/"/>
    
  </entry>
  
  <entry>
    <title>WebView学习笔记</title>
    <link href="http://lakeshire.github.io/2017/12/05//archivers/webview/"/>
    <id>http://lakeshire.github.io/2017/12/05//archivers/webview/</id>
    <published>2017-12-05T04:00:00.000Z</published>
    <updated>2017-12-05T07:52:06.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="WebView学习笔记"><a href="#WebView学习笔记" class="headerlink" title="WebView学习笔记"></a>WebView学习笔记</h2><p>WebView学习笔记，参考<a href="http://www.jianshu.com/p/3c94ae673e2a" target="_blank" rel="noopener">最全面、最易懂的Webview使用详解</a></p><a id="more"></a><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><h4 id="加载内容"><a href="#加载内容" class="headerlink" title="加载内容"></a>加载内容</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webView.loadUrl(<span class="string">"http://www.google.com/"</span>);</span><br></pre></td></tr></table></figure><p>加载一个网址</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WebView.loadData(String data, String mimeType, String encoding)</span><br></pre></td></tr></table></figure><p>加载一段网络内容，参数1是内容，参数2是内容类型，参数3是编码方式</p><h4 id="避免内存泄漏"><a href="#避免内存泄漏" class="headerlink" title="避免内存泄漏"></a>避免内存泄漏</h4><p>不在xml中定义，而是需要时创建，使用Application的Context</p><p>销毁的时候，先加载空内容，然后移除View，最后销毁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">webView.loadDataWithBaseURL(<span class="keyword">null</span>, <span class="string">""</span>, <span class="string">"text/html"</span>, <span class="string">"utf-8"</span>, <span class="keyword">null</span>);</span><br><span class="line">rootLayout.removeView(webView); </span><br><span class="line">webView.destroy();</span><br><span class="line">webView = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><p>WebView调用<code>destroy()</code>时仍绑定在Activity上，所以要先移除WebView，然后在摧毁</p><h4 id="后退"><a href="#后退" class="headerlink" title="后退"></a>后退</h4><p>不做处理时，按Back键会使WebView结束掉，所以需要在按键中处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onKeyDown</span><span class="params">(<span class="keyword">int</span> keyCode, KeyEvent event)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ((keyCode == KEYCODE_BACK) &amp;&amp; mWebView.canGoBack()) &#123; </span><br><span class="line">    mWebView.goBack();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">super</span>.onKeyDown(keyCode, event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h3><h4 id="WebSettings"><a href="#WebSettings" class="headerlink" title="WebSettings"></a>WebSettings</h4><p>对WebView进行配置管理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">WebSettings webSettings = webView.getSettings();</span><br><span class="line"><span class="comment">//如果访问的页面中要与Javascript交互，则webview必须设置支持Javascript</span></span><br><span class="line">webSettings.setJavaScriptEnabled(<span class="keyword">true</span>);  </span><br><span class="line"><span class="comment">//支持插件</span></span><br><span class="line">webSettings.setPluginsEnabled(<span class="keyword">true</span>); </span><br><span class="line"><span class="comment">//设置自适应屏幕，两者合用</span></span><br><span class="line"><span class="comment">//将图片调整到适合WebView的大小 </span></span><br><span class="line">webSettings.setUseWideViewPort(<span class="keyword">true</span>); </span><br><span class="line"><span class="comment">//缩放至屏幕的大小</span></span><br><span class="line">webSettings.setLoadWithOverviewMode(<span class="keyword">true</span>); </span><br><span class="line"><span class="comment">//支持缩放，默认为true</span></span><br><span class="line">webSettings.setSupportZoom(<span class="keyword">true</span>); </span><br><span class="line"><span class="comment">//设置可以访问文件 </span></span><br><span class="line">webSettings.setAllowFileAccess(<span class="keyword">true</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">//优先使用缓存: </span></span><br><span class="line">webSettings.setCacheMode(WebSettings.LOAD_CACHE_ELSE_NETWORK); </span><br><span class="line"><span class="comment">//缓存模式如下：</span></span><br><span class="line"><span class="comment">//LOAD_CACHE_ONLY: 不使用网络，只读取本地缓存数据</span></span><br><span class="line"><span class="comment">//LOAD_DEFAULT: （默认）根据cache-control决定是否从网络上取数据。</span></span><br><span class="line"><span class="comment">//LOAD_NO_CACHE: 不使用缓存，只从网络获取数据.</span></span><br><span class="line"><span class="comment">//LOAD_CACHE_ELSE_NETWORK，只要本地有，无论是否过期，或者no-cache，都使用缓存中的数据。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//开启DOM Storage API功能</span></span><br><span class="line">webSettings.setDomStorageEnabled(<span class="keyword">true</span>); </span><br><span class="line"><span class="comment">//开启Database Storage API功能</span></span><br><span class="line">webSettings.setDatabaseEnabled(<span class="keyword">true</span>); </span><br><span class="line"><span class="comment">//开启Application Caches功能</span></span><br><span class="line">webSettings.setAppCacheEnabled(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">//设置Application Caches缓存目录 每个Application只需调用一次</span></span><br><span class="line">String cacheDirPath = getFilesDir().getAbsolutePath() + APP_CACAHE_DIRNAME;</span><br><span class="line">webSettings.setAppCachePath(cacheDirPath);</span><br></pre></td></tr></table></figure><p>如果加载的HTML里有JS在执行动画等操作，会造成资源浪费，在<code>onStop()</code>和<code>onStart()</code>里分别把<code>setJavaScriptEnabled()</code>给设置成<code>false</code>和<code>true</code>即可</p><h4 id="WebViewClient"><a href="#WebViewClient" class="headerlink" title="WebViewClient"></a>WebViewClient</h4><p>处理各种通知／事件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldOverrideUrlLoading</span><span class="params">(WebView view, String url)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>载入Url之前可以在这里获得控制进行处理，不提供时，由系统选择如何处理Url（在浏览器中打开），返回<code>false</code>则由系统处理，返回<code>true</code> 由应用处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">webView.setWebViewClient(<span class="keyword">new</span> WebViewClient()&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldOverrideUrlLoading</span><span class="params">(WebView view, String url)</span> </span>&#123;</span><br><span class="line">    view.loadUrl(url);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>以上是在本WebView显示而不打开新的浏览器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开始载入页面</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPageStarted</span><span class="params">(WebView view, String url, Bitmap favicon)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结束载入页面</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPageFinished</span><span class="params">(WebView view, String url)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 载入资源时</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLoadResource</span><span class="params">(WebView view, String url)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拦截请求 允许应用返回数据 如果返回null 则继续请求 否则用这里返回的值</span></span><br><span class="line"><span class="comment">// 注意并非工作在UI线程</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> WebResourceResponse <span class="title">shouldInterceptRequest</span><span class="params">(WebView view, WebResourceRequest request)</span> </span>&#123;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> WebResourceResponse <span class="title">shouldInterceptRequest</span><span class="params">(WebView view, String url)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理错误</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceivedError</span><span class="params">(WebView view, WebResourceRequest request, WebResourceError error)</span> </span>&#123;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="WebChromeClient"><a href="#WebChromeClient" class="headerlink" title="WebChromeClient"></a>WebChromeClient</h4><p>辅助处理JS，图标，标题等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onProgressChanged</span><span class="params">(WebView view, <span class="keyword">int</span> newProgress)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceivedTitle</span><span class="params">(WebView view, String title)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceivedIcon</span><span class="params">(WebView view, Bitmap icon)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理JS的提示框</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onJsAlert</span><span class="params">(WebView view, String url, String message, JsResult result)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 处理JS的确认框</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onJsConfirm</span><span class="params">(WebView view, String url, String message, JsResult result)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 处理JS的输入框</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onJsPrompt</span><span class="params">(WebView view, String url, String message, String defaultValue, JsPromptResult result)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件选择器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onShowFileChooser</span><span class="params">(WebView webView, ValueCallback&lt;Uri[]&gt; filePathCallback, FileChooserParams fileChooserParams)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="JS和Android代码的交互"><a href="#JS和Android代码的交互" class="headerlink" title="JS和Android代码的交互"></a>JS和Android代码的交互</h3><h4 id="Android调用JS"><a href="#Android调用JS" class="headerlink" title="Android调用JS"></a>Android调用JS</h4><h5 id="loadUrl"><a href="#loadUrl" class="headerlink" title="loadUrl()"></a>loadUrl()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mWebView.loadUrl(<span class="string">"javascript:callJS()"</span>);</span><br></pre></td></tr></table></figure><p>调用JavaScript中的<code>callJS()</code>方法</p><p>JS代码调用一定要在<code>onPageFinished()</code>回调之后才能调用，否则不会调用</p><h5 id="evaluateJavascript"><a href="#evaluateJavascript" class="headerlink" title="evaluateJavascript()"></a>evaluateJavascript()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mWebView.evaluateJavascript（<span class="string">"javascript:callJS()"</span>, <span class="keyword">new</span> ValueCallback&lt;String&gt;() &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceiveValue</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这个方法不会刷新页面，所以比较高效，可以处理返回值，<code>4.4</code>以上才可以用</p><h4 id="JS调用Android"><a href="#JS调用Android" class="headerlink" title="JS调用Android"></a>JS调用Android</h4><h5 id="addJavascriptInterface-对象映射"><a href="#addJavascriptInterface-对象映射" class="headerlink" title="addJavascriptInterface()对象映射"></a>addJavascriptInterface()对象映射</h5><p>定义映射关系类，把JS需要调用的方法用<code>@JavascriptInterface</code>注释，代码中用<code>addJavascriptInterface()</code>添加映射</p><p><em>Android2JS.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Android2JS</span> <span class="keyword">extends</span> <span class="title">Object</span> </span>&#123;</span><br><span class="line">  <span class="meta">@JavascriptInterface</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Toast</span><span class="params">(String string)</span> </span>&#123;</span><br><span class="line">    Toast.makeText(MyApplication.sApp, string, Toast.LENGTH_SHORT).show();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mWebView.addJavascriptInterface(<span class="keyword">new</span> Android2JS(), <span class="string">"android2js"</span>);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">callAndroid</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     android2js.Toast(<span class="string">"Hello World"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>这样就可以通过JS调用原生代码</p><blockquote><p>JS拿到Android对象后，可以调用对象中的所有方法，是严重的安全漏洞</p><p>对象可以通过<code>getClass()</code>获得当前类Class，通过<code>Class.forName()</code>可以加载类，如果加载了<code>Runtime</code> 类，便可以执行本地命令，比如访问文件</p><p>APP通过扫描等打开外部网页，可能运行到恶意攻击代码</p><p><code>4.2</code>之后可以通过加<code>@JavascriptInterface</code> 注释</p><p><code>4.2</code> 之前通过拦截<code>prompt()</code>修复（不很理解，感觉跟下面的差不多）</p></blockquote><h5 id="shouldOverrideUrlLoading-方法回调拦截"><a href="#shouldOverrideUrlLoading-方法回调拦截" class="headerlink" title="shouldOverrideUrlLoading()方法回调拦截"></a>shouldOverrideUrlLoading()方法回调拦截</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">callAndroid</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.location = <span class="string">"js://webview?arg1=1&amp;arg2=2"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>JS里面的函数修改<code>location</code>，然后通过<code>shouldOverrideUrlLoading()</code>拦截URL路由</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldOverrideUrlLoading</span><span class="params">(WebView view, String url)</span> </span>&#123;</span><br><span class="line">  Uri uri = Uri.parse(url);        </span><br><span class="line">  <span class="comment">// 匹配协议／域 获得参数</span></span><br><span class="line">  <span class="keyword">if</span> ( uri.getScheme().equals(<span class="string">"js"</span>)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (uri.getAuthority().equals(<span class="string">"webview"</span>)) &#123;</span><br><span class="line">      HashMap&lt;String, String&gt; params = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">      Set&lt;String&gt; collection = uri.getQueryParameterNames();</span><br><span class="line">      ......</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">super</span>.shouldOverrideUrlLoading(view, url);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只能通过加载执行JS代码返回值，比较麻烦</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mWebView.loadUrl(<span class="string">"javascript:returnResult("</span> + result + <span class="string">")"</span>);</span><br></pre></td></tr></table></figure><h5 id="拦截JS对话框alert-、confirm-、prompt-消息"><a href="#拦截JS对话框alert-、confirm-、prompt-消息" class="headerlink" title="拦截JS对话框alert()、confirm()、prompt()消息"></a>拦截JS对话框alert()、confirm()、prompt()消息</h5><p>跟拦截URL差不多，而且使用输入框可以方便的返回值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onJsPrompt</span><span class="params">(WebView view, String url, String message, String defaultValue, JsPromptResult result)</span> </span>&#123;</span><br><span class="line">  Uri uri = Uri.parse(message);</span><br><span class="line">  <span class="keyword">if</span> (uri.getScheme().equals(<span class="string">"js"</span>)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (uri.getAuthority().equals(<span class="string">"toast"</span>)) &#123;</span><br><span class="line">      HashMap&lt;String, String&gt; params = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">      Set&lt;String&gt; keys = uri.getQueryParameterNames();</span><br><span class="line">      <span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">        params.put(key, uri.getQueryParameter(key));</span><br><span class="line">      &#125;</span><br><span class="line">      String msg = params.get(<span class="string">"message"</span>);</span><br><span class="line">      Toast.makeText(MainActivity.<span class="keyword">this</span>, msg, Toast.LENGTH_SHORT).show();</span><br><span class="line">      result.confirm(<span class="string">"done"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="漏洞"><a href="#漏洞" class="headerlink" title="漏洞"></a>漏洞</h3><h4 id="任意代码执行漏洞"><a href="#任意代码执行漏洞" class="headerlink" title="任意代码执行漏洞"></a>任意代码执行漏洞</h4><h5 id="addJavascriptInterface"><a href="#addJavascriptInterface" class="headerlink" title="addJavascriptInterface()"></a><code>addJavascriptInterface()</code></h5><h5 id="searchBoxJavaBridge"><a href="#searchBoxJavaBridge" class="headerlink" title="searchBoxJavaBridge_"></a><code>searchBoxJavaBridge_</code></h5><p><code>3.0</code>以下，系统默认添加映射对象<code>searchBoxJavaBridge_</code>，可能被利用，用<code>removeJavascriptInterface()</code> 删除该方法就好了</p><h5 id="accessibility和accessibilityTraversal"><a href="#accessibility和accessibilityTraversal" class="headerlink" title="accessibility和accessibilityTraversal"></a><code>accessibility</code>和<code>accessibilityTraversal</code></h5><p>同上</p><h4 id="密码明文存储"><a href="#密码明文存储" class="headerlink" title="密码明文存储"></a>密码明文存储</h4><p>WebView默认开启密码保存，并明文保存到本地数据库，通过<code>WebSettings.setSavePassword(false)</code>关闭密码保存</p><h4 id="域控制不严格"><a href="#域控制不严格" class="headerlink" title="域控制不严格"></a>域控制不严格</h4><p>A应用可以通过B应用导出的Activity让B应用加载一个恶意的<code>file</code>协议的URL，从而可以获取B应用的内部私有文件，从而带来数据泄露威胁</p><p>使用<code>file</code>域加载的JS代码能够使用进行<strong>同源策略跨域访问</strong>，从而导致隐私信息泄露</p><p>通过<code>WebSettings.setAllowFileAccess(true)</code>禁止访问文件，缺点是这样就不能加载本地网页，可以对使用<code>file</code> 协议的URL禁止使用JS</p><p>通过<code>WebSettings.setAllowFileAccessFromFileURLs(false)</code>禁止<code>file</code>协议加载的JS访问本地文件</p><p>通过<code>WebSettings.setAllowUniversalAccessFromFileURLs(false)</code>禁止<code>file</code>协议加载的JS访问其他Http源等</p><p>总之对不需要<code>file</code> 协议的禁用<code>file</code>协议，需要用的禁用JS</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;WebView学习笔记&quot;&gt;&lt;a href=&quot;#WebView学习笔记&quot; class=&quot;headerlink&quot; title=&quot;WebView学习笔记&quot;&gt;&lt;/a&gt;WebView学习笔记&lt;/h2&gt;&lt;p&gt;WebView学习笔记，参考&lt;a href=&quot;http://www.jianshu.com/p/3c94ae673e2a&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;最全面、最易懂的Webview使用详解&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://lakeshire.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://lakeshire.github.io/tags/Android/"/>
    
      <category term="WebView" scheme="http://lakeshire.github.io/tags/WebView/"/>
    
      <category term="Hybrid" scheme="http://lakeshire.github.io/tags/Hybrid/"/>
    
  </entry>
  
  <entry>
    <title>View的事件分发</title>
    <link href="http://lakeshire.github.io/2017/12/04//archivers/view-dispatch/"/>
    <id>http://lakeshire.github.io/2017/12/04//archivers/view-dispatch/</id>
    <published>2017-12-04T04:00:00.000Z</published>
    <updated>2017-12-04T09:07:11.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="View的事件分发"><a href="#View的事件分发" class="headerlink" title="View的事件分发"></a>View的事件分发</h2><p>本文的起点是Activity里的<code>dispatchTouchEvent()</code>方法，整体的流程如下图</p><p><img src="http://7xt3ho.com1.z0.glb.clouddn.com/Flow%20Chart%20Demo.png" alt=""></p><a id="more"></a><h3 id="流程梳理"><a href="#流程梳理" class="headerlink" title="流程梳理"></a>流程梳理</h3><p><em>Activity.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 通知用户与Activity发生了交互</span></span><br><span class="line">  <span class="keyword">if</span> (ev.getAction() == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">    onUserInteraction();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (getWindow().superDispatchTouchEvent(ev)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> onTouchEvent(ev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获得Activity的<code>mWindow</code>，调用其<code>superDispatchTouchEvent()</code>方法</p><p><em>Window.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">superDispatchTouchEvent</span><span class="params">(MotionEvent event)</span></span>;</span><br></pre></td></tr></table></figure><p>是一个抽象方法，手机上获得的Window都是PhoneWindow这个子类</p><p><em>PhoneWindow.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">superDispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mDecor.superDispatchTouchEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用了<code>mDecor</code>的<code>superDispatchTouchEvent()</code>方法</p><p><code>mDecor</code>是一个DecorView对象，它是Window的顶层View，是FrameLayout的子类，DecorView里包括一个标题栏和一个内容View，Activity的<code>setContentView()</code>方法就是给DecorView设置内容View</p><p><em>DecorView.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Window.Callback cb = mWindow.getCallback();</span><br><span class="line">  <span class="keyword">return</span> cb != <span class="keyword">null</span> &amp;&amp; !mWindow.isDestroyed() &amp;&amp; mFeatureId &lt; <span class="number">0</span> ? cb.dispatchTouchEvent(ev) : <span class="keyword">super</span>.dispatchTouchEvent(ev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见可以通过设置回调来拦截触摸事件，如果没有的话就调用父类ViewGroup的<code>dispatchTouchEvent()</code></p><p><em>ViewGroup.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 检查是否拦截</span></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">boolean</span> intercepted;</span><br><span class="line">  <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 检查禁止拦截标志位</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!disallowIntercept) &#123;</span><br><span class="line">      <span class="comment">// 可以拦截则调用拦截函数</span></span><br><span class="line">      intercepted = onInterceptTouchEvent(ev);</span><br><span class="line">      ev.setAction(action);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 没有拦截</span></span><br><span class="line">      intercepted = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 没有触摸目标并且也不是初始的DONW事件 保持拦截</span></span><br><span class="line">    intercepted = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 没有取消并且没有被拦截</span></span><br><span class="line">  <span class="keyword">if</span> (!canceled &amp;&amp; !intercepted) &#123;</span><br><span class="line">  ...</span><br><span class="line">    <span class="comment">// 处理DOWN事件</span></span><br><span class="line">    <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN) || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123;</span><br><span class="line">      ...</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 遍历子元素 发现能接受触摸事件的View</span></span><br><span class="line">      <span class="keyword">if</span> (newTouchTarget == <span class="keyword">null</span> &amp;&amp; childrenCount != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = childrenCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">          ...</span><br><span class="line">          <span class="keyword">final</span> View child = getAndVerifyPreorderedView(preorderedList, children, childIndex);</span><br><span class="line">          newTouchTarget = getTouchTarget(child);</span><br><span class="line">          <span class="keyword">if</span> (newTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 子元素已经在处理事件 应是多点触控的情况 添加新的指针 并跳出遍历循环</span></span><br><span class="line">            newTouchTarget.pointerIdBits |= idBitsToAssign;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          </span><br><span class="line">          <span class="comment">// 不然的话交由子元素处理</span></span><br><span class="line">          <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, <span class="keyword">false</span>, child, idBitsToAssign)) &#123;</span><br><span class="line">            <span class="comment">// 返回true则是将要处理事件</span></span><br><span class="line">            <span class="comment">// 记录接触点 产生新的触摸对象 标记为已经分发给触摸对象</span></span><br><span class="line">            mLastTouchDownTime = ev.getDownTime();</span><br><span class="line">            <span class="keyword">if</span> (preorderedList != <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; childrenCount; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (children[childIndex] == mChildren[j]) &#123;</span><br><span class="line">                  mLastTouchDownIndex = j;</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              mLastTouchDownIndex = childIndex;</span><br><span class="line">            &#125;</span><br><span class="line">            mLastTouchDownX = ev.getX();</span><br><span class="line">            mLastTouchDownY = ev.getY();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 添加新的触摸对象</span></span><br><span class="line">            newTouchTarget = addTouchTarget(child, idBitsToAssign);</span><br><span class="line">            alreadyDispatchedToNewTouchTarget = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        ｝</span><br><span class="line">          </span><br><span class="line">        <span class="comment">// 没有找到可以接受事件的子元素 用最近添加的</span></span><br><span class="line">        <span class="keyword">if</span> (newTouchTarget == <span class="keyword">null</span> &amp;&amp; mFirstTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">          newTouchTarget = mFirstTouchTarget;</span><br><span class="line">          <span class="keyword">while</span> (newTouchTarget.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            newTouchTarget = newTouchTarget.next;</span><br><span class="line">          &#125;</span><br><span class="line">          newTouchTarget.pointerIdBits |= idBitsToAssign;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (mFirstTouchTarget == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 这个时候还没有触摸对象 则由本View处理</span></span><br><span class="line">    handled = dispatchTransformedTouchEvent(ev, canceled, <span class="keyword">null</span>, TouchTarget.ALL_POINTER_IDS);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 把事件发送给所有的触摸对象 已处理过的除外</span></span><br><span class="line">    <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, cancelChild, target.child, target.pointerIdBits)) &#123;</span><br><span class="line">      handled = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 处理UP事件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>`<em>ViewGroup.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dispatchTransformedTouchEvent</span><span class="params">(MotionEvent event, <span class="keyword">boolean</span> cancel, View child, <span class="keyword">int</span> desiredPointerIdBits)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 没有可接收事件的子元素 交由父类View处理 </span></span><br><span class="line">    handled = <span class="keyword">super</span>.dispatchTouchEvent(transformedEvent);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> offsetX = mScrollX - child.mLeft;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> offsetY = mScrollY - child.mTop;</span><br><span class="line">    transformedEvent.offsetLocation(offsetX, offsetY);</span><br><span class="line">    <span class="keyword">if</span> (! child.hasIdentityMatrix()) &#123;</span><br><span class="line">      transformedEvent.transform(child.getInverseMatrix());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 由子元素处理</span></span><br><span class="line">    handled = child.dispatchTouchEvent(transformedEvent);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> handled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>View.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 先观察设置给View的点击监听器</span></span><br><span class="line">  <span class="comment">// 如果设置了 并且标志位是可点击的 则调用监听器的onTouch()方法</span></span><br><span class="line">  <span class="comment">// onTouch返回true则最终结果为true 其它情况结果均为false</span></span><br><span class="line">  ListenerInfo li = mListenerInfo;</span><br><span class="line">  <span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnTouchListener != <span class="keyword">null</span> &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; li.mOnTouchListener.onTouch(<span class="keyword">this</span>, event)) &#123;</span><br><span class="line">    result = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 只有上面的结果为false才会onTouchEvent()处理</span></span><br><span class="line">  <span class="keyword">if</span> (!result &amp;&amp; onTouchEvent(event)) &#123;</span><br><span class="line">    result = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见返回值如果为true，则表示事件已被处理不需再处理</p><p><em>View.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> action = event.getAction();</span><br><span class="line">  <span class="keyword">if</span> (clickable || (viewFlags &amp; TOOLTIP) == TOOLTIP) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (action) &#123;</span><br><span class="line">      <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">...</span><br><span class="line">        performClick();</span><br><span class="line">      ...</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> MotionEvent.ACTION_CANCEL:</span><br><span class="line">...</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会在<code>ACTION_UP</code>事件里处理点击事件</p><p>同样处理后返回true，否则返回false</p><p><em>View.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">performClick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">boolean</span> result;</span><br><span class="line">  <span class="keyword">final</span> ListenerInfo li = mListenerInfo;</span><br><span class="line">  <span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnClickListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">    playSoundEffect(SoundEffectConstants.CLICK);</span><br><span class="line">    li.mOnClickListener.onClick(<span class="keyword">this</span>);</span><br><span class="line">    result = <span class="keyword">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    result = <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里调用了<code>View.OnClickListener.onClick()</code></p><p><em>总结流程</em></p><ol><li><p>事件首先到达Activity，由<code>dispatchTouchEvent()</code>分发给顶层布局容器</p></li><li><p>ViewGroup通过<code>dispatchTouchEvent()</code>进行分发</p><ol><li>处理DOWN事件，做一些初始化</li><li>处理拦截</li><li>如果没有拦截，则遍历子元素，根据DONW事件的信息查找触摸目标，如果有则调用这个触摸目标的<code>dispatchTouchEvent()</code> 方法，如果是ViewGroup，则重复2，如果是View，则调用其<code>onTouchEvent()</code>处理事件并返回</li><li>如果没有找到触摸目标，则调用自己父类的<code>View.dispatchTouchEvent()</code>方法，否则在所有的触摸目标上应用触摸事件，排除已处理过的</li><li>处理UP事件，清理状态</li></ol></li><li><p>处理返回值，如果为<code>true</code>，则之后的同序列事件都由本View处理，如果为<code>false</code>，则之后的同序列事件交给父布局处理，重复此过程直到顶层布局容器</p></li><li><p>布局都没有处理，则由Activity的<code>onTouchEvent()</code>处理</p><p>​</p></li></ol><h3 id="细节整理"><a href="#细节整理" class="headerlink" title="细节整理"></a>细节整理</h3><h4 id="拦截原理"><a href="#拦截原理" class="headerlink" title="拦截原理"></a>拦截原理</h4><p><code>actionMasked == MotionEvent.ACTION_DOWN</code> 和<code>mFirstTouchTarget != null</code>两个条件满足其一的时候会判断是否拦截，前者说明DOWN事件总是判断拦截的，后者说明之前的事件已经交给子元素处理了，所以一旦DOWN事件已经被拦截，<code>mFirstTouchTarget</code>就是空，那么接下来的MOVE和UP事件就不会再判断拦截了，即所有一系列事件都会被拦截</p><p>下面会判断拦截标志位，这个标志位会导致父元素无法拦截除DOWN之外的事件，因为在DOWN到来时会重置标志位，如果没有禁止拦截，那么<code>onInterceptTouchEvent()</code>确定是否拦截，这个标记可以由子元素调用<code>requestDisallowInterceptTouchEvent()</code> 来设置</p><h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><p>返回值会层层回传，直到Activity那里</p><p><em>Activity.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (getWindow().superDispatchTouchEvent(ev)) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> onTouchEvent(ev);</span><br></pre></td></tr></table></figure><p>可见如果是<code>true</code>，就直接返回了，如果是<code>false</code>，就走Activity的<code>onTouchEvent()</code>方法，由Activity处理</p><p>对于DOWN事件有额外的处理，DOWN事件里会查找并分发给子元素处理，如果返回的是<code>true</code>，则会调用<code>addTouchTarget()</code>，这里面会给<code>mFirstTouchTarget</code>赋值，返回<code>false</code>则不会，后面就会做判断，决定后续事件是交给子元素还是自己处理</p><p>所以返回<code>true</code>则由子元素处理，返回<code>false</code>则由自己处理</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;View的事件分发&quot;&gt;&lt;a href=&quot;#View的事件分发&quot; class=&quot;headerlink&quot; title=&quot;View的事件分发&quot;&gt;&lt;/a&gt;View的事件分发&lt;/h2&gt;&lt;p&gt;本文的起点是Activity里的&lt;code&gt;dispatchTouchEvent()&lt;/code&gt;方法，整体的流程如下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xt3ho.com1.z0.glb.clouddn.com/Flow%20Chart%20Demo.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://lakeshire.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://lakeshire.github.io/tags/Android/"/>
    
      <category term="View" scheme="http://lakeshire.github.io/tags/View/"/>
    
  </entry>
  
  <entry>
    <title>View的绘制原理</title>
    <link href="http://lakeshire.github.io/2017/11/30//archivers/view/"/>
    <id>http://lakeshire.github.io/2017/11/30//archivers/view/</id>
    <published>2017-11-30T04:00:00.000Z</published>
    <updated>2017-11-30T08:14:01.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="View的绘制原理"><a href="#View的绘制原理" class="headerlink" title="View的绘制原理"></a>View的绘制原理</h2><p>Android的View绘制都要经过测量，布局和绘制三个步骤</p><a id="more"></a><h3 id="测量"><a href="#测量" class="headerlink" title="测量"></a>测量</h3><p>测量过程用来决定View的宽高，父布局提供了限制条件</p><p><em>View.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">measure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">  ......</span><br><span class="line">  <span class="comment">// 判断是不是要进行测量</span></span><br><span class="line">  <span class="comment">// 有强制布局的标志 或者MeasureSpec有变化则测量</span></span><br><span class="line">  <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT || widthMeasureSpec != mOldWidthMeasureSpec || heightMeasureSpec != mOldHeightMeasureSpec) &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 清标记</span></span><br><span class="line">    mPrivateFlags &amp;= ~PFLAG_MEASURED_DIMENSION_SET;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 测量</span></span><br><span class="line">    onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 如果没有设置标志就抛出异常</span></span><br><span class="line">    <span class="comment">// 说明在测量出宽高后一定要调setMeasuredDimension()</span></span><br><span class="line">    <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_MEASURED_DIMENSION_SET) != PFLAG_MEASURED_DIMENSION_SET) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"View with id "</span> + getId() + <span class="string">": "</span> + getClass().getName() + <span class="string">"#onMeasure() did not set the measured dimension by calling setMeasuredDimension()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mPrivateFlags |= PFLAG_LAYOUT_REQUIRED;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  mOldWidthMeasureSpec = widthMeasureSpec;</span><br><span class="line">  mOldHeightMeasureSpec = heightMeasureSpec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>measure()</code>方法不可被重写，都是通过重写<code>onMeasure()</code>来完成测量</p><p><em>View.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">  setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec), getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>View的<code>onMeasure()</code>只调用了<code>setMeasuredDimension()</code>设置测量好的宽高，就是设置了<code>mMeasuredWidth</code> 和<code>mMeasuredHeight</code>两个变量，并设置了<code>PFLAG_MEASURED_DIMENSION_SET</code>标志位</p><p><em>View.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getDefaultSize</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> measureSpec)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> result = size;</span><br><span class="line">  <span class="keyword">int</span> specMode = MeasureSpec.getMode(measureSpec);</span><br><span class="line">  <span class="keyword">int</span> specSize = MeasureSpec.getSize(measureSpec);</span><br><span class="line">  <span class="keyword">switch</span> (specMode) &#123;</span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</span><br><span class="line">      <span class="comment">// 无限制 则返回给定的大小</span></span><br><span class="line">      result = size;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.AT_MOST:</span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.EXACTLY:</span><br><span class="line">      <span class="comment">// 父布局给定最大值或指定值 则返回从MeasureSpec中解析出来的大小</span></span><br><span class="line">      result = specSize;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认实现通过<code>getDeaultSize()</code>来获得宽高，综合考虑传入的大小和MeasureSpec</p><h3 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h3><p><em>View.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">layout</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 需要测量先测量</span></span><br><span class="line">  <span class="keyword">if</span> ((mPrivateFlags3 &amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != <span class="number">0</span>) &#123;</span><br><span class="line">    onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec);</span><br><span class="line">    mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> oldL = mLeft;</span><br><span class="line">  <span class="keyword">int</span> oldT = mTop;</span><br><span class="line">  <span class="keyword">int</span> oldB = mBottom;</span><br><span class="line">  <span class="keyword">int</span> oldR = mRight;</span><br><span class="line">  <span class="comment">// 调用某个setFrame方法</span></span><br><span class="line">  <span class="keyword">boolean</span> changed = isLayoutModeOptical(mParent) ? setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 如果有变化或者标志位是强制布局才开始真正的布局</span></span><br><span class="line">  <span class="keyword">if</span> (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123;</span><br><span class="line">    onLayout(changed, l, t, r, b);</span><br><span class="line">    mPrivateFlags &amp;= ~PFLAG_LAYOUT_REQUIRED;</span><br><span class="line">    ListenerInfo li = mListenerInfo;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通知布局变化</span></span><br><span class="line">    <span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnLayoutChangeListeners != <span class="keyword">null</span>) &#123;</span><br><span class="line">      ArrayList&lt;OnLayoutChangeListener&gt; listenersCopy = (ArrayList&lt;OnLayoutChangeListener&gt;)li.mOnLayoutChangeListeners.clone();</span><br><span class="line">      <span class="keyword">int</span> numListeners = listenersCopy.size();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numListeners; ++i) &#123;</span><br><span class="line">        listenersCopy.get(i).onLayoutChange(<span class="keyword">this</span>, l, t, r, b, oldL, oldT, oldR, oldB);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  mPrivateFlags &amp;= ~PFLAG_FORCE_LAYOUT;</span><br><span class="line">  mPrivateFlags3 |= PFLAG3_IS_LAID_OUT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也是通过重写<code>onLayout()</code>来重写布局</p><p><em>View.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>View的<code>onLayout()</code>是空的，需要子类实现</p><p><em>View.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">setFrame</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">boolean</span> changed = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (mLeft != left || mRight != right || mTop != top || mBottom != bottom) &#123;</span><br><span class="line">    <span class="comment">// 发生了变化</span></span><br><span class="line">    changed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">int</span> drawn = mPrivateFlags &amp; PFLAG_DRAWN;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 比较新旧宽高的变化</span></span><br><span class="line">    <span class="keyword">int</span> oldWidth = mRight - mLeft;</span><br><span class="line">    <span class="keyword">int</span> oldHeight = mBottom - mTop;</span><br><span class="line">    <span class="keyword">int</span> newWidth = right - left;</span><br><span class="line">    <span class="keyword">int</span> newHeight = bottom - top;</span><br><span class="line">    <span class="keyword">boolean</span> sizeChanged = (newWidth != oldWidth) || (newHeight != oldHeight);</span><br><span class="line">    </span><br><span class="line">    invalidate(sizeChanged);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新成员变量</span></span><br><span class="line">    mLeft = left;</span><br><span class="line">    mTop = top;</span><br><span class="line">    mRight = right;</span><br><span class="line">    mBottom = bottom;</span><br><span class="line">    mRenderNode.setLeftTopRightBottom(mLeft, mTop, mRight, mBottom);</span><br><span class="line">    mPrivateFlags |= PFLAG_HAS_BOUNDS;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 大小变化后做一些事</span></span><br><span class="line"><span class="keyword">if</span> (sizeChanged) &#123;</span><br><span class="line">      sizeChange(newWidth, newHeight, oldWidth, oldHeight);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || mGhostView != <span class="keyword">null</span>) &#123;</span><br><span class="line">      mPrivateFlags |= PFLAG_DRAWN;</span><br><span class="line">      invalidate(sizeChanged);</span><br><span class="line">      invalidateParentCaches();</span><br><span class="line">    &#125;</span><br><span class="line">    mPrivateFlags |= drawn;</span><br><span class="line">    </span><br><span class="line">mBackgroundSizeChanged = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (mForegroundInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">      mForegroundInfo.mBoundsChanged = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    notifySubtreeAccessibilityStateChangedIfNeeded();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> changed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sizeChange</span><span class="params">(<span class="keyword">int</span> newWidth, <span class="keyword">int</span> newHeight, <span class="keyword">int</span> oldWidth, <span class="keyword">int</span> oldHeight)</span> </span>&#123;</span><br><span class="line">  onSizeChanged(newWidth, newHeight, oldWidth, oldHeight);</span><br><span class="line">  <span class="keyword">if</span> (mOverlay != <span class="keyword">null</span>) &#123;</span><br><span class="line">    mOverlay.getOverlayView().setRight(newWidth);</span><br><span class="line">    mOverlay.getOverlayView().setBottom(newHeight);</span><br><span class="line">  &#125;</span><br><span class="line">  rebuildOutline();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>onSizeChanged()</code>也是由子类实现，大小变化时做一些事</p><h3 id="绘制"><a href="#绘制" class="headerlink" title="绘制"></a>绘制</h3><p><em>View.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">  drawBackground(canvas);</span><br><span class="line">  ...</span><br><span class="line">  onDraw(canvas);</span><br><span class="line">  ...</span><br><span class="line">  dispatchDraw(canvas);</span><br><span class="line">  ...</span><br><span class="line">  onDrawForeground(canvas);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>绘制背景</li><li>如有必要，保存图层，绘制边界的渐变效果</li><li>绘制内容</li><li>绘制子元素</li><li>恢复2中保存的图层</li><li>绘制前景（滚动条等）</li></ol><p>通过重写<code>onDraw()</code>来绘制内容</p><p><em>View.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>View的<code>onDraw()</code>是空的，需要子类实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dispatchDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也是由子类实现，在子元素被绘制之前进行控制</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><h4 id="ViewGroup"><a href="#ViewGroup" class="headerlink" title="ViewGroup"></a>ViewGroup</h4><p>ViewGroup是View的子类</p><p>ViewGroup没有重写<code>onMeasure()</code>，使用的是View的默认实现</p><p><em>ViewGroup.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span></span>;</span><br></pre></td></tr></table></figure><p><code>onLayout()</code>是个抽象函数，一定要在子类中重写（因为ViewGroup就是用来布局子元素的）</p><p>ViewGroup没有重写<code>onDraw()</code>，所以也是空实现</p><h4 id="LinearLayout"><a href="#LinearLayout" class="headerlink" title="LinearLayout"></a>LinearLayout</h4><p><em>LinearLayout.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (mOrientation == VERTICAL) &#123;</span><br><span class="line">    measureVertical(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    measureHorizontal(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据方向进行测量，以竖直方向为例</p><p><em>LinearLayout.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">measureVertical</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">  mTotalLength = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> maxWidth = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">boolean</span> allFillParent = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">int</span> alternativeMaxWidth = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> count = getVirtualChildCount();</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> widthMode = MeasureSpec.getMode(widthMeasureSpec);</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> heightMode = MeasureSpec.getMode(heightMeasureSpec);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 遍历子元素</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">    <span class="keyword">final</span> View child = getVirtualChildAt(i);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 子元素为空的处理 measureNullChild()返回0 继续下一轮</span></span><br><span class="line">    <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">      mTotalLength += measureNullChild(i);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 子元素不可见的处理 getChildrenSkipCount()返回0 继续下一轮</span></span><br><span class="line">    <span class="keyword">if</span> (child.getVisibility() == View.GONE) &#123;</span><br><span class="line">      i += getChildrenSkipCount(child, i);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 处理分割线</span></span><br><span class="line">    <span class="keyword">if</span> (hasDividerBeforeChildAt(i)) &#123;</span><br><span class="line">      mTotalLength += mDividerHeight;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();</span><br><span class="line">    totalWeight += lp.weight;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (heightMode == MeasureSpec.EXACTLY &amp;&amp; lp.height == <span class="number">0</span> &amp;&amp; lp.weight &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">int</span> totalLength = mTotalLength;</span><br><span class="line">      mTotalLength = Math.max(totalLength, totalLength + lp.topMargin + lp.bottomMargin);</span><br><span class="line">      skippedMeasure = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">int</span> oldHeight = Integer.MIN_VALUE;</span><br><span class="line">      <span class="keyword">if</span> (lp.height == <span class="number">0</span> &amp;&amp; lp.weight &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        oldHeight = <span class="number">0</span>;</span><br><span class="line">        lp.height = LayoutParams.WRAP_CONTENT;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 测量子元素</span></span><br><span class="line">      measureChildBeforeLayout(child, i, widthMeasureSpec, <span class="number">0</span>, heightMeasureSpec, totalWeight == <span class="number">0</span> ? mTotalLength : <span class="number">0</span>);</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (oldHeight != Integer.MIN_VALUE) &#123;</span><br><span class="line">        lp.height = oldHeight;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">int</span> childHeight = child.getMeasuredHeight();</span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">int</span> totalLength = mTotalLength;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 获得新的总高度 子元素高度+Margin+偏移</span></span><br><span class="line">      mTotalLength = Math.max(totalLength, totalLength + childHeight + lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (useLargestChild) &#123;</span><br><span class="line">        largestChildHeight = Math.max(childHeight, largestChildHeight);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> matchWidthLocally = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 有子元素是MATCH_PARENT的 并且没有确切的宽度 需要重新测量</span></span><br><span class="line">    <span class="keyword">if</span> (widthMode != MeasureSpec.EXACTLY &amp;&amp; lp.width == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">      matchWidth = <span class="keyword">true</span>;</span><br><span class="line">      matchWidthLocally = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算宽度</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> margin = lp.leftMargin + lp.rightMargin;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> measuredWidth = child.getMeasuredWidth() + margin;</span><br><span class="line">    maxWidth = Math.max(maxWidth, measuredWidth);</span><br><span class="line">    childState = combineMeasuredStates(childState, child.getMeasuredState());</span><br><span class="line">    </span><br><span class="line">    allFillParent = allFillParent &amp;&amp; lp.width == LayoutParams.MATCH_PARENT;</span><br><span class="line">    <span class="keyword">if</span> (lp.weight &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      weightedMaxWidth = Math.max(weightedMaxWidth, matchWidthLocally ? margin : measuredWidth);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      alternativeMaxWidth = Math.max(alternativeMaxWidth, matchWidthLocally ? margin : measuredWidth);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    i += getChildrenSkipCount(child, i);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 最后一个分割线</span></span><br><span class="line">  <span class="keyword">if</span> (mTotalLength &gt; <span class="number">0</span> &amp;&amp; hasDividerBeforeChildAt(count)) &#123;</span><br><span class="line">    mTotalLength += mDividerHeight;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (useLargestChild &amp;&amp; (heightMode == MeasureSpec.AT_MOST || heightMode == MeasureSpec.UNSPECIFIED)) &#123;</span><br><span class="line">    ......</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 计算Padding</span></span><br><span class="line">  mTotalLength += mPaddingTop + mPaddingBottom;</span><br><span class="line">  <span class="keyword">int</span> heightSize = mTotalLength;</span><br><span class="line">  heightSize = Math.max(heightSize, getSuggestedMinimumHeight());</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> heightSizeAndState = resolveSizeAndState(heightSize, heightMeasureSpec, <span class="number">0</span>);</span><br><span class="line">  heightSize = heightSizeAndState &amp; MEASURED_SIZE_MASK;</span><br><span class="line">  <span class="keyword">int</span> delta = heightSize - mTotalLength;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (skippedMeasure || delta != <span class="number">0</span> &amp;&amp; totalWeight &gt; <span class="number">0.0f</span>) &#123;</span><br><span class="line">    <span class="comment">// 计算总weight</span></span><br><span class="line">    <span class="keyword">float</span> weightSum = mWeightSum &gt; <span class="number">0.0f</span> ? mWeightSum : totalWeight;</span><br><span class="line">    mTotalLength = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">      <span class="keyword">final</span> View child = getVirtualChildAt(i);</span><br><span class="line">      <span class="keyword">if</span> (child.getVisibility() == View.GONE) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();</span><br><span class="line">      <span class="keyword">float</span> childExtra = lp.weight;</span><br><span class="line">      <span class="keyword">if</span> (childExtra &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 分配给带weight的子元素额外空间</span></span><br><span class="line">        <span class="keyword">int</span> share = (<span class="keyword">int</span>) (childExtra * delta / weightSum);</span><br><span class="line">        weightSum -= childExtra;</span><br><span class="line">        delta -= share;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 用默认方式获得子元素的WidthMeasureSpec</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> childWidthMeasureSpec = getChildMeasureSpec(widthMeasureSpec, mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin, lp.width);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((lp.height != <span class="number">0</span>) || (heightMode != MeasureSpec.EXACTLY)) &#123;</span><br><span class="line">          <span class="comment">// 说明上面测量过</span></span><br><span class="line">          <span class="keyword">int</span> childHeight = child.getMeasuredHeight() + share;</span><br><span class="line">          <span class="keyword">if</span> (childHeight &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            childHeight = <span class="number">0</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 测量子元素</span></span><br><span class="line">          <span class="comment">// 这里HeightMeasureSpec是自己构造出来的 明确的指定大小</span></span><br><span class="line">          child.measure(childWidthMeasureSpec, MeasureSpec.makeMeasureSpec(childHeight, MeasureSpec.EXACTLY));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          child.measure(childWidthMeasureSpec, MeasureSpec.makeMeasureSpec(share &gt; <span class="number">0</span> ? share : <span class="number">0</span>, MeasureSpec.EXACTLY));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        childState = combineMeasuredStates(childState, child.getMeasuredState() &amp; (MEASURED_STATE_MASK&gt;&gt;MEASURED_HEIGHT_STATE_SHIFT));</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">int</span> margin =  lp.leftMargin + lp.rightMargin;</span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">int</span> measuredWidth = child.getMeasuredWidth() + margin;</span><br><span class="line">      maxWidth = Math.max(maxWidth, measuredWidth);</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">boolean</span> matchWidthLocally = widthMode != MeasureSpec.EXACTLY &amp;&amp; lp.width == LayoutParams.MATCH_PARENT;</span><br><span class="line">      alternativeMaxWidth = Math.max(alternativeMaxWidth, matchWidthLocally ? margin : measuredWidth);</span><br><span class="line">      allFillParent = allFillParent &amp;&amp; lp.width == LayoutParams.MATCH_PARENT;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">int</span> totalLength = mTotalLength;</span><br><span class="line">      mTotalLength = Math.max(totalLength, totalLength + child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    mTotalLength += mPaddingTop + mPaddingBottom;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    alternativeMaxWidth = Math.max(alternativeMaxWidth, weightedMaxWidth);</span><br><span class="line">    <span class="keyword">if</span> (useLargestChild &amp;&amp; heightMode != MeasureSpec.EXACTLY) &#123;</span><br><span class="line">      ......</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (!allFillParent &amp;&amp; widthMode != MeasureSpec.EXACTLY) &#123;</span><br><span class="line">    maxWidth = alternativeMaxWidth;</span><br><span class="line">  &#125;</span><br><span class="line">        </span><br><span class="line">  maxWidth += mPaddingLeft + mPaddingRight;</span><br><span class="line">  maxWidth = Math.max(maxWidth, getSuggestedMinimumWidth());</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 设置测量的宽高</span></span><br><span class="line">  setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState), heightSizeAndState);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (matchWidth) &#123;</span><br><span class="line">    forceUniformWidth(count, heightMeasureSpec);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>遍历子元素，子元素未设置<code>weight</code>则进行测量，否则跳过</li><li>如果有跳过测量的元素或有剩余的空间，则进行第二次遍历，处理设置<code>weight</code>的元素</li><li><code>setMeasuredDimension()</code></li></ol><p><em>ViewGroup.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getChildMeasureSpec</span><span class="params">(<span class="keyword">int</span> spec, <span class="keyword">int</span> padding, <span class="keyword">int</span> childDimension)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// spec是父元素的MeasureSpec 表示父元素的限制</span></span><br><span class="line">  <span class="comment">// padding在这里是子元素的左右margin+父元素的左右padding</span></span><br><span class="line">  <span class="comment">// childDimension是子元素LayoutParams.width</span></span><br><span class="line">  <span class="keyword">int</span> specMode = MeasureSpec.getMode(spec);</span><br><span class="line">  <span class="keyword">int</span> specSize = MeasureSpec.getSize(spec);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 参考宽度＝父元素给定的宽度-各种边距</span></span><br><span class="line">  <span class="keyword">int</span> size = Math.max(<span class="number">0</span>, specSize - padding);</span><br><span class="line">  <span class="keyword">int</span> resultSize = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> resultMode = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">switch</span> (specMode) &#123;</span><br><span class="line">    <span class="comment">// 父元素指定了一个确定值</span></span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.EXACTLY:</span><br><span class="line">      <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// lp.width有确定值</span></span><br><span class="line">        <span class="comment">// 则取该值 模式为EXACTLY</span></span><br><span class="line">        resultSize = childDimension;</span><br><span class="line">        resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">        <span class="comment">// lp.width为match_parent</span></span><br><span class="line">        <span class="comment">// 取参考宽度 模式为EXACTLY</span></span><br><span class="line">        resultSize = size;</span><br><span class="line">        resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">        <span class="comment">// lp.width为wrap_content</span></span><br><span class="line">        <span class="comment">// 取参考宽度 模式为AT_MOST</span></span><br><span class="line">        resultSize = size;</span><br><span class="line">        resultMode = MeasureSpec.AT_MOST;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 父元素给定最大值</span></span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.AT_MOST:</span><br><span class="line">      <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// lp.width有确定值</span></span><br><span class="line">        <span class="comment">// 则取该值 模式为EXACTLY            </span></span><br><span class="line">        resultSize = childDimension;</span><br><span class="line">        resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">        <span class="comment">// lp.width为match_parent</span></span><br><span class="line">        <span class="comment">// 但父元素大小也不确定</span></span><br><span class="line">        <span class="comment">// 取参考宽度 模式为AT_MOST</span></span><br><span class="line">        resultSize = size;</span><br><span class="line">        resultMode = MeasureSpec.AT_MOST;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">        <span class="comment">// lp.width为wrap_content</span></span><br><span class="line">        <span class="comment">// 取参考宽度 模式为AT_MOST</span></span><br><span class="line">        resultSize = size;</span><br><span class="line">        resultMode = MeasureSpec.AT_MOST;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 父元素无限制</span></span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</span><br><span class="line">      <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// lp.width有确定值</span></span><br><span class="line">        <span class="comment">// 则取该值 模式为EXACTLY             </span></span><br><span class="line">        resultSize = childDimension;</span><br><span class="line">        resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">        <span class="comment">// lp.width为match_parent</span></span><br><span class="line">        <span class="comment">// 但父元素大小也不确定</span></span><br><span class="line">        <span class="comment">// 取参考宽度 模式为UNSPECIFIED</span></span><br><span class="line">        resultSize = View.sUseZeroUnspecifiedMeasureSpec ? <span class="number">0</span> : size;</span><br><span class="line">        resultMode = MeasureSpec.UNSPECIFIED;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">        <span class="comment">// lp.width为wrap_content</span></span><br><span class="line">        <span class="comment">// 取参考宽度 模式为UNSPECIFIED</span></span><br><span class="line">        resultSize = View.sUseZeroUnspecifiedMeasureSpec ? <span class="number">0</span> : size;</span><br><span class="line">        resultMode = MeasureSpec.UNSPECIFIED;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> MeasureSpec.makeMeasureSpec(resultSize, resultMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>布局生成MeasureSpec的默认方法，综合考虑父元素传入的MeasureSpec和子元素的LayoutParams</p><p><em>LinearLayout.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mOrientation == VERTICAL) &#123;</span><br><span class="line">        layoutVertical(l, t, r, b);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        layoutHorizontal(l, t, r, b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也是根据方向进行布局，以竖直方向为例</p><p><em>LinearLayout.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">layoutVertical</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> paddingLeft = mPaddingLeft;</span><br><span class="line">  <span class="keyword">int</span> childTop;</span><br><span class="line">  <span class="keyword">int</span> childLeft;</span><br><span class="line">        </span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> width = right - left;</span><br><span class="line">  <span class="keyword">int</span> childRight = width - mPaddingRight;</span><br><span class="line">  <span class="keyword">int</span> childSpace = width - paddingLeft - mPaddingRight;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> count = getVirtualChildCount();</span><br><span class="line">  <span class="comment">// 可见主Gravity是竖直方向的 次Gravity是水平方向的</span></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> majorGravity = mGravity &amp; Gravity.VERTICAL_GRAVITY_MASK;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> minorGravity = mGravity &amp; Gravity.RELATIVE_HORIZONTAL_GRAVITY_MASK;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 考察竖直方向的Gravity 这里用的是父布局的值</span></span><br><span class="line">  <span class="keyword">switch</span> (majorGravity) &#123;</span><br><span class="line">    <span class="keyword">case</span> Gravity.BOTTOM:</span><br><span class="line">      childTop = mPaddingTop + (bottom - top - mTotalLength);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> Gravity.CENTER_VERTICAL:</span><br><span class="line">      childTop = mPaddingTop + (bottom - top - mTotalLength) / <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> Gravity.TOP:</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      childTop = mPaddingTop;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 遍历子元素</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">    <span class="keyword">final</span> View child = getVirtualChildAt(i);</span><br><span class="line">    <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">      childTop += measureNullChild(i);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (child.getVisibility() != GONE) &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">int</span> childWidth = child.getMeasuredWidth();</span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">int</span> childHeight = child.getMeasuredHeight();</span><br><span class="line">      <span class="keyword">final</span> LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();</span><br><span class="line">      <span class="comment">// 如果子元素没有设置Gravity 那么设置父Gravity的次Gravity给它</span></span><br><span class="line">      <span class="comment">// 对于一个竖直布局来说 子元素的水平Gravity才是有效的</span></span><br><span class="line">      <span class="keyword">int</span> gravity = lp.gravity;</span><br><span class="line">      <span class="keyword">if</span> (gravity &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        gravity = minorGravity;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">int</span> layoutDirection = getLayoutDirection();</span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">int</span> absoluteGravity = Gravity.getAbsoluteGravity(gravity, layoutDirection);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 考察子元素的水平Gravity</span></span><br><span class="line">      <span class="keyword">switch</span> (absoluteGravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK) &#123;</span><br><span class="line">        <span class="keyword">case</span> Gravity.CENTER_HORIZONTAL:</span><br><span class="line">          childLeft = paddingLeft + ((childSpace - childWidth) / <span class="number">2</span>) + lp.leftMargin - lp.rightMargin;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Gravity.RIGHT:</span><br><span class="line">          childLeft = childRight - childWidth - lp.rightMargin;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Gravity.LEFT:</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">          childLeft = paddingLeft + lp.leftMargin;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 处理分割线</span></span><br><span class="line">      <span class="keyword">if</span> (hasDividerBeforeChildAt(i)) &#123;</span><br><span class="line">        childTop += mDividerHeight;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 增加上边距</span></span><br><span class="line">      childTop += lp.topMargin;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 子元素布局</span></span><br><span class="line">      setChildFrame(child, childLeft, childTop + getLocationOffset(child), childWidth, childHeight);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 增加高度+下边距+偏移</span></span><br><span class="line">      childTop += childHeight + lp.bottomMargin + getNextLocationOffset(child);</span><br><span class="line">      i += getChildrenSkipCount(child, i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先根据父布局的Gravity来确定竖直方向的位置，然后遍历子元素LayoutParams中的Gravity来确定水平方向的位置并调用子元素的<code>layout()</code></p><p><em>LinearLayout.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (mDivider == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (mOrientation == VERTICAL) &#123;</span><br><span class="line">    drawDividersVertical(canvas);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    drawDividersHorizontal(canvas);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也是根据方向进行绘制，对<code>mDivider</code>进行了判断，可见主要就是进行了分割线的绘制，以竖直方向为例</p><p><em>LinearLayout.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">drawDividersVertical</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> count = getVirtualChildCount();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 遍历绘制每个子元素之前的分割线</span></span><br><span class="line">  <span class="comment">// 综合考虑子元素的位置以及Divider设置</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">    <span class="keyword">final</span> View child = getVirtualChildAt(i);</span><br><span class="line">    <span class="keyword">if</span> (child != <span class="keyword">null</span> &amp;&amp; child.getVisibility() != GONE) &#123;</span><br><span class="line">      <span class="keyword">if</span> (hasDividerBeforeChildAt(i)) &#123;</span><br><span class="line">        <span class="keyword">final</span> LayoutParams lp = (LayoutParams) child.getLayoutParams();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> top = child.getTop() - lp.topMargin - mDividerHeight;</span><br><span class="line">        drawHorizontalDivider(canvas, top);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 最后的分割线</span></span><br><span class="line">  <span class="keyword">if</span> (hasDividerBeforeChildAt(count)) &#123;</span><br><span class="line">    <span class="keyword">final</span> View child = getLastNonGoneChild();</span><br><span class="line">    <span class="keyword">int</span> bottom = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">      bottom = getHeight() - getPaddingBottom() - mDividerHeight;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">final</span> LayoutParams lp = (LayoutParams) child.getLayoutParams();</span><br><span class="line">      bottom = child.getBottom() + lp.bottomMargin;</span><br><span class="line">    &#125;</span><br><span class="line">    drawHorizontalDivider(canvas, bottom);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="RelativeLayout"><a href="#RelativeLayout" class="headerlink" title="RelativeLayout"></a>RelativeLayout</h4><p><em>RelativeLayout.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">boolean</span> isWrapContentWidth = widthMode != MeasureSpec.EXACTLY;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">boolean</span> isWrapContentHeight = heightMode != MeasureSpec.EXACTLY;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 整理子元素</span></span><br><span class="line">  <span class="comment">// 水平和竖直方向各有一个数组，用来保存排序的子元素 排序是根据依赖 比如A依赖B B依赖C 存放顺序就是C-B-A</span></span><br><span class="line">  <span class="comment">// 通过DependencyGraph来完成</span></span><br><span class="line">  <span class="keyword">if</span> (mDirtyHierarchy) &#123;</span><br><span class="line">    mDirtyHierarchy = <span class="keyword">false</span>;</span><br><span class="line">    sortChildren();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  ......</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 水平方向子元素的处理</span></span><br><span class="line">  View[] views = mSortedHorizontalChildren;</span><br><span class="line">  <span class="keyword">int</span> count = views.length;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">    View child = views[i];</span><br><span class="line">    <span class="keyword">if</span> (child.getVisibility() != GONE) &#123;</span><br><span class="line">      LayoutParams params = (LayoutParams) child.getLayoutParams();</span><br><span class="line">      <span class="keyword">int</span>[] rules = params.getRules(layoutDirection);</span><br><span class="line">      <span class="comment">// 应用水平方向布局规则</span></span><br><span class="line">      <span class="comment">// 即通过LEFT_OF这类的规则找到关联元素 获得它的LayoutParams 用来调整自己的LayoutParams</span></span><br><span class="line">      <span class="comment">// 主要是mLeft和mRight</span></span><br><span class="line">      applyHorizontalSizeRules(params, myWidth, rules);</span><br><span class="line">      <span class="comment">// 水平方向测量子元素</span></span><br><span class="line">      measureChildHorizontal(child, params, myWidth, myHeight);</span><br><span class="line">      <span class="comment">// 定位子元素 调整mLeft和mRight</span></span><br><span class="line">      <span class="keyword">if</span> (positionChildHorizontal(child, params, myWidth, isWrapContentWidth)) &#123;</span><br><span class="line">        offsetHorizontalAxis = <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 竖直方向子元素的处理</span></span><br><span class="line">  views = mSortedVerticalChildren;</span><br><span class="line">  count = views.length;</span><br><span class="line">  <span class="keyword">int</span> targetSdkVersion = getContext().getApplicationInfo().targetSdkVersion;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">    <span class="keyword">final</span> View child = views[i];</span><br><span class="line">    <span class="keyword">if</span> (child.getVisibility() != GONE) &#123;</span><br><span class="line">      <span class="keyword">final</span> LayoutParams params = (LayoutParams) child.getLayoutParams();</span><br><span class="line">      <span class="comment">// 应用竖直方向布局规则</span></span><br><span class="line">      <span class="comment">// 即通过ABOVE这类的规则找到关联元素 获得它的LayoutParams 用来调整自己的LayoutParams</span></span><br><span class="line">      <span class="comment">// 主要是mTop和mBottom</span></span><br><span class="line">      applyVerticalSizeRules(params, myHeight, child.getBaseline());</span><br><span class="line">      <span class="comment">// 测量子元素</span></span><br><span class="line">      measureChild(child, params, myWidth, myHeight);</span><br><span class="line">      <span class="comment">// 定位子元素 调整mTop和mBottom</span></span><br><span class="line">      <span class="keyword">if</span> (positionChildVertical(child, params, myHeight, isWrapContentHeight)) &#123;</span><br><span class="line">        offsetVerticalAxis = <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 如果宽度是包裹子元素的 如下处理</span></span><br><span class="line">      <span class="keyword">if</span> (isWrapContentWidth) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isLayoutRtl()) &#123;</span><br><span class="line">          <span class="keyword">if</span> (targetSdkVersion &lt; Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">            width = Math.max(width, myWidth - params.mLeft);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            width = Math.max(width, myWidth - params.mLeft - params.leftMargin);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (targetSdkVersion &lt; Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">            width = Math.max(width, params.mRight);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            width = Math.max(width, params.mRight + params.rightMargin);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果高度是包裹子元素的 如下处理</span></span><br><span class="line">      <span class="keyword">if</span> (isWrapContentHeight) &#123;</span><br><span class="line">        <span class="keyword">if</span> (targetSdkVersion &lt; Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">          height = Math.max(height, params.mBottom);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          height = Math.max(height, params.mBottom + params.bottomMargin);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (child != ignore || verticalGravity) &#123;</span><br><span class="line">        left = Math.min(left, params.mLeft - params.leftMargin);</span><br><span class="line">        top = Math.min(top, params.mTop - params.topMargin);</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (child != ignore || horizontalGravity) &#123;</span><br><span class="line">        right = Math.max(right, params.mRight + params.rightMargin);</span><br><span class="line">        bottom = Math.max(bottom, params.mBottom + params.bottomMargin);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 各种布局参数的设置</span></span><br><span class="line">  <span class="comment">// 居中 尾部对齐(右对齐／底部对齐)</span></span><br><span class="line">  <span class="comment">// Gravity调整</span></span><br><span class="line">  ......</span><br><span class="line">  </span><br><span class="line">  setMeasuredDimension(width, height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>如有必要，解析子元素的依赖关系，按顺序保存在全局数组里</li><li>水平方向处理子元素，应用布局规则，水平测量子元素</li><li>竖直方向处理子元素，应用布局规则，测量子元素</li><li>调整居中／右对齐／底部对齐／Gravity</li><li><code>setMeasuredDimension()</code></li></ol><p><em>RelativeLayout.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> count = getChildCount();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">    View child = getChildAt(i);</span><br><span class="line">    <span class="keyword">if</span> (child.getVisibility() != GONE) &#123;</span><br><span class="line">      RelativeLayout.LayoutParams st = (RelativeLayout.LayoutParams) child.getLayoutParams();</span><br><span class="line">      child.layout(st.mLeft, st.mTop, st.mRight, st.mBottom);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>onLayout()</code>很简单，因为测量的时候每个子元素的边界都保存在布局参数里了，这里直接用它们进行布局</p><p>RelativeLayout并没有重写<code>onDraw()</code>，所以是空实现</p><h4 id="FrameLayout"><a href="#FrameLayout" class="headerlink" title="FrameLayout"></a>FrameLayout</h4><p><em>FrameLayout.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> count = getChildCount();</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">boolean</span> measureMatchParentChildren = MeasureSpec.getMode(widthMeasureSpec) != MeasureSpec.EXACTLY || MeasureSpec.getMode(heightMeasureSpec) != MeasureSpec.EXACTLY;</span><br><span class="line">  mMatchParentChildren.clear();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> maxHeight = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> maxWidth = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> childState = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">    <span class="keyword">final</span> View child = getChildAt(i);</span><br><span class="line">    <span class="keyword">if</span> (mMeasureAllChildren || child.getVisibility() != GONE) &#123;</span><br><span class="line">      <span class="comment">// 测量子元素</span></span><br><span class="line">      measureChildWithMargins(child, widthMeasureSpec, <span class="number">0</span>, heightMeasureSpec, <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">final</span> LayoutParams lp = (LayoutParams) child.getLayoutParams();</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 获得最大的宽度和高度</span></span><br><span class="line">      maxWidth = Math.max(maxWidth, child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin);</span><br><span class="line">      maxHeight = Math.max(maxHeight, child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin);</span><br><span class="line">      childState = combineMeasuredStates(childState, child.getMeasuredState());</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (measureMatchParentChildren) &#123;</span><br><span class="line">        <span class="keyword">if</span> (lp.width == LayoutParams.MATCH_PARENT || lp.height == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">          mMatchParentChildren.add(child);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理Padding</span></span><br><span class="line">  maxWidth += getPaddingLeftWithForeground() + getPaddingRightWithForeground();</span><br><span class="line">  maxHeight += getPaddingTopWithForeground() + getPaddingBottomWithForeground();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检查宽高</span></span><br><span class="line">  maxHeight = Math.max(maxHeight, getSuggestedMinimumHeight());</span><br><span class="line">  maxWidth = Math.max(maxWidth, getSuggestedMinimumWidth());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检查前景宽高</span></span><br><span class="line">  <span class="keyword">final</span> Drawable drawable = getForeground();</span><br><span class="line">  <span class="keyword">if</span> (drawable != <span class="keyword">null</span>) &#123;</span><br><span class="line">    maxHeight = Math.max(maxHeight, drawable.getMinimumHeight());</span><br><span class="line">    maxWidth = Math.max(maxWidth, drawable.getMinimumWidth());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置宽高</span></span><br><span class="line">  setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState), resolveSizeAndState(maxHeight, heightMeasureSpec, childState &lt;&lt; MEASURED_HEIGHT_STATE_SHIFT));</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 处理match_parent的子元素</span></span><br><span class="line">  count = mMatchParentChildren.size();</span><br><span class="line">  <span class="keyword">if</span> (count &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">      <span class="keyword">final</span> View child = mMatchParentChildren.get(i);</span><br><span class="line">      <span class="keyword">final</span> MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">int</span> childWidthMeasureSpec;</span><br><span class="line">      <span class="comment">// 水平方向</span></span><br><span class="line">      <span class="keyword">if</span> (lp.width == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> width = Math.max(<span class="number">0</span>, getMeasuredWidth() - getPaddingLeftWithForeground() - getPaddingRightWithForeground() - lp.leftMargin - lp.rightMargin);</span><br><span class="line">        <span class="comment">// 设置明确的宽度</span></span><br><span class="line">        childWidthMeasureSpec = MeasureSpec.makeMeasureSpec(width, MeasureSpec.EXACTLY);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 默认实现获得MeasureSpec</span></span><br><span class="line">        childWidthMeasureSpec = getChildMeasureSpec(widthMeasureSpec, getPaddingLeftWithForeground() + getPaddingRightWithForeground() + lp.leftMargin + lp.rightMargin, lp.width);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">int</span> childHeightMeasureSpec;</span><br><span class="line">      <span class="keyword">if</span> (lp.height == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">        <span class="comment">// 设置明确的高度</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> height = Math.max(<span class="number">0</span>, getMeasuredHeight() - getPaddingTopWithForeground() - getPaddingBottomWithForeground() - lp.topMargin - lp.bottomMargin);</span><br><span class="line">        childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(height, MeasureSpec.EXACTLY);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 默认实现获得MeasureSpec</span></span><br><span class="line">        childHeightMeasureSpec = getChildMeasureSpec(heightMeasureSpec, getPaddingTopWithForeground() + getPaddingBottomWithForeground() + lp.topMargin + lp.bottomMargin, lp.height);</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 测量子元素</span></span><br><span class="line">      child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>遍历测量子元素</li><li><code>setMeasuredDimension()</code></li><li>如果有布局参数是<code>match_parent</code> 的，需要用新的宽度得到MeasureSpec再次测量</li></ol><p><em>FrameLayout.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span> </span>&#123;</span><br><span class="line">    layoutChildren(left, top, right, bottom, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">layoutChildren</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom, <span class="keyword">boolean</span> forceLeftGravity)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> count = getChildCount();</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> parentLeft = getPaddingLeftWithForeground();</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> parentRight = right - left - getPaddingRightWithForeground();</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> parentTop = getPaddingTopWithForeground();</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> parentBottom = bottom - top - getPaddingBottomWithForeground();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">    <span class="keyword">final</span> View child = getChildAt(i);</span><br><span class="line">    <span class="keyword">if</span> (child.getVisibility() != GONE) &#123;</span><br><span class="line">      <span class="keyword">final</span> LayoutParams lp = (LayoutParams) child.getLayoutParams();</span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">int</span> width = child.getMeasuredWidth();</span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">int</span> height = child.getMeasuredHeight();</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">int</span> childLeft;</span><br><span class="line">      <span class="keyword">int</span> childTop;</span><br><span class="line">      <span class="keyword">int</span> gravity = lp.gravity;</span><br><span class="line">      <span class="keyword">if</span> (gravity == -<span class="number">1</span>) &#123;</span><br><span class="line">        gravity = DEFAULT_CHILD_GRAVITY;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">int</span> layoutDirection = getLayoutDirection();</span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">int</span> absoluteGravity = Gravity.getAbsoluteGravity(gravity, layoutDirection);</span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">int</span> verticalGravity = gravity &amp; Gravity.VERTICAL_GRAVITY_MASK;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 水平方向</span></span><br><span class="line">      <span class="keyword">switch</span> (absoluteGravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK) &#123;</span><br><span class="line">        <span class="keyword">case</span> Gravity.CENTER_HORIZONTAL:</span><br><span class="line">          childLeft = parentLeft + (parentRight - parentLeft - width) / <span class="number">2</span> + lp.leftMargin - lp.rightMargin;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Gravity.RIGHT:</span><br><span class="line">          <span class="keyword">if</span> (!forceLeftGravity) &#123;</span><br><span class="line">            childLeft = parentRight - width - lp.rightMargin;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        <span class="keyword">case</span> Gravity.LEFT:</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">          childLeft = parentLeft + lp.leftMargin;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 竖直方向</span></span><br><span class="line">      <span class="keyword">switch</span> (verticalGravity) &#123;</span><br><span class="line">        <span class="keyword">case</span> Gravity.TOP:</span><br><span class="line">          childTop = parentTop + lp.topMargin;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Gravity.CENTER_VERTICAL:</span><br><span class="line">          childTop = parentTop + (parentBottom - parentTop - height) / <span class="number">2</span> + lp.topMargin - lp.bottomMargin;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Gravity.BOTTOM:</span><br><span class="line">          childTop = parentBottom - height - lp.bottomMargin;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">          childTop = parentTop + lp.topMargin;</span><br><span class="line">      &#125;</span><br><span class="line">      child.layout(childLeft, childTop, childLeft + width, childTop + height);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遍历子元素，根据Gravity参数布局</p><p>FrameLayout也没有重写<code>onDraw()</code>， 为空实现</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;View的绘制原理&quot;&gt;&lt;a href=&quot;#View的绘制原理&quot; class=&quot;headerlink&quot; title=&quot;View的绘制原理&quot;&gt;&lt;/a&gt;View的绘制原理&lt;/h2&gt;&lt;p&gt;Android的View绘制都要经过测量，布局和绘制三个步骤&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://lakeshire.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://lakeshire.github.io/tags/Android/"/>
    
      <category term="View" scheme="http://lakeshire.github.io/tags/View/"/>
    
  </entry>
  
  <entry>
    <title>Handler机制</title>
    <link href="http://lakeshire.github.io/2017/11/29//archivers/handler/"/>
    <id>http://lakeshire.github.io/2017/11/29//archivers/handler/</id>
    <published>2017-11-29T04:00:00.000Z</published>
    <updated>2017-11-29T09:17:23.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h2><p>Handler是Android中常用的线程间通信机制</p><p>Android是不允许在UI线程进行耗时的网络操作，所以一般会在工作线程中执行网络请求，得到返回数据后通知UI线程更新界面，这就可以通过Handler实现</p><p><img src="http://7xt3ho.com1.z0.glb.clouddn.com/e03907fead023dc753bf8777548d3bac_b.png" alt=""></p><a id="more"></a><h3 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h3><h4 id="Handler-1"><a href="#Handler-1" class="headerlink" title="Handler"></a>Handler</h4><p>首先需要创建一个Handler，所以先看一下Handler的构造函数，Handler有几个版本的构造函数</p><p><em>Handler.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Looper looper, Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">  mLooper = looper;</span><br><span class="line">  mQueue = looper.mQueue;</span><br><span class="line">  mCallback = callback;</span><br><span class="line">  mAsynchronous = async;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个构造函数接受三个参数，第一个指定对应的Looper，第二个指定全局的回调函数，第三个指定是同步还是异步</p><p><em>Handler.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">  mLooper = Looper.myLooper();</span><br><span class="line">  <span class="keyword">if</span> (mLooper == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Can't create handler inside thread that has not called Looper.prepare()"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  mQueue = mLooper.mQueue;</span><br><span class="line">  mCallback = callback;</span><br><span class="line">  mAsynchronous = async;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个构造函数接受两个参数，没有传入Looper，Looper在构造函数中由<code>Looper.myLooper()</code>创建</p><p>当mLooper为空时会抛出一个常见的异常，说明在创建Handler之前必须调用<code>Looper.prepare()</code></p><p>由此我们获得了消息循环mLooper，消息队列mQueue，全局回调mCallback</p><h4 id="Looper"><a href="#Looper" class="headerlink" title="Looper"></a>Looper</h4><p><em>Looper.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="meta">@Nullable</span> <span class="function">Looper <span class="title">myLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> sThreadLocal.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>myLooper()</code>返回了当前线程的一个Looper</p><p><em>Looper.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个线程本地变量Looper是在<code>prepare()</code>里创建的，如果反复调用则会抛异常，意思是一个线程只能有一个Looper</p><p><em>Looper.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Looper</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">  mQueue = <span class="keyword">new</span> MessageQueue(quitAllowed);</span><br><span class="line">  mThread = Thread.currentThread();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Looper的构造函数里，创建了一个消息队列mQueue，并把当前的线程设置给mThread</p><h4 id="MessageQueue"><a href="#MessageQueue" class="headerlink" title="MessageQueue"></a>MessageQueue</h4><p><em>MessageQueue.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MessageQueue(<span class="keyword">boolean</span> quitAllowed) &#123;</span><br><span class="line">  mQuitAllowed = quitAllowed;</span><br><span class="line">  mPtr = nativeInit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消息队列的构造函数，可见调用了Native层的相关函数<code>nativeInit()</code></p><h4 id="Message"><a href="#Message" class="headerlink" title="Message"></a>Message</h4><p>定义了一个消息，包含了描述和可被发送给Handler的数据对象，这个对象包含两个额外的int域和一个额外的object域，允许你在很多场合不用做内存分配</p><p>尽管构造函数是public的，最好的方式是<code>obtain()</code>或者<code>obtainMessage()</code>，将从一个回收对象的池中获得对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (sPoolSync) &#123;</span><br><span class="line">    <span class="keyword">if</span> (sPool != <span class="keyword">null</span>) &#123;</span><br><span class="line">      Message m = sPool;</span><br><span class="line">      sPool = m.next;</span><br><span class="line">      m.next = <span class="keyword">null</span>;</span><br><span class="line">      m.flags = <span class="number">0</span>;</span><br><span class="line">      sPoolSize--;</span><br><span class="line">      <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Message();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Message里面有一个<code>next</code>的Message域，整个就是一个链式结构<br>所以<code>sPool</code>也是一个消息池的链，在从池中取出<code>sPool</code>这个消息时，<code>sPool</code>本身被赋值为<code>sPool.next</code>，池大小减1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_POOL_SIZE = <span class="number">50</span>;</span><br></pre></td></tr></table></figure><h4 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h4><p>一般通过<code>sendMessage()</code>这系列的函数发送消息，都要获得一个Message，设置消息类型和内容，立即或延时发送消息，最终是调用<code>sendMessageAtTime()</code></p><p><em>Handler.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessageAtTime</span><span class="params">(Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">  MessageQueue queue = mQueue;</span><br><span class="line">  <span class="keyword">if</span> (queue == <span class="keyword">null</span>) &#123;</span><br><span class="line">    RuntimeException e = <span class="keyword">new</span> RuntimeException(<span class="keyword">this</span> + <span class="string">" sendMessageAtTime() called with no mQueue"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>检查是否有消息队列，没有的话会抛异常，然后调用<code>enqueueMessage()</code>把消息放入队列</p><p><em>Handler.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(MessageQueue queue, Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">  msg.target = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">if</span> (mAsynchronous) &#123;</span><br><span class="line">    msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先设置了消息的<code>target</code>字段为本Handler，然后调用MessageQueue的<code>queueMessage()</code>方法</p><p>从<code>enqueueMessage()</code>放进队列的消息的<code>target</code>都被设置了值，而后面有判断<code>target</code>为空的地方</p><p><code>MessageQueue</code>里有一个<code>postSyncBarrier()</code>方法，用来添加一个同步屏障</p><p>消息分为同步和异步，同步屏障说明之后的同步消息不被处理，异步消息就不会被影响，Handler的默认构造设置<code>mAsynchronous</code>为<code>false</code>，即都是同步消息</p><p><em>MessageQueue.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">postSyncBarrier</span><span class="params">(<span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> token = mNextBarrierToken++;</span><br><span class="line">    <span class="keyword">final</span> Message msg = Message.obtain();</span><br><span class="line">    msg.markInUse();</span><br><span class="line">    msg.when = when;</span><br><span class="line">    msg.arg1 = token;</span><br><span class="line"></span><br><span class="line">    Message prev = <span class="keyword">null</span>;</span><br><span class="line">    Message p = mMessages;</span><br><span class="line">    <span class="keyword">if</span> (when != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; p.when &lt;= when) &#123;</span><br><span class="line">        prev = p;</span><br><span class="line">        p = p.next;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123;</span><br><span class="line">      msg.next = p;</span><br><span class="line">      prev.next = msg;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      msg.next = p;</span><br><span class="line">      mMessages = msg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> token;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现没有设置消息的<code>target</code>字段，即为空，</p><p><em>MessageQueue.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(Message msg, <span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 检查Message，目标不能为空，也不能在使用中</span></span><br><span class="line">  <span class="keyword">if</span> (msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Message must have a target."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (msg.isInUse()) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(msg + <span class="string">" This message is already in use."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果正在退出 就回收掉Message并返回</span></span><br><span class="line">    <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">      IllegalStateException e = <span class="keyword">new</span> IllegalStateException(msg.target + <span class="string">" sending message to a Handler on a dead thread"</span>);</span><br><span class="line">      msg.recycle();</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 标记Message为使用中 设置触发时间字段when</span></span><br><span class="line">    msg.markInUse();</span><br><span class="line">    msg.when = when;</span><br><span class="line">    Message p = mMessages;</span><br><span class="line">    <span class="keyword">boolean</span> needWake;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="keyword">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</span><br><span class="line">      <span class="comment">// 新的队列头，立即执行，最先执行</span></span><br><span class="line">      <span class="comment">// 如果队列被阻塞则唤醒</span></span><br><span class="line">      msg.next = p;</span><br><span class="line">      mMessages = msg;</span><br><span class="line">      needWake = mBlocked;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 把Message插入到队列里合适的地方</span></span><br><span class="line">      needWake = mBlocked &amp;&amp; p.target == <span class="keyword">null</span> &amp;&amp; msg.isAsynchronous();</span><br><span class="line">      Message prev;</span><br><span class="line">      <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        prev = p;</span><br><span class="line">        p = p.next;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> || when &lt; p.when) &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">          needWake = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      msg.next = p;</span><br><span class="line">      prev.next = msg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如有必要则唤醒</span></span><br><span class="line">    <span class="keyword">if</span> (needWake) &#123;</span><br><span class="line">      nativeWake(mPtr);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="处理消息"><a href="#处理消息" class="headerlink" title="处理消息"></a>处理消息</h4><p>Looper在<code>prepare()</code>之后，需要调用<code>loop()</code>来开始消息循环</p><p><em>Looper.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Looper me = myLooper();</span><br><span class="line">  <span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"No Looper; Looper.prepare() wasn't called on this thread."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">final</span> MessageQueue queue = me.mQueue;</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    Message msg = queue.next(); <span class="comment">// might block</span></span><br><span class="line">    <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    msg.target.dispatchMessage(msg);</span><br><span class="line">    msg.recycleUnchecked();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开始一个无限循环，调用<code>next()</code>获得消息队列的下一条消息，这里可能阻塞，如果取得的消息为空则退出循环，否则获得<code>target</code>字段，调用其<code>dispatchMessage()</code>方法</p><p><em>Handler.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">    handleCallback(msg);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    handleMessage(msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按如下顺序调用回调处理消息：</p><p>1.消息中设置的回调</p><p>2.全局回调的<code>handleMessage()</code></p><p>3.<code>Handler.handleMessage()</code>，由子类实现</p><p><em>MessageQueue.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Message <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// mPtr是Native层中用到的，通过nativeInit()获得，应是队列头</span></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">long</span> ptr = mPtr;</span><br><span class="line">  <span class="keyword">if</span> (ptr == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> pendingIdleHandlerCount = -<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 然后开始一个无限循环，通过nativePollOnce()取一个消息</span></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nextPollTimeoutMillis != <span class="number">0</span>) &#123;</span><br><span class="line">      Binder.flushPendingCommands();</span><br><span class="line">    &#125;</span><br><span class="line">    nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">      Message prevMsg = <span class="keyword">null</span>;</span><br><span class="line">      Message msg = mMessages;</span><br><span class="line">      <span class="comment">// 如果消息的target为空 则寻找下一个异步消息</span></span><br><span class="line">      <span class="comment">// 说明这是一个同步屏障 不会继续处理同步消息</span></span><br><span class="line">      <span class="keyword">if</span> (msg != <span class="keyword">null</span> &amp;&amp; msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">          prevMsg = msg;</span><br><span class="line">          msg = msg.next;</span><br><span class="line">        &#125; <span class="keyword">while</span> (msg != <span class="keyword">null</span> &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (msg != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (now &lt; msg.when) &#123;</span><br><span class="line">          <span class="comment">// 消息的触发时间还没到 设置一个超时当它就绪时唤醒</span></span><br><span class="line">          nextPollTimeoutMillis = (<span class="keyword">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 消息就绪 标记为没有阻塞</span></span><br><span class="line">          <span class="comment">// 从队列中取出这个消息并返回</span></span><br><span class="line">          mBlocked = <span class="keyword">false</span>;</span><br><span class="line">          <span class="keyword">if</span> (prevMsg != <span class="keyword">null</span>) &#123;</span><br><span class="line">            prevMsg.next = msg.next;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mMessages = msg.next;</span><br><span class="line">          &#125;</span><br><span class="line">          msg.next = <span class="keyword">null</span>;</span><br><span class="line">          msg.markInUse();</span><br><span class="line">          <span class="keyword">return</span> msg;        </span><br><span class="line">        &#125; </span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        nextPollTimeoutMillis = -<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">        dispose();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 消息队列为空或者第一条消息还没就绪 就会执行空闲Handler</span></span><br><span class="line">      <span class="keyword">if</span> (pendingIdleHandlerCount &lt; <span class="number">0</span> &amp;&amp; (mMessages == <span class="keyword">null</span> || now &lt; mMessages.when)) &#123;</span><br><span class="line">        pendingIdleHandlerCount = mIdleHandlers.size();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (pendingIdleHandlerCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 没有空闲Handler 继续循环 并设置为阻塞</span></span><br><span class="line">        mBlocked = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (mPendingIdleHandlers == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mPendingIdleHandlers = <span class="keyword">new</span> IdleHandler[Math.max(pendingIdleHandlerCount, <span class="number">4</span>)];</span><br><span class="line">      &#125;</span><br><span class="line">      mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 运行空闲Handler 只在第一次循环的时候执行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;</span><br><span class="line">      <span class="keyword">final</span> IdleHandler idler = mPendingIdleHandlers[i];</span><br><span class="line">      mPendingIdleHandlers[i] = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">boolean</span> keep = <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        keep = idler.queueIdle();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        Log.wtf(TAG, <span class="string">"IdleHandler threw exception"</span>, t);</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (!keep) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">          mIdleHandlers.remove(idler);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pendingIdleHandlerCount = <span class="number">0</span>;</span><br><span class="line">    nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Native层实现"><a href="#Native层实现" class="headerlink" title="Native层实现"></a><em>Native层实现</em></h3><p>MessageQueue通过<code>mPtr</code>变量保存NativeMessageQueue对象，从而使得MessageQueue成为Java层和Native层的枢纽，既能处理上层消息，也能处理Native层消息</p><p>Handler/Looper/Message这三大类Java层与Native层并没有任何的真正关联，只是分别在Java层和Native层的Handler消息模型中具有相似的功能。都是彼此独立的，各自实现相应的逻辑</p><p><a href="http://www.programering.com/a/MjM2QDMwATc.html" target="_blank" rel="noopener">Native层分析参见这篇博客</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Handler&quot;&gt;&lt;a href=&quot;#Handler&quot; class=&quot;headerlink&quot; title=&quot;Handler&quot;&gt;&lt;/a&gt;Handler&lt;/h2&gt;&lt;p&gt;Handler是Android中常用的线程间通信机制&lt;/p&gt;
&lt;p&gt;Android是不允许在UI线程进行耗时的网络操作，所以一般会在工作线程中执行网络请求，得到返回数据后通知UI线程更新界面，这就可以通过Handler实现&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xt3ho.com1.z0.glb.clouddn.com/e03907fead023dc753bf8777548d3bac_b.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://lakeshire.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://lakeshire.github.io/tags/Android/"/>
    
      <category term="Handler" scheme="http://lakeshire.github.io/tags/Handler/"/>
    
  </entry>
  
  <entry>
    <title>Binder机制</title>
    <link href="http://lakeshire.github.io/2017/11/27//archivers/binder/"/>
    <id>http://lakeshire.github.io/2017/11/27//archivers/binder/</id>
    <published>2017-11-27T09:00:00.000Z</published>
    <updated>2017-11-28T02:21:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>Binder是Android的一种安全且高效的进程间通信机制，安全是因为其发起通信时会写入PID/UID信息，高效是因为传输过程只需要一次内存拷贝</p><a id="more"></a><h2 id="Binder机制"><a href="#Binder机制" class="headerlink" title="Binder机制"></a>Binder机制</h2><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Binder通信模型包含四个角色Client，Service，ServiceManager和Binder驱动，通信过程为：</p><ol><li>Server进程需要先向ServiceManager进程注册服务，该过程本身是跨进程的，首先获得ServiceManager服务，然后调用注册方法</li><li>Client进程使用服务时需要向ServiceManager获得对应Service</li><li>调用服务中提供的方法</li></ol><p>整个过程类似于从电话本上查到对应名字的电话并拨打过去……</p><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p>进程是CPU上运行的单个任务，Linux系统是多进程的，使用虚拟内存实现了进程的隔离，进程都认为独占了整个系统，进程之间数据不共享，需要借助某种机制进行进程间通信</p><p>Linux将内存划分为内核空间和用户空间，内核空间不允许应用程序随便访问，应用程序可以通过系统调用进入内核态访问内核空间</p><p>一个进程的用户空间如果想要访问别的进程的用户空间，需要借助进程间通信机制，如Linux的Socket，管道，共享内存等，Android则使用了Binder机制，通过Binder驱动实现</p><h3 id="Binder跨进程通信原理"><a href="#Binder跨进程通信原理" class="headerlink" title="Binder跨进程通信原理"></a>Binder跨进程通信原理</h3><p>Android系统使用代理模式完成Binder通信，Client进程持有Server端的代理，代理对象协助驱动完成了跨进程通信</p><h4 id="Java层数据结构"><a href="#Java层数据结构" class="headerlink" title="Java层数据结构"></a>Java层数据结构</h4><ul><li>IBinder 代表跨进程传输能力的接口，驱动会识别IBinder类型的数据，完成本地对象和代理对象的转换</li><li>IInterface 代表远程服务能力的接口</li><li>Binder 代表Binder本地对象，BinderProxy是Binder的内部类，是Binder的本地代理，它们都实现了IBinder，Binder驱动会完成这两种对象的转换</li><li>Stub 使用AIDL的时候会自动生成Stub类，它继承了Binder，实现了IInterface，是一个抽象类，需要被具体实现</li></ul><p>AIDL生成的代码可以看到这几个结构，Android的很多服务基本都是这个样子，比如<code>ActivityManagerService</code></p><p><code>IActivityManager</code>是具有Activity管理能力的远程接口，<code>ActivityManagerNative</code>实现了该接口，它是一个Binder本地对象，它的内部类<code>ActivityManagerProxy</code>是Binder代理对象，<code>ActivityManagerService</code>继承了<code>ActivityManagerNative</code>，是服务的具体实现类</p><h4 id="以ActivityManagerService为例的原理分析"><a href="#以ActivityManagerService为例的原理分析" class="headerlink" title="以ActivityManagerService为例的原理分析"></a>以ActivityManagerService为例的原理分析</h4><p>以<code>startActivity()</code>为例</p><p><em>Instrumentation.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ActivityManagerNative.getDefault().startActivity()</span><br></pre></td></tr></table></figure><p>首先获得ActivityManager服务，然后调用<code>startActivity()</code></p><p><em>ActivityManagerNative.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IBinder b = ServiceManager.getService(<span class="string">"activity"</span>);</span><br><span class="line">IActivityManager am = asInterface(b);</span><br><span class="line"><span class="keyword">return</span> am;</span><br></pre></td></tr></table></figure><p>通过<code>ServiceManager</code>获得名为<code>activity</code>的服务，它是一个<code>IBinder</code></p><p>通过<code>asInterface()</code>方法转化成<code>IActivityManager</code>接口，这个对象具有Activity管理能力，显然在应用进程里它应该是一个Binder代理对象</p><p><em>ActivityManagerNative.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">public</span> IActivityManager <span class="title">asInterface</span><span class="params">(IBinder obj)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (obj == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  IActivityManager in = (IActivityManager) obj.queryLocalInterface(descriptor);</span><br><span class="line">  <span class="keyword">if</span> (in != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> in;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ActivityManagerProxy(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>queryLocalInterface()</code>获取本地接口，如果获取不到则用此Binder创建一个代理对象</p><p><em>Binder.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> IInterface <span class="title">queryLocalInterface</span><span class="params">(String descriptor)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (mDescriptor.equals(descriptor)) &#123;</span><br><span class="line">    <span class="keyword">return</span> mOwner;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BinderProxy</span> <span class="keyword">implements</span> <span class="title">IBinder</span> </span>&#123;</span><br><span class="line">  ......</span><br><span class="line">  <span class="function"><span class="keyword">public</span> IInterface <span class="title">queryLocalInterface</span><span class="params">(String descriptor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法在<code>Binder</code>和<code>BinderProxy</code>中都有实现，<code>Binder</code>中返回了本地对象，而<code>BinderProxy</code>中返回了<code>null</code>，所以在服务端和客户端拿到的IBinder不同</p><p>获得<code>IActivityManager</code>之后就可以调用<code>startActivity()</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">startActivity</span><span class="params">(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, <span class="keyword">int</span> requestCode, <span class="keyword">int</span> startFlags, ProfilerInfo profilerInfo, Bundle options)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">  Parcel data = Parcel.obtain();</span><br><span class="line">  Parcel reply = Parcel.obtain();</span><br><span class="line">  data.writeInterfaceToken(IActivityManager.descriptor);</span><br><span class="line">  data.writeStrongBinder(caller != <span class="keyword">null</span> ? caller.asBinder() : <span class="keyword">null</span>);</span><br><span class="line">  data.writeString(callingPackage);</span><br><span class="line">  intent.writeToParcel(data, <span class="number">0</span>);</span><br><span class="line">  data.writeString(resolvedType);</span><br><span class="line">  data.writeStrongBinder(resultTo);</span><br><span class="line">  data.writeString(resultWho);</span><br><span class="line">  data.writeInt(requestCode);</span><br><span class="line">  data.writeInt(startFlags);</span><br><span class="line">  <span class="keyword">if</span> (profilerInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">    data.writeInt(<span class="number">1</span>);</span><br><span class="line">    profilerInfo.writeToParcel(data, Parcelable.PARCELABLE_WRITE_RETURN_VALUE);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    data.writeInt(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (options != <span class="keyword">null</span>) &#123;</span><br><span class="line">    data.writeInt(<span class="number">1</span>);</span><br><span class="line">    options.writeToParcel(data, <span class="number">0</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    data.writeInt(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  mRemote.transact(START_ACTIVITY_TRANSACTION, data, reply, <span class="number">0</span>);</span><br><span class="line">  reply.readException();</span><br><span class="line">  <span class="keyword">int</span> result = reply.readInt();</span><br><span class="line">  reply.recycle();</span><br><span class="line">  data.recycle();</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按顺序填入参数，然后调用<code>mRemote</code>的<code>transact()</code>方法，这个<code>mRemote</code>就是一个<code>IBinder</code>，最后等待返回值</p><p>服务端在<code>onTransact()</code>里面收到客户端发来的命令</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">int</span> code, Parcel data, Parcel reply, <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (code) &#123;</span><br><span class="line">    <span class="keyword">case</span> START_ACTIVITY_TRANSACTION: &#123;</span><br><span class="line">      data.enforceInterface(IActivityManager.descriptor);</span><br><span class="line">      IBinder b = data.readStrongBinder();</span><br><span class="line">      IApplicationThread app = ApplicationThreadNative.asInterface(b);</span><br><span class="line">      String callingPackage = data.readString();</span><br><span class="line">      Intent intent = Intent.CREATOR.createFromParcel(data);</span><br><span class="line">      String resolvedType = data.readString();</span><br><span class="line">      IBinder resultTo = data.readStrongBinder();</span><br><span class="line">      String resultWho = data.readString();</span><br><span class="line">      <span class="keyword">int</span> requestCode = data.readInt();</span><br><span class="line">      <span class="keyword">int</span> startFlags = data.readInt();</span><br><span class="line">      ProfilerInfo profilerInfo = data.readInt() != <span class="number">0</span> ? ProfilerInfo.CREATOR.createFromParcel(data) : <span class="keyword">null</span>;</span><br><span class="line">      Bundle options = data.readInt() != <span class="number">0</span> ? Bundle.CREATOR.createFromParcel(data) : <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">int</span> result = startActivity(app, callingPackage, intent, resolvedType, resultTo, resultWho, requestCode, startFlags, profilerInfo, options);</span><br><span class="line">      reply.writeNoException();</span><br><span class="line">      reply.writeInt(result);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      ......</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">super</span>.onTransact(code, data, reply, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据命令号走对应的条件分支，取出参数，调用服务端中实际的<code>startActivity()</code>方法，最后写回返回值</p><h4 id="ServiceManager"><a href="#ServiceManager" class="headerlink" title="ServiceManager"></a>ServiceManager</h4><p><code>ServiceManager</code>是整个Binder机制的守护进程，来管理各种Server，并像Client提供查询Server远程接口的功能</p><p><code>ServiceManager</code>做了三件事：</p><p>1.打开Binder设备文件并建立内存映射</p><p>2.告诉Binder驱动自己是上下文管理者即守护进程</p><p>3.进入无限循环，等待Client的请求</p><p>ServiceManager也是一个Server，然而它又与一般的Server不一样。对于普通的Server来说，Client如果想要获得Server的远程接口，那么必须通过ServiceManager远程接口提供的<code>getService</code>接口来获得，这本身就是一个使用Binder机制来进行进程间通信的过程。而对于ServiceManager这个Server来说，Client如果想要获得ServiceManager远程接口，却不必通过进程间通信机制来获得，因为ServiceManager远程接口是一个特殊的Binder引用，它的引用句柄一定是0</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Binder是Android的一种安全且高效的进程间通信机制，安全是因为其发起通信时会写入PID/UID信息，高效是因为传输过程只需要一次内存拷贝&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://lakeshire.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://lakeshire.github.io/tags/Android/"/>
    
      <category term="Binder" scheme="http://lakeshire.github.io/tags/Binder/"/>
    
      <category term="跨进程通信" scheme="http://lakeshire.github.io/tags/%E8%B7%A8%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>Gradle插件</title>
    <link href="http://lakeshire.github.io/2017/08/15//archivers/gradle-plugin/"/>
    <id>http://lakeshire.github.io/2017/08/15//archivers/gradle-plugin/</id>
    <published>2017-08-15T09:00:00.000Z</published>
    <updated>2017-11-28T03:10:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>Gradle插件是一组任务，几乎所有的任务，如编译任务，设置域对象，设置源文件等都由插件处理</p><a id="more"></a><h2 id="编写Gradle插件"><a href="#编写Gradle插件" class="headerlink" title="编写Gradle插件"></a>编写Gradle插件</h2><ol><li><p>创建一个模块（假设模块名叫<code>library</code>），清空除build.gradle以外的文件，清空build.gradle的内容</p></li><li><p>新建src文件夹，在src下新建main文件夹，在main下新建groovy和resources文件夹</p></li><li><p>groovy下新建包名文件夹，在里面创建类，创建一个<code>PluginImpl.groovy</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package com.github.lakeshire</span><br><span class="line">import org.gradle.api.Plugin</span><br><span class="line">import org.gradle.api.Project</span><br><span class="line"></span><br><span class="line">public class PluginImpl implements Plugin&lt;Project&gt; &#123;</span><br><span class="line">  void apply(Project project) &#123;</span><br><span class="line">    project.task(&apos;TestTask&apos;) &#123;</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>resources下创建META-INF文件夹，META-INF下创建gradle-plugins文件夹，gradle-plugins下新建属性文件，文件命名就是插件的名字，如<code>plugin.test.properties</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation-class=com.github.lakeshire.PluginImpl</span><br></pre></td></tr></table></figure><p>这样就创建了一个叫<code>plugin.test</code>的插件，插件里有一个<code>TestTask</code>任务</p></li><li><p>发布到本地仓库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">  mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line">group=&apos;com.github.lakeshire&apos;</span><br><span class="line">version=&apos;1.0.0&apos;</span><br><span class="line"></span><br><span class="line">uploadArchives &#123;</span><br><span class="line">  repositories &#123;</span><br><span class="line">    mavenDeployer &#123;</span><br><span class="line">      repository(url : uri(&apos;../repo&apos;))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Sync之后会出现一个<code>uploadArchives</code>任务，运行就在<code>repo</code>目录下出现我们的插件</p></li><li><p>使用插件，在使用到的<code>gradle.build</code>中加入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">  repositories &#123;</span><br><span class="line">    maven &#123;</span><br><span class="line">      url uri(&apos;../repo&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  dependencies &#123;</span><br><span class="line">    classpath &apos;com.github.lakeshire:library:1.0.0&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 就是模块名</span><br><span class="line">apply plugin: &apos;library&apos;</span><br></pre></td></tr></table></figure><p>​</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Gradle插件是一组任务，几乎所有的任务，如编译任务，设置域对象，设置源文件等都由插件处理&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://lakeshire.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://lakeshire.github.io/tags/Android/"/>
    
      <category term="Gradle" scheme="http://lakeshire.github.io/tags/Gradle/"/>
    
  </entry>
  
  <entry>
    <title>Activity相关</title>
    <link href="http://lakeshire.github.io/2017/04/11//archivers/activity-launch-mode/"/>
    <id>http://lakeshire.github.io/2017/04/11//archivers/activity-launch-mode/</id>
    <published>2017-04-11T09:00:00.000Z</published>
    <updated>2017-11-28T03:11:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍一些与Activity相关的小知识</p><a id="more"></a><h2 id="启动模式"><a href="#启动模式" class="headerlink" title="启动模式"></a>启动模式</h2><p><code>Activity</code>可以设置<code>android:launchMode</code>指定启动模式</p><ul><li><p><code>standard</code><br>标准</p></li><li><p><code>singleTop</code><br>唯一栈顶，启动的Activity如果在栈顶，将不再新建，而是调用原Activity的<code>onNewIntent()</code><br>比如点击搜索按钮进入搜索结果页面，一般而言还是会有搜索框可以再次搜索，如果反复生成新搜索页面，回退的时候非常麻烦而且很怪异，这个时候适合用这个</p></li><li><p><code>singleTask</code><br>如果栈内已经有一个标记为<code>singleTask</code>的Activity A，再次启动一个这样的Activity时将不会新建，而是会残忍的销毁A之上的所有Activity，使A显示在栈顶，并调用它的<code>onNewIntent()</code><br>文档里提到然而并不是这样，如果想达到这样的效果即新开一个Task，这个Activity作为根，你需要配置清单的<code>android:taskAffinity</code>属性为空</p></li></ul><blockquote><p>The system creates a new task and instantiates the activity at the root of the new task</p></blockquote><ul><li><code>singleInstance</code><br>栈内只有这么一个Activity，再次启动一个这样的Acitivity会启动一个新的Task</li></ul><h2 id="标志位"><a href="#标志位" class="headerlink" title="标志位"></a>标志位</h2><p>比较常用的有下面这些</p><ul><li><p><code>FLAG_ACTIVITY_SINGLE_TOP</code><br>唯一栈顶，启动的Activity如果在栈顶，将不再新建，而是调用原Activity的<code>onNewIntent()</code></p></li><li><p><code>FLAG_ACTIVITY_NEW_TASK</code><br>启动一个新的Task，通常用于表现启动器行为，提供用户一组可以做的事，然后运行在完全独立的Task里</p></li><li><p><code>FLAG_ACTIVITY_MULTIPLE_TASK</code><br>用来启动一个新的Task，通常与<code>FLAG_ACTIVITY_NEW_TASK</code>或<code>FLAG_ACTIVITY_NEW_DOCUMENT</code>一起使用（不一起使用该标记会被忽略），因为单独使用这些标记时，如果能在现存的Task里找到匹配的，就不会再新建，加上这个标记则会跳过搜索匹配Task的过程，无条件的创建一个新的Task</p></li><li><p><code>FLAG_ACTIVITY_CLEAR_TOP</code><br>可以和<code>FLAG_ACTIVITY_NEW_TASK</code>很好的搭配，用来启动一个Task的根Activity，将把那个Task当前正在运行的任何实例都调到前台，然后清除到根，在从通知里启动Activity这种场景尤其有用</p></li><li><p><code>FLAG_ACTIVITY_REORDER_TO_FRONT</code><br>如果已经运行，就调到栈顶，如果<code>FLAG_ACTIVITY_CLEAR_TOP</code>也被设置了会被忽略</p></li><li><p><code>FLAG_ACTIVITY_CLEAR_TASK</code><br>清空Task，Activity成为根</p></li></ul><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>Activity有三种重要状态：</p><ul><li><code>resumed</code><br>Activity在前台，拥有用户焦点</li><li><code>paused</code><br>别的Activity在前台并且拥有焦点，但是这个Activity仍然可见，内存中保存有Activity对象，维持着所有状态，保持附着于WindowManager，在极度低内存时可能被销毁</li><li><code>stopped</code><br>完全被其他Activity覆盖，处于后台不可见，内存中保存有Activity对象，维持着所有状态，但是未附着于WindowManager，当其他地方需要内存时可能被销毁</li></ul><p>当Activity是<code>paused</code>或<code>stopped</code>时，系统可能调用<code>finish()</code>或直接杀死进程来回收内存，当Activity再次被打开时，必须被重新创建</p><p>生命周期</p><ul><li>全部阶段<br>从<code>onCreate()</code>到<code>onDestroy()</code>，在前者初始化，在后者释放所有资源，比如停止后台下载线程</li><li>可见阶段<br>从<code>onStart()</code>到<code>onStop()</code>，可以在前者注册<code>BroadcastReceiver</code>监视UI变化，在后者注销</li><li>前台阶段<br>从<code>onResume()</code>到<code>onPause()</code>，获得焦点用户可交互，可能频繁切换，所以其中的代码需要轻量，<code>onPause()</code>是Activity可能被销毁之前调用的最后方法，所以要在这里做关键数据保存</li></ul><p>假设A启动B，执行顺序是A.onPause() -&gt; B.onCreate() -&gt; B.onStart() -&gt; B.onResume() -&gt; A.onStop()，所以如果A需要写入数据供B读取，应该发生在<code>onPause()</code>中</p><h2 id="配置变化"><a href="#配置变化" class="headerlink" title="配置变化"></a>配置变化</h2><p>如果配置变化，UI都需要更新，Activity有特殊的支持处理配置变化<br>除非特别指定，配置变化将会导致当前Activity被销毁，如果Activity当前可见，之后会重新实例化，使用<code>savedInstanceState</code>，这是之前实例通过<code>onSaveInstanceState()</code>保存的</p><p>某些特殊情况，你可能想跳过重建，通过清单里的<code>android:configChanges</code>配置，对于你要处理的任意配置变化类型，将会调用<code>onConfigurationChanged()</code>而不是重启，如果一个配置变化你不处理，仍然会重建而且这个函数不会被调用</p><p>要做以下几点：</p><ol><li>添加权限<code>&lt;uses-permission android:name=&quot;android.permission.CHANGE_CONFIGURATION&quot; /&gt;</code></li><li>指定<code>android:configChanges</code>属性，用<code>|</code>连接多个变化项</li><li>重写<code>onConfigurationChanged()</code></li></ol><blockquote><p>从API13后转屏时<code>screenSize</code>也会改变，这时仅写<code>orientation</code>是不会生效的，而要写<code>orientation|srceenSize</code>，小于API13则不需要，此为一坑</p></blockquote><h2 id="保存状态"><a href="#保存状态" class="headerlink" title="保存状态"></a>保存状态</h2><p>Activity可能被销毁，重建时需要之前的信息，可以通过<code>onSaveInstanceState()</code>保存信息，在<code>onCreate()</code>或<code>onRestoreInstanceState()</code>中获得信息恢复</p><p><code>onSaveInstanceState()</code>是不保证被调用的，因为当用户主动关闭Activity时没有必要保存状态，如果系统调用这个方法，会在<code>onStop()</code>之前调用，可能在<code>onPause()</code>之前</p><p>然而即使你没有实现<code>onSaveInstanceState()</code>，一些Activity状态仍然被默认实现保存了，默认会调用所有视图的<code>onSaveInstanceState()</code>，保存所有视图的状态，几乎所有视图都实现了这个方法，所以能保存和恢复状态，不过你需要提供一个<code>android:id</code>，否则不会保存状态</p><p>重写这些方法的时候不要忘了调用父类方法</p><p><code>onSaveInstanceState()</code>不保证被调用，所以应该只用来保存UI状态，不要用它保存数据，这应该在<code>onPause()</code>中做</p><h2 id="进程生命周期"><a href="#进程生命周期" class="headerlink" title="进程生命周期"></a>进程生命周期</h2><p>同一个应用的所有组件都在同一个进程下，可以通过组件的<code>android:process</code>属性指定不同的进程，也可以指定<code>application</code>的这个属性为所有组件指定默认的进程</p><p>Android系统尽可能保持应用进程的运行，当内存很低时也会移除旧的进程，有五种进程状态，按重要程度排列：</p><ul><li><code>前台进程</code>   </li></ul><ol><li>进程中包含处于前台的正与用户交互的Activity</li><li>进程中包含与前台Activity绑定的Service</li><li>进程中包含调用了<code>startForeground()</code>方法的Service</li><li>进程中包含正在执行<code>onCreate()</code>, <code>onStart()</code>, 或<code>onDestroy()</code>方法的Service</li><li>进程中包含正在执行<code>onReceive()</code>方法的<code>BroadcastReceiver</code><br>系统中前台进程的数量很少, 前台进程几乎不会被杀死，只有当内存低到无法保证所有的前台进程同时运行时才会选择杀死某个前台进程（系统也差不多挂了）</li></ol><ul><li><code>可见进程</code>  </li></ul><ol><li>进程中包含未处于前台但仍然可见的Activity（调用了<code>onPause()</code>方法, 但没有调用<code>onStop()</code>方法），典型的情况是运行Activity时弹出对话框, 此时的Activity虽然不是前台Activity, 但其仍然可见</li><li>进程中包含与可见Activity绑定的Service</li></ol><ul><li><p><code>服务进程</code><br>包含已启动的Service</p></li><li><p><code>后台进程</code><br>不可见，暂停</p></li><li><p><code>空进程</code><br>不持有Activity和其他组件，当系统内存低时会被很快杀掉，空进程存在的唯一理由是为了缓存一些启动数据，以便下次可以更快的启动</p></li></ul><blockquote><p>由于服务进程的优先级高于后台进程，因此如果Activity需要执行耗时操作，最好还是启动一个Service来完成，当然在Activity中启动子线程完成耗时操作也可以，但是这样做的缺点在于，一旦Activity不再可见，Activity所在的进程成为后台进程，而内存不足时后台进程随时都有可能被系统杀死。基于同样的考虑，在BroadcastReceiver中也不应该执行耗时操作，而应该启动Service来完成(当然, BroadcastReceiver的生命周期过于短暂，也决定了不能在其中执行耗时操作)</p></blockquote><h2 id="有用的方法"><a href="#有用的方法" class="headerlink" title="有用的方法"></a>有用的方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFinishing</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>检查Activity是不是结束了，可能是你手动调用了<code>finish()</code>，也可能是其他地方请求结束<br>经常在<code>onPause()</code>中检查Acitivity只是暂停还是彻底结束</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">moveTaskToBack</span> <span class="params">(<span class="keyword">boolean</span> nonRoot)</span></span></span><br></pre></td></tr></table></figure><p>把包含此Activity的Task移动到Activity栈的后面，Task内的Activity顺序不变，<code>nonRoot</code>是<code>true</code>对所有Activity有效，<code>false</code>只对根Activity有效</p><p>测试：比如A1-&gt;A2-&gt;A3，A3调用<code>moveTaskToBack()</code>，参数为<code>true</code>时”退出”应用，实际栈维持不变，再回到应用还是一样的，参数为<code>false</code>时在这个页面无效，只在A有效</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">navigateUpTo</span> <span class="params">(Intent upIntent)</span></span></span><br></pre></td></tr></table></figure><p>类似目标Activity有<code>singleTask</code>的效果，在复杂导航的APP里可能有用<br>应该用于同Task里的向上操作，如果跨Task，参见<code>shouldUpRecreateTask()</code></p><p>测试：比如A1-&gt;A2-&gt;A3-&gt;A4，A4调用<code>navigateUpTo()</code>到A1，A2/A3/A4都会出栈，A1再按后退键就会退出应用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldUpRecreateTask</span> <span class="params">(Intent targetIntent)</span></span></span><br></pre></td></tr></table></figure><p>当向上导航时是否要重建Task</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> PendingIntent <span class="title">createPendingResult</span> <span class="params">(<span class="keyword">int</span> requestCode, Intent data, <span class="keyword">int</span> flags)</span></span></span><br></pre></td></tr></table></figure><p>创建<code>PendingIntent</code>，你能够传给其他组件，它们可以用来发送数据回来到<code>onActivityResult()</code>，可以是一次性的也可以是多次使用的</p><p>这个方法可以用来Activity与Service交互，也可以应用于跨Activity传递数据，比如A、B、C三个Activity，A打开B，B打开C，然后B自动关掉，A接收C的结果，就可以使用这种方式传递PendingIntent实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PendingIntent pendingResult = createPendingResult(<span class="number">100</span>, <span class="keyword">new</span> Intent(), <span class="number">0</span>);  </span><br><span class="line">Intent i = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, MyService.class);  </span><br><span class="line">i.putExtra(PENDING__RESULT, pendingResult);  </span><br><span class="line">startService(i);</span><br></pre></td></tr></table></figure><p>先启动一个service，PendingIntent也传过去</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PendingIntent pendingIntent = intent.getParcelableExtra(MainActivity.PENDING__RESULT);  </span><br><span class="line"><span class="keyword">try</span> &#123;  </span><br><span class="line">    pendingIntent.send(MyService.<span class="keyword">this</span>, <span class="number">101</span>, <span class="keyword">new</span> Intent().putExtra(<span class="string">"data"</span>, <span class="string">"some data"</span>));  </span><br><span class="line">&#125; <span class="keyword">catch</span> (CanceledException e) &#123;  </span><br><span class="line">    e.printStackTrace();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用<code>PendingIntent</code>的<code>send()</code>方法，发送结果给调用的Activity，让其<code>onActivityResult()</code>响应</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">finishAffinity</span> <span class="params">()</span></span></span><br></pre></td></tr></table></figure><p>可以关闭当前Activity所属的Activity栈中所有的Activity，如果所有Activity都保存在默认栈中，则使用该方法会直接退出程序</p><p>如果要回到程序的主界面，则可以在清单文件中将主界面的Activity设置为单独的栈保存，设置<code>android:taskAffinity=&quot;:[name]</code>“</p><h2 id="清空任务栈"><a href="#清空任务栈" class="headerlink" title="清空任务栈"></a>清空任务栈</h2><p>用户离开Task很长时间，系统清理Task里的除了根Activity以外的所有Activity，当用户回来，只有根Activity会恢复<br>有一些Activity属性可以用来改变这种行为</p><ul><li><code>alwaysRetainTaskState</code><br>如果根Activity的这个属性是<code>true</code>，则总是保留Activity</li><li><code>clearTaskOnLaunch</code><br>如果根<code>Activity</code>的这个属性是<code>true</code>，则总是清空Activity</li><li><code>finishOnTaskLaunch</code><br>类似<code>clearTaskOnLaunch</code>，但是不是对整个Task，而是对单个Activity</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍一些与Activity相关的小知识&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://lakeshire.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://lakeshire.github.io/tags/Android/"/>
    
      <category term="Activity" scheme="http://lakeshire.github.io/tags/Activity/"/>
    
  </entry>
  
  <entry>
    <title>EventBus总结</title>
    <link href="http://lakeshire.github.io/2017/04/11//archivers/event-bus/"/>
    <id>http://lakeshire.github.io/2017/04/11//archivers/event-bus/</id>
    <published>2017-04-11T04:00:00.000Z</published>
    <updated>2017-11-28T01:45:13.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>EventBus</code>是为Android定制的发布/订阅总线</p><p>它可以简化组件之间的通信，解耦事件发送者和接受者，可以很好的与Activity、Fragment、后台线程协同工作，避免了复杂的依赖和生命周期相关的问题</p><a id="more"></a><blockquote><p>广播稍显麻烦，并且传递对象时需要序列化</p></blockquote><p><img src="http://7xt3ho.com1.z0.glb.clouddn.com/EventBus-Publish-Subscribe.png" alt=""></p><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><h3 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h3><h4 id="自定义事件类"><a href="#自定义事件类" class="headerlink" title="自定义事件类"></a>自定义事件类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageEvent</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="注册和注销订阅者"><a href="#注册和注销订阅者" class="headerlink" title="注册和注销订阅者"></a>注册和注销订阅者</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EventBus.getDefault().register(<span class="keyword">this</span>);</span><br><span class="line">EventBus.getDefault().unregister(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><h4 id="添加处理函数"><a href="#添加处理函数" class="headerlink" title="添加处理函数"></a>添加处理函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Subscribe</span>(threadMode = ThreadMode.MAIN)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessageEvent</span><span class="params">(MessageEvent event)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>EventBus3</code>中处理函数可以任意取名，通过<code>@Subscribe</code>注解标记  </p><p><code>threadMode</code>：线程模式：</p><ul><li><code>ThreadMode.POSTING</code> 发送事件和接收事件在同一个线程</li><li><code>ThreadMode.MAIN</code> 事件处理在UI线程进行</li><li><code>ThreadMode.BACKGROUND</code> 如果是UI线程发送，则新建子线程执行，如果本身是后台线程发送，就在该线程执行</li><li><code>ThreadMode.ASYNC</code> 无论从哪个线程发送，都在新线程执行</li></ul><p><code>sticky</code>：粘性事件，表示在订阅之前发布的事件订阅后也能收到</p><p><code>priority</code>：优先级，默认为0，越大优先级越高</p><h4 id="发送事件"><a href="#发送事件" class="headerlink" title="发送事件"></a>发送事件</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventBus.getDefault().post(<span class="keyword">new</span> MessageEvent());</span><br></pre></td></tr></table></figure><p>发送粘性事件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventBus.getDefault().postSticky(<span class="keyword">new</span> MessageEvent());</span><br></pre></td></tr></table></figure><h3 id="配置注解处理器获得索引"><a href="#配置注解处理器获得索引" class="headerlink" title="配置注解处理器获得索引"></a>配置注解处理器获得索引</h3><p>修改<code>build.gradle</code></p><pre><code>buildscript {    dependencies {        classpath &apos;com.neenbedankt.gradle.plugins:android-apt:1.8&apos;    }}apply plugin: &apos;com.neenbedankt.android-apt&apos;dependencies {    apt &apos;org.greenrobot:eventbus-annotation-processor:3.0.1&apos;}apt {    arguments {        // 这个就是生成的索引类的名字        eventBusIndex &apos;com.github.lakeshire.eventbusdemo.MyEventBusIndex&apos;    }}</code></pre><p>编译期生成的类是这样的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** This class is generated by EventBus, do not edit. */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyEventBusIndex</span> <span class="keyword">implements</span> <span class="title">SubscriberInfoIndex</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, SubscriberInfo&gt; SUBSCRIBER_INDEX;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        SUBSCRIBER_INDEX = <span class="keyword">new</span> HashMap&lt;Class&lt;?&gt;, SubscriberInfo&gt;();</span><br><span class="line"></span><br><span class="line">        putIndex(<span class="keyword">new</span> SimpleSubscriberInfo(MainActivity.class, <span class="keyword">true</span>, <span class="keyword">new</span> SubscriberMethodInfo[] &#123;</span><br><span class="line">            <span class="keyword">new</span> SubscriberMethodInfo(<span class="string">"onMessageEvent"</span>, MessageEvent.class, ThreadMode.MAIN, <span class="number">100</span>, <span class="keyword">false</span>),</span><br><span class="line">            <span class="keyword">new</span> SubscriberMethodInfo(<span class="string">"onMessageEventAlt"</span>, Misc.class, ThreadMode.MAIN, <span class="number">100</span>, <span class="keyword">false</span>),</span><br><span class="line">        &#125;));</span><br><span class="line"></span><br><span class="line">        putIndex(<span class="keyword">new</span> SimpleSubscriberInfo(ReceiveActivity.class, <span class="keyword">true</span>, <span class="keyword">new</span> SubscriberMethodInfo[] &#123;</span><br><span class="line">            <span class="keyword">new</span> SubscriberMethodInfo(<span class="string">"onMessageEvent"</span>, MessageEvent.class, ThreadMode.MAIN, <span class="number">0</span>, <span class="keyword">true</span>),</span><br><span class="line">        &#125;));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">putIndex</span><span class="params">(SubscriberInfo info)</span> </span>&#123;</span><br><span class="line">        SUBSCRIBER_INDEX.put(info.getSubscriberClass(), info);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SubscriberInfo <span class="title">getSubscriberInfo</span><span class="params">(Class&lt;?&gt; subscriberClass)</span> </span>&#123;</span><br><span class="line">        SubscriberInfo info = SUBSCRIBER_INDEX.get(subscriberClass);</span><br><span class="line">        <span class="keyword">if</span> (info != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> info;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后设置默认的EventBus</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventBus.builder().addIndex(<span class="keyword">new</span> MyEventBusIndex()).installDefaultEventBus();</span><br></pre></td></tr></table></figure><p>用下来，注册时间用反射时是8ms，用索引时是2ms，再次注册是1ms，区别很明显</p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><h3 id="EventBus"><a href="#EventBus" class="headerlink" title="EventBus"></a>EventBus</h3><p>提供一个默认的单例实现，也可以通过Builder自定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  事件类型缓存</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, List&lt;Class&lt;?&gt;&gt;&gt; eventTypesCache = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//  事件类型-订阅者表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, CopyOnWriteArrayList&lt;Subscription&gt;&gt; subscriptionsByEventType;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  订阅者-事件类型表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Object, List&lt;Class&lt;?&gt;&gt;&gt; typesBySubscriber;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  粘性事件列表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, Object&gt; stickyEvents;</span><br></pre></td></tr></table></figure><p>有几个重要的数据容器</p><h4 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Object subscriber)</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt; subscriberClass = subscriber.getClass();</span><br><span class="line">    List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (SubscriberMethod subscriberMethod : subscriberMethods) &#123;</span><br><span class="line">            subscribe(subscriber, subscriberMethod);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先通过一个订阅方法查找器找到对应这个订阅者的一组方法，查找器内部会保存一份方法缓存表，如果已存在直接返回，没有的话就要实际查找，有反射和索引两种查找方式，索引在编译期通过注解处理器获得，速度要比反射快</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(Object subscriber, SubscriberMethod subscriberMethod)</span> </span>&#123;</span><br></pre></td></tr></table></figure><ol><li>查看<code>subscriptionsByEventType</code>中对应<code>EventType</code>的列表，根据优先级把新的订阅者添加进去</li><li>查看<code>typesBySubscriber</code>中对应<code>Subscriber</code>的列表，添加新的<code>EventType</code></li><li>处理粘性事件，从粘性事件列表中获取对应<code>EventType</code>的事件，做一次发送<br>这里就是发送粘性事件的时机，所以注册前发送的粘性事件再注册后可以接收到，粘性事件列表维护的是事件类型-事件（不是列表）对，发送后不会主动移除掉，所以再次注册还是会发送</li></ol><h4 id="注销"><a href="#注销" class="headerlink" title="注销"></a>注销</h4><p>就是清理<code>subscriptionsByEventType</code>和<code>typesBySubscriber</code>这两个列表</p><h4 id="发送事件-1"><a href="#发送事件-1" class="headerlink" title="发送事件"></a>发送事件</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">post</span><span class="params">(Object event)</span> </span>&#123;</span><br><span class="line">    PostingThreadState postingState = currentPostingThreadState.get();</span><br><span class="line">    List&lt;Object&gt; eventQueue = postingState.eventQueue;</span><br><span class="line">    eventQueue.add(event);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!postingState.isPosting) &#123;</span><br><span class="line">        postingState.isMainThread = Looper.getMainLooper() == Looper.myLooper();</span><br><span class="line">        postingState.isPosting = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (postingState.canceled) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Internal error. Abort state was not reset"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!eventQueue.isEmpty()) &#123;</span><br><span class="line">                postSingleEvent(eventQueue.remove(<span class="number">0</span>), postingState);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            postingState.isPosting = <span class="keyword">false</span>;</span><br><span class="line">            postingState.isMainThread = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发送是向线程本地变量里维护的队列中添加一个事件，如果没有在发送则发送队列头的事件</p><p><code>postSingleEventForEventType()</code>里在<code>subscriptionsByEventType</code>中查找对应<code>EventType</code>的订阅者，有的话就对每个订阅者发送</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postToSubscription</span><span class="params">(Subscription subscription, Object event, <span class="keyword">boolean</span> isMainThread)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (subscription.subscriberMethod.threadMode) &#123;</span><br><span class="line">        <span class="keyword">case</span> POSTING:</span><br><span class="line">            invokeSubscriber(subscription, event);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MAIN:</span><br><span class="line">            <span class="keyword">if</span> (isMainThread) &#123;</span><br><span class="line">                invokeSubscriber(subscription, event);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mainThreadPoster.enqueue(subscription, event);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> BACKGROUND:</span><br><span class="line">            <span class="keyword">if</span> (isMainThread) &#123;</span><br><span class="line">                backgroundPoster.enqueue(subscription, event);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                invokeSubscriber(subscription, event);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ASYNC:</span><br><span class="line">            asyncPoster.enqueue(subscription, event);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unknown thread mode: "</span> + subscription.subscriberMethod.threadMode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个就是发送的核心部分，根据线程模式决定做法，跟线程模式的定义匹配：</p><ul><li><code>POSTING</code>直接调用订阅者的方法</li><li><code>MAIN</code>判断是否在主线程，在主线程直接调用，否则放进主线程的消息队列</li><li><code>BACKGROUND</code>判断是否在主线程，在主线程则放进后台线程的消息队列，否则直接调用</li><li><code>ASYNC</code>直接放进后台线程的队列</li></ul><p><code>EventBus</code>内有三个<code>Handler</code>：</p><ul><li><code>mainThreadPoster</code>持有UI线程的消息循环，发消息给UI线程并在上面处理</li><li><code>backgroundPoster</code>和<code>asyncPoster</code>都是在<code>EventBus</code>内的线程池上执行</li></ul><p><code>invokeSubscriber</code>就是调用订阅方法</p><h4 id="发送粘性事件"><a href="#发送粘性事件" class="headerlink" title="发送粘性事件"></a>发送粘性事件</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postSticky</span><span class="params">(Object event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (stickyEvents) &#123;</span><br><span class="line">        stickyEvents.put(event.getClass(), event);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Should be posted after it is putted, in case the subscriber wants to remove immediately</span></span><br><span class="line">    post(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很简单，把事件设置到粘性事件列表的对应项，然后正常发送</p><h4 id="事件继承"><a href="#事件继承" class="headerlink" title="事件继承"></a>事件继承</h4><p><code>postSingleEvent()</code>中出现的代码段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (eventInheritance) &#123;</span><br><span class="line">    List&lt;Class&lt;?&gt;&gt; eventTypes = lookupAllEventTypes(eventClass);</span><br><span class="line">    <span class="keyword">int</span> countTypes = eventTypes.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> h = <span class="number">0</span>; h &lt; countTypes; h++) &#123;</span><br><span class="line">        Class&lt;?&gt; clazz = eventTypes.get(h);</span><br><span class="line">        subscriptionFound |= postSingleEventForEventType(event, postingState, clazz);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    subscriptionFound = postSingleEventForEventType(event, postingState, eventClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果支持事件继承的话，需要查找对应事件类的所有<code>EventType</code>，包括接口类和基类，然后全部发送一遍（可能某些场景有用）</p><h4 id="注解处理器"><a href="#注解处理器" class="headerlink" title="注解处理器"></a>注解处理器</h4><p>参见生成的类，就是收集所有订阅者的处理函数并结构化形成索引</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;EventBus&lt;/code&gt;是为Android定制的发布/订阅总线&lt;/p&gt;
&lt;p&gt;它可以简化组件之间的通信，解耦事件发送者和接受者，可以很好的与Activity、Fragment、后台线程协同工作，避免了复杂的依赖和生命周期相关的问题&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://lakeshire.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://lakeshire.github.io/tags/Android/"/>
    
      <category term="开源库" scheme="http://lakeshire.github.io/tags/%E5%BC%80%E6%BA%90%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>JNI初学</title>
    <link href="http://lakeshire.github.io/2017/03/22//archivers/jni-init/"/>
    <id>http://lakeshire.github.io/2017/03/22//archivers/jni-init/</id>
    <published>2017-03-22T04:00:00.000Z</published>
    <updated>2017-11-28T03:12:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>JNI是<code>Java Native Interface</code>的缩写，它提供了若干的API实现了Java和其他语言的通信（主要是C/C++）</p><a id="more"></a><p>参考<a href="http://www.cnblogs.com/icejoywoo/archive/2012/02/24/2367116.html" target="_blank" rel="noopener">使用JNI进行Java与C/C++语言混合编程</a></p><h2 id="JNI"><a href="#JNI" class="headerlink" title="JNI"></a>JNI</h2><p>JNI（Java Native Interface，Java本地接口），用于打通Java层与Native(C/C++)层。这不是Android系统所独有的，而是Java所有。众所周知，Java语言是跨平台的语言，而这跨平台的背后都是依靠Java虚拟机，虚拟机采用C/C++编写，适配各个系统，通过JNI为上层Java提供各种服务，保证跨平台性。</p><h3 id="JNI注册"><a href="#JNI注册" class="headerlink" title="JNI注册"></a>JNI注册</h3><p>Android系统在启动过程中，先启动Kernel创建init进程，紧接着由init进程fork第一个横穿Java和C/C++的进程，即<code>Zygote</code>进程。Zygote启动过程中会AndroidRuntime.cpp中的<code>startVm</code>创建虚拟机，VM创建完成后，紧接着调用<code>startReg</code>完成虚拟机中的JNI方法注册。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> AndroidRuntime::startReg(JNIEnv* env) &#123;</span><br><span class="line">    androidSetCreateThreadFunc((android_create_thread_fn) javaCreateThreadEtc);</span><br><span class="line">    env-&gt;PushLocalFrame(<span class="number">200</span>);</span><br><span class="line">    <span class="keyword">if</span> (register_jni_procs(gRegJNI, NELEM(gRegJNI), env) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        env-&gt;PopLocalFrame(NULL);</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    env-&gt;PopLocalFrame(NULL);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">register_jni_procs</span><span class="params">(<span class="keyword">const</span> RegJNIRec array[], size_t count, JNIEnv* env)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array[i].mProc(env) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  该数组的每个成员都代表一个类文件的JNI映射，其中REG_JNI是一个宏定义，该宏的作用就是调用相应的方法</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> RegJNIRec gRegJNI[] = &#123;</span><br><span class="line">    REG_JNI(register_android_os_MessageQueue),</span><br><span class="line">    REG_JNI(register_android_os_Binder),</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="JNI查找"><a href="#JNI查找" class="headerlink" title="JNI查找"></a>JNI查找</h3><h4 id="系统方法"><a href="#系统方法" class="headerlink" title="系统方法"></a>系统方法</h4><p>以<code>MessageQueue</code>为例：</p><ul><li><code>android.os.MessageQueue.nativePollOnce</code>的本地方法是<code>android_os_MessageQueue_nativePollOnce</code></li><li><code>MessageQueue</code>对应的注册方法是<code>register_android_os_MessageQueue</code>，存在于<code>gRegJNI</code>数组中，在启动时就完成了注册</li><li>对应的本地文件是<code>android_os_MessageQueue.cpp</code></li></ul><h4 id="自定义方法"><a href="#自定义方法" class="headerlink" title="自定义方法"></a>自定义方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MediaPlayer</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.loadLibrary(<span class="string">"media_jni"</span>);</span><br><span class="line">        native_init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">native_init</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过static静态代码块中<code>System.loadLibrary</code>方法来加载动态库，库名为<code>media_jni</code>, Android平台则会自动扩展成所对应的<code>libmedia_jni.so</code>库</p><p>一般都是通过Android.mk文件定义<code>LOCAL_MODULE:= libmedia_jni</code></p><h3 id="JNI原理"><a href="#JNI原理" class="headerlink" title="JNI原理"></a>JNI原理</h3><p>System.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loadLibrary</span><span class="params">(String libName)</span> </span>&#123;</span><br><span class="line">    Runtime.getRuntime().loadLibrary(libName, VMStack.getCallingClassLoader());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Runtime.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loadLibrary</span><span class="params">(String libraryName, ClassLoader loader)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (loader != <span class="keyword">null</span>) &#123;</span><br><span class="line">        String filename = loader.findLibrary(libraryName);</span><br><span class="line">        <span class="keyword">if</span> (filename == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnsatisfiedLinkError(loader + <span class="string">" couldn't find \""</span> + System.mapLibraryName(libraryName) + <span class="string">"\""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        String error = doLoad(filename, loader);</span><br><span class="line">        <span class="keyword">if</span> (error != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnsatisfiedLinkError(error);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String filename = System.mapLibraryName(libraryName);</span><br><span class="line">    List&lt;String&gt; candidates = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    String lastError = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (String directory : mLibPaths) &#123;</span><br><span class="line">        String candidate = directory + filename;</span><br><span class="line">        candidates.add(candidate);</span><br><span class="line">        <span class="keyword">if</span> (IoUtils.canOpenReadOnly(candidate)) &#123;</span><br><span class="line">            String error = doLoad(candidate, loader);</span><br><span class="line">            <span class="keyword">if</span> (error == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            lastError = error;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (lastError != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsatisfiedLinkError(lastError);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsatisfiedLinkError(<span class="string">"Library "</span> + libraryName + <span class="string">" not found; tried "</span> + candidates);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">doLoad</span><span class="params">(String name, ClassLoader loader)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> nativeLoad(name, loader, ldLibraryPath);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用本地方法<code>nativeLoad</code>，其中会调用<code>dlopen</code>函数，打开一个so文件并创建一个handle；调用<code>dlsym</code>函数，查看相应so文件的<code>JNI_OnLoad()</code>函数指针，并执行相应函数。</p><p>android_media_MediaPlayer.cpp</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">jint <span class="title">JNI_OnLoad</span><span class="params">(JavaVM* vm, <span class="keyword">void</span>* reserved)</span> </span>&#123;</span><br><span class="line">    JNIEnv* env = NULL;</span><br><span class="line">    <span class="keyword">if</span> (register_android_media_MediaPlayer(env) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        goto bail;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">register_android_media_MediaPlayer</span><span class="params">(JNIEnv *env)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> AndroidRuntime::registerNativeMethods(env, <span class="string">"android/media/MediaPlayer"</span>, gMethods, NELEM(gMethods));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  gMethods，记录Java层和C/C++层方法的一一映射关系</span></span><br><span class="line"><span class="keyword">static</span> JNINativeMethod gMethods[] = &#123;</span><br><span class="line">    &#123;<span class="string">"prepare"</span>,      <span class="string">"()V"</span>,  (<span class="keyword">void</span> *)android_media_MediaPlayer_prepare&#125;,</span><br><span class="line">    &#123;<span class="string">"_start"</span>,       <span class="string">"()V"</span>,  (<span class="keyword">void</span> *)android_media_MediaPlayer_start&#125;,</span><br><span class="line">    &#123;<span class="string">"_stop"</span>,        <span class="string">"()V"</span>,  (<span class="keyword">void</span> *)android_media_MediaPlayer_stop&#125;,</span><br><span class="line">    &#123;<span class="string">"seekTo"</span>,       <span class="string">"(I)V"</span>, (<span class="keyword">void</span> *)android_media_MediaPlayer_seekTo&#125;,</span><br><span class="line">    &#123;<span class="string">"_release"</span>,     <span class="string">"()V"</span>,  (<span class="keyword">void</span> *)android_media_MediaPlayer_release&#125;,</span><br><span class="line">    &#123;<span class="string">"native_init"</span>,  <span class="string">"()V"</span>,  (<span class="keyword">void</span> *)android_media_MediaPlayer_native_init&#125;,</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>jni.h</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    <span class="comment">//  Java层native函数名</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* name; </span><br><span class="line">    <span class="comment">//  Java函数签名，记录参数类型和个数，以及返回值类型</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* signature;</span><br><span class="line">    <span class="comment">//  Native层对应的函数指针</span></span><br><span class="line">    <span class="keyword">void</span>* fnPtr; </span><br><span class="line">&#125; JNINativeMethod;</span><br></pre></td></tr></table></figure><p>AndroidRuntime.cpp</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> AndroidRuntime::registerNativeMethods(JNIEnv* env, <span class="keyword">const</span> <span class="keyword">char</span>* className, <span class="keyword">const</span> JNINativeMethod* gMethods, <span class="keyword">int</span> numMethods) &#123;</span><br><span class="line">    <span class="keyword">return</span> jniRegisterNativeMethods(env, className, gMethods, numMethods);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JNIHelper.cpp</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">extern <span class="string">"C"</span> <span class="function"><span class="keyword">int</span> <span class="title">jniRegisterNativeMethods</span><span class="params">(C_JNIEnv* env, <span class="keyword">const</span> <span class="keyword">char</span>* className, <span class="keyword">const</span> JNINativeMethod* gMethods, <span class="keyword">int</span> numMethods)</span> </span>&#123;</span><br><span class="line">    JNIEnv* e = reinterpret_cast&lt;JNIEnv*&gt;(env);</span><br><span class="line">    <span class="function">scoped_local_ref&lt;jclass&gt; <span class="title">c</span><span class="params">(env, findClass(env, className)</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span> (c.get() == NULL) &#123;</span><br><span class="line">        e-&gt;FatalError(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((*env)-&gt;RegisterNatives(e, c.get(), gMethods, numMethods) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        e-&gt;FatalError(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>jni.h</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct _JNIEnv &#123;</span><br><span class="line">    <span class="keyword">const</span> struct JNINativeInterface* functions;</span><br><span class="line"></span><br><span class="line">    <span class="function">jint <span class="title">RegisterNatives</span><span class="params">(jclass clazz, <span class="keyword">const</span> JNINativeMethod* methods, jint nMethods)</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> functions-&gt;RegisterNatives(<span class="keyword">this</span>, clazz, methods, nMethods); &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虚拟机相关的变量中有两个非常重要的量<code>JavaVM</code>和<code>JNIEnv</code><br><code>JavaVM</code>是指进程虚拟机环境，每个进程有且只有一个JavaVM实例<br><code>JNIEnv</code>是指线程上下文环境，每个线程有且只有一个JNIEnv实例</p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><h4 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h4><table><thead><tr><th style="text-align:center">Signature格式</th><th style="text-align:center">Java</th><th style="text-align:left">Native</th></tr></thead><tbody><tr><td style="text-align:center">B</td><td style="text-align:center">byte</td><td style="text-align:left">jbyte</td></tr><tr><td style="text-align:center">C</td><td style="text-align:center">char</td><td style="text-align:left">jchar</td></tr><tr><td style="text-align:center">D</td><td style="text-align:center">double</td><td style="text-align:left">jdouble</td></tr><tr><td style="text-align:center">F</td><td style="text-align:center">float</td><td style="text-align:left">jfloat</td></tr><tr><td style="text-align:center">I</td><td style="text-align:center">int</td><td style="text-align:left">jint</td></tr><tr><td style="text-align:center">S</td><td style="text-align:center">short</td><td style="text-align:left">jshort</td></tr><tr><td style="text-align:center">J</td><td style="text-align:center">long</td><td style="text-align:left">jlong</td></tr><tr><td style="text-align:center">Z</td><td style="text-align:center">boolean</td><td style="text-align:left">jboolean</td></tr><tr><td style="text-align:center">V</td><td style="text-align:center">void</td><td style="text-align:left">void</td></tr></tbody></table><h4 id="数组数据类型"><a href="#数组数据类型" class="headerlink" title="数组数据类型"></a>数组数据类型</h4><table><thead><tr><th style="text-align:center">Signature格式</th><th style="text-align:center">Java</th><th style="text-align:center">Native</th></tr></thead><tbody><tr><td style="text-align:center">[B</td><td style="text-align:center">byte[]</td><td style="text-align:center">jbyteArray</td></tr><tr><td style="text-align:center">[C</td><td style="text-align:center">char[]</td><td style="text-align:center">jcharArray</td></tr><tr><td style="text-align:center">[D</td><td style="text-align:center">double[]</td><td style="text-align:center">jdoubleArray</td></tr><tr><td style="text-align:center">[F</td><td style="text-align:center">float[]</td><td style="text-align:center">jfloatArray</td></tr><tr><td style="text-align:center">[I</td><td style="text-align:center">int[]</td><td style="text-align:center">jintArray</td></tr><tr><td style="text-align:center">[S</td><td style="text-align:center">short[]</td><td style="text-align:center">jshortArray</td></tr><tr><td style="text-align:center">[J</td><td style="text-align:center">long[]</td><td style="text-align:center">jlongArray</td></tr><tr><td style="text-align:center">[Z</td><td style="text-align:center">boolean[]</td><td style="text-align:center">jbooleanArray</td></tr></tbody></table><h4 id="复杂数据类型"><a href="#复杂数据类型" class="headerlink" title="复杂数据类型"></a>复杂数据类型</h4><table><thead><tr><th style="text-align:center">Signature格式</th><th style="text-align:center">Java</th><th style="text-align:center">Native</th></tr></thead><tbody><tr><td style="text-align:center">Ljava/lang/String;</td><td style="text-align:center">String</td><td style="text-align:center">jstring</td></tr><tr><td style="text-align:center">L+classname +;</td><td style="text-align:center">所有对象</td><td style="text-align:center">jobject</td></tr><tr><td style="text-align:center">[L+classname +;</td><td style="text-align:center">Object[]</td><td style="text-align:center">jobjectArray</td></tr><tr><td style="text-align:center">Ljava.lang.Class;</td><td style="text-align:center">Class</td><td style="text-align:center">jclass</td></tr><tr><td style="text-align:center">Ljava.lang.Throwable;</td><td style="text-align:center">Throwable</td><td style="text-align:center">jthrowable</td></tr></tbody></table><h4 id="签名实例"><a href="#签名实例" class="headerlink" title="签名实例"></a>签名实例</h4><table><thead><tr><th style="text-align:center">Java函数</th><th style="text-align:center">对应的签名</th></tr></thead><tbody><tr><td style="text-align:center">void foo()</td><td style="text-align:center">()V</td></tr><tr><td style="text-align:center">float foo(int i)</td><td style="text-align:center">(I)F</td></tr><tr><td style="text-align:center">long foo(int[] i)</td><td style="text-align:center">([I)J</td></tr><tr><td style="text-align:center">double foo(Class c)</td><td style="text-align:center">(Ljava/lang/Class;)D</td></tr><tr><td style="text-align:center">boolean foo(int[] i,String s)</td><td style="text-align:center">([ILjava/lang/String;)Z</td></tr><tr><td style="text-align:center">String foo(int i)</td><td style="text-align:center">(I)Ljava/lang/String;</td></tr></tbody></table><h2 id="Java调用C-C"><a href="#Java调用C-C" class="headerlink" title="Java调用C/C++"></a>Java调用C/C++</h2><ul><li><p>新建一个<code>Sample.java</code>源文件</p></li><li><p>获得<code>Sample.class</code>类文件</p></li></ul><pre><code>javac Sample.java</code></pre><ul><li>获得头文件</li></ul><pre><code>javah Sample</code></pre><ul><li>通过C或者C++来实现这些函数，然后生成<code>dll</code>或者<code>so</code>，在mac上，需要生成<code>libSample.jnilib</code></li></ul><pre><code>gcc -I$JAVA_HOME/include -I$JAVA_HOME/include/darwin -c Sample.c  gcc -dynamiclib -o libSample.jnilib Samplie.o</code></pre><ul><li>运行</li></ul><pre><code>java Sample</code></pre><p>Sample.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">JNIEXPORT jint JNICALL Java_Sample_intMethod</span><br><span class="line">  (JNIEnv *env, jobject obj, jint num)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> num * num;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">JNIEXPORT jboolean JNICALL Java_Sample_booleanMethod</span><br><span class="line">  (JNIEnv *env, jobject obj, jboolean boolean)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> !boolean;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">JNIEXPORT jstring JNICALL Java_Sample_stringMethod</span><br><span class="line">  (JNIEnv *env, jobject obj, jstring <span class="built_in">string</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* str = (*env)-&gt;GetStringUTFChars(env, <span class="built_in">string</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">char</span> cap[<span class="number">128</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(cap, str);</span><br><span class="line">    (*env)-&gt;ReleaseStringUTFChars(env, <span class="built_in">string</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> (*env)-&gt;NewStringUTF(env, strupr(cap));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">JNIEXPORT jint JNICALL Java_Sample_intArrayMethod</span><br><span class="line">  (JNIEnv *env, jobject obj, jintArray <span class="built_in">array</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i, sum = <span class="number">0</span>;</span><br><span class="line">    jsize len = (*env)-&gt;GetArrayLength(env, <span class="built_in">array</span>);</span><br><span class="line">    jint *body = (*env)-&gt;GetIntArrayElements(env, <span class="built_in">array</span>, <span class="number">0</span>);</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += body[i];</span><br><span class="line">    &#125;</span><br><span class="line">    (*env)-&gt;ReleaseIntArrayElements(env, <span class="built_in">array</span>, body, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>(*env)-&gt;GetStringUTFChars()</code>这个方法，是用来在Java和C之间转换字符串的，因为Java本身都使用了双字节的字符， 而C语言本身都是单字节的字符，所以需要进行转换</p><p><code>JNIEnv*</code>是每个函数都有的参数, 它包含了很多有用的方法， 使用起来类似Java的反射，也提供了这样一个编码转换的函数</p><p><code>GetStringUTFChars()</code>和<code>NewStringUTF()</code>， 第一个是从UTF8转换为C的编码格式， 第二个是根据C的字符串返回一个UTF8字符串</p><p><code>ReleaseStringUTFChars()</code>是用来释放对象的， 在Java中有虚拟机进行垃圾回收，但是在C语言中，这些对象必须手动回收，否则可能造成内存泄漏</p><h2 id="C-C-调用Java"><a href="#C-C-调用Java" class="headerlink" title="C/C++调用Java"></a>C/C++调用Java</h2><p>Sample.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello, "</span> + name + <span class="string">"!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello, "</span> + name + <span class="string">"!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SampleTest.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;jni.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 环境变量PATH在windows下和linux下的分割符定义</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _WIN32</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PATH_SEPARATOR <span class="meta-string">';'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PATH_SEPARATOR <span class="meta-string">':'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    JavaVMOption options[<span class="number">1</span>];</span><br><span class="line">    JNIEnv *env;</span><br><span class="line">    JavaVM *jvm;</span><br><span class="line">    JavaVMInitArgs vm_args;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">long</span> status;</span><br><span class="line">    jclass cls;</span><br><span class="line">    jmethodID mid;</span><br><span class="line">    jfieldID fid;</span><br><span class="line">    jobject obj;</span><br><span class="line">     </span><br><span class="line">    options[<span class="number">0</span>].optionString = <span class="string">"-Djava.class.path=."</span>;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;vm_args, <span class="number">0</span>, <span class="keyword">sizeof</span>(vm_args));</span><br><span class="line">    vm_args.version = JNI_VERSION_1_4;</span><br><span class="line">    vm_args.nOptions = <span class="number">1</span>;</span><br><span class="line">    vm_args.options = options;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// 启动虚拟机</span></span><br><span class="line">    status = JNI_CreateJavaVM(&amp;jvm, (<span class="keyword">void</span>**)&amp;env, &amp;vm_args);</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span> (status != JNI_ERR) &#123;</span><br><span class="line">        <span class="comment">// 先获得class对象</span></span><br><span class="line">        cls = (*env)-&gt;FindClass(env, <span class="string">"Sample2"</span>);</span><br><span class="line">        <span class="keyword">if</span> (cls != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取方法ID, 通过方法名和签名, 调用静态方法</span></span><br><span class="line">            mid = (*env)-&gt;GetStaticMethodID(env, cls, <span class="string">"sayHello"</span>, <span class="string">"(Ljava/lang/String;)Ljava/lang/String;"</span>);</span><br><span class="line">            <span class="keyword">if</span> (mid != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">char</span>* name = <span class="string">"World"</span>;</span><br><span class="line">                jstring arg = (*env)-&gt;NewStringUTF(env, name);</span><br><span class="line">                jstring result = (jstring)(*env)-&gt;CallStaticObjectMethod(env, cls, mid, arg);</span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">char</span>* str = (*env)-&gt;GetStringUTFChars(env, result, <span class="number">0</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Result of sayHello: %s\n"</span>, str);</span><br><span class="line">                (*env)-&gt;ReleaseStringUTFChars(env, result, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">             </span><br><span class="line">            <span class="comment">// 调用指定的构造函数, 构造函数的名字叫做&lt;init&gt;</span></span><br><span class="line">            mid = (*env)-&gt;GetMethodID(env, cls, <span class="string">"&lt;init&gt;"</span>, <span class="string">"()V"</span>);</span><br><span class="line">            obj = (*env)-&gt;NewObject(env, cls, mid);</span><br><span class="line">            <span class="keyword">if</span> (obj == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Create object failed!\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取属性ID, 通过属性名和签名</span></span><br><span class="line">            fid = (*env)-&gt;GetFieldID(env, cls, <span class="string">"name"</span>, <span class="string">"Ljava/lang/String;"</span>);</span><br><span class="line">            <span class="keyword">if</span> (fid != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">char</span>* name = <span class="string">"Tom"</span>;</span><br><span class="line">                jstring arg = (*env)-&gt;NewStringUTF(env, name);</span><br><span class="line">                (*env)-&gt;SetObjectField(env, obj, fid, arg); <span class="comment">// 修改属性</span></span><br><span class="line">            &#125;</span><br><span class="line">             </span><br><span class="line">            <span class="comment">// 调用成员方法</span></span><br><span class="line">            mid = (*env)-&gt;GetMethodID(env, cls, <span class="string">"sayHello"</span>, <span class="string">"()Ljava/lang/String;"</span>);</span><br><span class="line">            <span class="keyword">if</span> (mid != <span class="number">0</span>) &#123;</span><br><span class="line">                jstring result = (jstring)(*env)-&gt;CallObjectMethod(env, obj, mid);</span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">char</span>* str = (*env)-&gt;GetStringUTFChars(env, result, <span class="number">0</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Result of sayHello: %s\n"</span>, str);</span><br><span class="line">                (*env)-&gt;ReleaseStringUTFChars(env, result, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        (*jvm)-&gt;DestroyJavaVM(jvm);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"JVM Created failed!\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码比较好理解，做了这些事：</p><ul><li>创建虚拟机JVM, 在程序结束的时候销毁虚拟机JVM</li><li>寻找class对象</li><li>创建class对象的实例</li><li>调用方法和修改属性</li></ul><p><code>JavaVM</code>就是我们需要创建的虚拟机实例<br><code>JavaVMOption</code>相当于在命令行里传入的参数<br><code>JNIEnv</code>在Java调用C/C++中每个方法都会有的一个参数, 拥有一个JNI的环境<br><code>JavaVMInitArgs</code>就是虚拟机创建的初始化参数，这个参数里面会包含JavaVMOption</p><blockquote><p>在MAC下用<code>gcc</code>编译遇到找不到JVM库的问题，还不知道怎么解决</p></blockquote><h2 id="AIDL"><a href="#AIDL" class="headerlink" title="AIDL"></a>AIDL</h2><p><code>AIDL（Android 接口定义语言）</code>与您可能使用过的其他IDL类似。 您可以利用它定义客户端与服务使用进程间通信(IPC)进行相互通信时都认可的编程接口。 在Android上，一个进程通常无法访问另一个进程的内存。 尽管如此，进程需要将其对象分解成操作系统能够识别的原语，并将对象编组成跨越边界的对象。编写执行这一编组操作的代码是一项繁琐的工作，因此Android会使用AIDL来处理。</p><blockquote><p>只有允许不同应用的客户端用IPC 方式访问服务，并且想要在服务中处理多线程时，才有必要使用AIDL。 如果您不需要执行跨越不同应用的并发IPC，就应该通过实现一个<code>Binder</code>创建接口；或者，如果您想执行IPC，但根本不需要处理多线程，则使用<code>Messenger</code>类来实现接口。无论如何，在实现AIDL之前，请您务必理解绑定服务。</p></blockquote><h3 id="定义AIDL接口"><a href="#定义AIDL接口" class="headerlink" title="定义AIDL接口"></a>定义AIDL接口</h3><p>您必须使用Java编程语言语法在<code>.aidl</code>文件中定义AIDL接口，然后将它保存在托管服务的应用以及任何其他绑定到服务的应用的源代码内。</p><p>您开发每个包含.aidl文件的应用时，Android SDK工具都会生成一个基于该.aidl文件的<code>IBinder</code>接口，并将其保存在项目的<code>gen/</code>目录中。服务必须视情况实现<code>IBinder</code>接口。然后客户端应用便可绑定到该服务，并调用<code>IBinder</code>中的方法来执行IPC。</p><p>如需使用 AIDL 创建绑定服务，请执行以下步骤：</p><ol><li>创建 .aidl 文件<br>此文件定义带有方法签名的编程接口。</li><li>实现接口<br>Android SDK工具基于您的.aidl文件，使用Java编程语言生成一个接口。此接口具有一个名为<code>Stub</code>的内部抽象类，用于扩展<code>Binder</code>类并实现AIDL接口中的方法。您必须扩展<code>Stub</code>类并实现方法。</li><li>向客户端公开该接口<br>实现<code>Service</code>并重写<code>onBind()</code>以返回Stub类的实现。</li></ol><h4 id="创建AIDL文件"><a href="#创建AIDL文件" class="headerlink" title="创建AIDL文件"></a>创建AIDL文件</h4><p>AIDL使用简单语法，使您能通过可带参数和返回值的一个或多个方法来声明接口。 参数和返回值可以是任意类型，甚至可以是其他AIDL生成的接口。</p><p>您必须使用Java编程语言构建.aidl文件。每个.aidl文件都必须定义单个接口，并且只需包含接口声明和方法签名。</p><p>默认情况下，AIDL支持下列数据类型：</p><ul><li>Java编程语言中的所有原语类型（如<code>int</code>、<code>long</code>、<code>char</code>、<code>boolean</code> 等等）</li><li><code>String</code></li><li><code>CharSequence</code></li><li><code>List</code><br><code>List</code>中的所有元素都必须是以上列表中支持的数据类型、其他AIDL生成的接口或您声明的可打包类型。可选择将<code>List</code>用作通用类（例如，<code>List&lt;String&gt;</code>）。另一端实际接收的具体类始终是<code>ArrayList</code>，但生成的方法使用的是<code>List</code>接口。</li><li><code>Map</code><br><code>Map</code>中的所有元素都必须是以上列表中支持的数据类型、其他AIDL生成的接口或您声明的可打包类型。不支持通用<code>Map</code>（如<code>Map&lt;String,Integer&gt;</code>形式的<code>Map</code>）。另一端实际接收的具体类始终是<code>HashMap</code>，但生成的方法使用的是<code>Map</code>接口。</li></ul><p>您必须为以上未列出的每个附加类型加入一个import语句，即使这些类型是在与您的接口相同的软件包中定义。</p><p>定义服务接口时，请注意：</p><ul><li>方法可带零个或多个参数，返回值或空值。</li><li>所有非原语参数都需要指示数据走向的方向标记。可以是<code>in</code>、<code>out</code>或<code>inout</code>。原语默认为<code>in</code>，不能是其他方向。<blockquote><p>注意：您应该将方向限定为真正需要的方向，因为编组参数的开销极大。</p></blockquote></li><li>.aidl 文件中包括的所有代码注释都包含在生成的<code>IBinder接口中</code>（import 和 package 语句之前的注释除外）</li><li>只支持方法；您不能公开AIDL中的静态字段。</li></ul><p>示例aidl文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.android;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IRemoteService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getPid</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">basicTypes</span><span class="params">(<span class="keyword">int</span> anInt, <span class="keyword">long</span> aLong, <span class="keyword">boolean</span> aBoolean, <span class="keyword">float</span> aFloat, <span class="keyword">double</span> aDouble, String aString)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h4><p>示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> IRemoteService.Stub mBinder = <span class="keyword">new</span> IRemoteService.Stub() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPid</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Process.myPid();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">basicTypes</span><span class="params">(<span class="keyword">int</span> anInt, <span class="keyword">long</span> aLong, <span class="keyword">boolean</span> aBoolean, <span class="keyword">float</span> aFloat, <span class="keyword">double</span> aDouble, String aString)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在实现 AIDL 接口时应注意遵守以下这几个规则：</p><ul><li>由于不能保证在主线程上执行传入调用，因此您一开始就需要做好多线程处理准备，并将您的服务正确地编译为线程安全服务。</li><li>默认情况下，RPC调用是同步调用。如果您明知服务完成请求的时间不止几毫秒，就不应该从Activity的主线程调用服务，因为这样做可能会使应用挂起。您通常应该从客户端内的单独线程调用服务。</li><li>您引发的任何异常都不会回传给调用方。</li></ul><h4 id="向客户端公开接口"><a href="#向客户端公开接口" class="headerlink" title="向客户端公开接口"></a>向客户端公开接口</h4><p>示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoteService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mBinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> IRemoteService.Stub mBinder = <span class="keyword">new</span> IRemoteService.Stub() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPid</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Process.myPid();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">basicTypes</span><span class="params">(<span class="keyword">int</span> anInt, <span class="keyword">long</span> aLong, <span class="keyword">boolean</span> aBoolean, <span class="keyword">float</span> aFloat, <span class="keyword">double</span> aDouble, String aString)</span> </span>&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当客户端（如Activity）调用<code>bindService()</code>以连接此服务时，客户端的<code>onServiceConnected()</code>回调会接收服务的<code>onBind()</code>方法返回的mBinder实例。</p><p>客户端还必须具有对接口类的访问权限，因此如果客户端和服务在不同的应用内，则客户端的应用<code>src/</code> 目录内必须包含.aidl文件（它生成 <code>android.os.Binder</code>接口 — 为客户端提供对AIDL方法的访问权限）的副本。</p><p>当客户端在<code>onServiceConnected()</code>回调中收到IBinder时，它必须调用<code>asInterface(service)</code>以将返回的参数转换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">IRemoteService mIRemoteService;</span><br><span class="line"><span class="keyword">private</span> ServiceConnection mConnection = <span class="keyword">new</span> ServiceConnection() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName className, IBinder service)</span> </span>&#123;</span><br><span class="line">        mIRemoteService = IRemoteService.Stub.asInterface(service);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName className)</span> </span>&#123;</span><br><span class="line">        mIRemoteService = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="通过IPC传递对象"><a href="#通过IPC传递对象" class="headerlink" title="通过IPC传递对象"></a>通过IPC传递对象</h3><p>通过IPC接口把某个类从一个进程发送到另一个进程是可以实现的。不过，您必须确保该类的代码对IPC通道的另一端可用，并且该类必须支持<code>Parcelable</code>接口。支持<code>Parcelable</code>接口很重要，因为Android系统可通过它将对象分解成可编组到各进程的原语。</p><p>如需创建支持<code>Parcelable</code>协议的类，您必须执行以下操作：</p><ul><li>让您的类实现<code>Parcelable</code>接口  </li><li>实现<code>writeToParcel</code>，它会获取对象的当前状态并将其写入Parcel。</li><li>为您的类添加一个名为<code>CREATOR</code>的静态字段，这个字段是一个实现<code>Parcelable.Creator</code>接口的对象。</li><li>最后，创建一个声明可打包类的.aidl 文件<br>如果您使用的是自定义编译进程，切勿在您的编译中添加.aidl文件。 此.aidl文件与C语言中的头文件类似，并未编译。<br>AIDL在它生成的代码中使用这些方法和字段将您的对象编组和取消编组。</li></ul><p>Rect.aidl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> android.graphics;</span><br><span class="line"></span><br><span class="line">parcelable Rect;</span><br></pre></td></tr></table></figure><p>Rect.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> android.os.Parcel;</span><br><span class="line"><span class="keyword">import</span> android.os.Parcelable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Rect</span> <span class="keyword">implements</span> <span class="title">Parcelable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> left;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> top;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> right;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> bottom;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Parcelable.Creator&lt;Rect&gt; CREATOR = <span class="keyword">new</span></span><br><span class="line">Parcelable.Creator&lt;Rect&gt;() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Rect <span class="title">createFromParcel</span><span class="params">(Parcel in)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Rect(in);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Rect[] newArray(<span class="keyword">int</span> size) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Rect[size];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Rect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Rect</span><span class="params">(Parcel in)</span> </span>&#123;</span><br><span class="line">        readFromParcel(in);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeToParcel</span><span class="params">(Parcel out)</span> </span>&#123;</span><br><span class="line">        out.writeInt(left);</span><br><span class="line">        out.writeInt(top);</span><br><span class="line">        out.writeInt(right);</span><br><span class="line">        out.writeInt(bottom);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFromParcel</span><span class="params">(Parcel in)</span> </span>&#123;</span><br><span class="line">        left = in.readInt();</span><br><span class="line">        top = in.readInt();</span><br><span class="line">        right = in.readInt();</span><br><span class="line">        bottom = in.readInt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="调用IPC方法"><a href="#调用IPC方法" class="headerlink" title="调用IPC方法"></a>调用IPC方法</h3><p>调用类必须执行以下步骤，才能调用使用AIDL定义的远程接口：</p><ul><li>在项目<code>src/</code>目录中加入.aidl文件</li><li>声明一个<code>IBinder</code>接口实例（基于AIDL生成）</li><li>实现<code>ServiceConnection</code></li><li>调用<code>Context.bindService()</code>，以传入您的<code>ServiceConnection</code>实现</li><li>在您的<code>onServiceConnected()</code>实现中，您将收到一个<code>IBinder实例</code>（名为 <code>service</code>）。调用<code>asInterface((IBinder)service)</code>，以将返回的参数转换类型</li><li>调用您在接口上定义的方法。您应该始终捕获<code>DeadObjectException</code>异常，它们是在连接中断时引发的；这将是远程方法引发的唯一异常。</li><li>如需断开连接，请使用您的接口实例调用<code>Context.unbindService()</code>。</li></ul><p>有关调用IPC服务的几点说明：</p><ul><li>对象是跨进程计数的引用</li><li>您可以将匿名对象作为方法参数发送</li></ul><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ol><li><p>传递对象<br>.aidl文件和实现文件都放在系统创建的<code>aidl</code>目录下，编译时可能出现找不到符号的问题，需要对<code>build.gradle</code>做修改，增加源码集</p><pre><code>sourceSets {    main {        java.srcDirs = [&apos;src/main/java&apos;, &apos;src/main/aidl&apos;]    }}</code></pre></li></ol><p>另外注意要指定对象的<code>in</code>/<code>out</code>/<code>inout</code>类型，否则会报错</p><ol><li>绑定远程服务<br>可能出现服务必须为显示调用的错误，这样解决，通过指定包名</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">intent.setAction(<span class="string">"android.intent.action.RemoteService"</span>);</span><br><span class="line">intent.setPackage(<span class="string">"lakeshire.gitlab.com.aidlserver"</span>);</span><br><span class="line">bindService(intent, mConnectionRemote, Context.BIND_AUTO_CREATE);</span><br></pre></td></tr></table></figure><p>服务端的AndroidManifest.xml注册一下这个服务</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;service android:name=<span class="string">".RemoteService"</span> android:exported=<span class="string">"true"</span>&gt;</span><br><span class="line">    &lt;intent-filter&gt;</span><br><span class="line">        &lt;action android:name=<span class="string">"android.intent.action.RemoteService"</span> /&gt;</span><br><span class="line">        &lt;category android:name=<span class="string">"android.intent.category.DEFAULT"</span> /&gt;</span><br><span class="line">    &lt;/intent-filter&gt;</span><br><span class="line">&lt;/service&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JNI是&lt;code&gt;Java Native Interface&lt;/code&gt;的缩写，它提供了若干的API实现了Java和其他语言的通信（主要是C/C++）&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://lakeshire.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://lakeshire.github.io/tags/Android/"/>
    
      <category term="JNI" scheme="http://lakeshire.github.io/tags/JNI/"/>
    
      <category term="C/C++" scheme="http://lakeshire.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>Git相关</title>
    <link href="http://lakeshire.github.io/2017/03/20//archivers/git-related/"/>
    <id>http://lakeshire.github.io/2017/03/20//archivers/git-related/</id>
    <published>2017-03-20T04:00:00.000Z</published>
    <updated>2017-11-28T03:12:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>Git是目前世界上最先进的分布式版本控制系统</p><a id="more"></a><p>参考<a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">Git教程</a></p><h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><p>Git是目前世界上最先进的分布式版本控制系统</p><h2 id="版本管理"><a href="#版本管理" class="headerlink" title="版本管理"></a>版本管理</h2><h3 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h3><p>选择一个空目录</p><pre><code>git init</code></pre><h3 id="添加文件"><a href="#添加文件" class="headerlink" title="添加文件"></a>添加文件</h3><pre><code>git add [filename]</code></pre><p>将文件修改从工作区添加到暂存区</p><h3 id="提交修改"><a href="#提交修改" class="headerlink" title="提交修改"></a>提交修改</h3><pre><code>git commit -m [filename]</code></pre><p>将文件修改从暂存区提交到当前分支</p><h3 id="版本历史"><a href="#版本历史" class="headerlink" title="版本历史"></a>版本历史</h3><pre><code>git log --pretty=oneline</code></pre><h3 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h3><pre><code>git reset --hard HEAD^</code></pre><p><code>HEAD</code>表示当前版本，<code>^</code>表示上个版本，<code>^^</code>表示上上个版本</p><p>也可以直接指定版本序列号</p><pre><code>git reflog</code></pre><p>可以查看每一次命令</p><h3 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h3><pre><code>git checkout -- [filename]</code></pre><p>把文件在工作区的修改全部撤销，这里有两种情况：</p><p>一种是文件自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</p><p>一种是文件已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</p><p>总之，就是让这个文件回到最近一次提交或添加时的状态</p><p>如果添加到暂存区了或已经提交到分支，可以这样撤销：</p><pre><code>git reset HEAD [filename]</code></pre><h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><pre><code>git rm [filename]</code></pre><h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><h3 id="添加远程库"><a href="#添加远程库" class="headerlink" title="添加远程库"></a>添加远程库</h3><p>把本地仓库推送到远程</p><pre><code>git remote add origin [url]</code></pre><p>先在远程添加一个</p><pre><code>git push -u origin master</code></pre><p>然后推送，<code>-u</code>可以把本地的<code>master</code>分支和远程<code>master</code>关联  </p><p>之后的推送可以用</p><pre><code>git push origin master</code></pre><h3 id="从远程库克隆"><a href="#从远程库克隆" class="headerlink" title="从远程库克隆"></a>从远程库克隆</h3><pre><code>git clone [url]</code></pre><h3 id="同步远程库信息"><a href="#同步远程库信息" class="headerlink" title="同步远程库信息"></a>同步远程库信息</h3><pre><code>git fetch origin</code></pre><h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><h3 id="创建和合并分支"><a href="#创建和合并分支" class="headerlink" title="创建和合并分支"></a>创建和合并分支</h3><p>创建分支</p><pre><code>git checkout -b dev</code></pre><p>查看分支</p><pre><code>git branch</code></pre><p>合并分支，如在<code>master</code>分支合并<code>dev</code>的修改</p><pre><code>git merge dev</code></pre><p>删除分支</p><pre><code>git branch -d dev</code></pre><p>获取远程分支</p><pre><code>git checkout -b dev origin/dev</code></pre><h3 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h3><h3 id="分支管理策略"><a href="#分支管理策略" class="headerlink" title="分支管理策略"></a>分支管理策略</h3><h2 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h2><h3 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h3><pre><code>git tag [tag]</code></pre><h3 id="操作标签"><a href="#操作标签" class="headerlink" title="操作标签"></a>操作标签</h3><p>删除标签</p><pre><code>git tag -d [tag]</code></pre><p>推送标签到远程</p><pre><code>git push origin [tag]</code></pre><h2 id="自定义Git"><a href="#自定义Git" class="headerlink" title="自定义Git"></a>自定义Git</h2><h3 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h3><p>填写<code>.gitignore</code>文件</p><h3 id="配置别名"><a href="#配置别名" class="headerlink" title="配置别名"></a>配置别名</h3><pre><code>git config --global alias.co checkout</code></pre><h3 id="显示颜色"><a href="#显示颜色" class="headerlink" title="显示颜色"></a>显示颜色</h3><pre><code>git config --global color.ui true</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Git是目前世界上最先进的分布式版本控制系统&lt;/p&gt;
    
    </summary>
    
      <category term="Git" scheme="http://lakeshire.github.io/categories/Git/"/>
    
    
      <category term="Git" scheme="http://lakeshire.github.io/tags/Git/"/>
    
      <category term="版本管理" scheme="http://lakeshire.github.io/tags/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Gradle相关资料</title>
    <link href="http://lakeshire.github.io/2017/03/15//archivers/gradle-related/"/>
    <id>http://lakeshire.github.io/2017/03/15//archivers/gradle-related/</id>
    <published>2017-03-15T04:00:00.000Z</published>
    <updated>2017-11-28T03:12:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文罗列一些Gradle的资料</p><a id="more"></a><h2 id="深入理解Gradle"><a href="#深入理解Gradle" class="headerlink" title="深入理解Gradle"></a><a href="http://blog.csdn.net/innost/article/details/48228651" target="_blank" rel="noopener">深入理解Gradle</a></h2><p>这篇文章是从API的角度做的教程，可以更清楚的了解Gradle</p><h2 id="Gradle脚本基础全攻略"><a href="#Gradle脚本基础全攻略" class="headerlink" title="Gradle脚本基础全攻略"></a><a href="http://blog.csdn.net/yanbober/article/details/49314255" target="_blank" rel="noopener">Gradle脚本基础全攻略</a></h2><p>这个基本就是官方文档的翻译版，讲述了实现一些特性的方法</p><h2 id="Groovy脚本基础全攻略"><a href="#Groovy脚本基础全攻略" class="headerlink" title="Groovy脚本基础全攻略"></a><a href="http://blog.csdn.net/yanbober/article/details/49047515" target="_blank" rel="noopener">Groovy脚本基础全攻略</a></h2><p>Gradle是基于Groovy的DSL，可以通过这篇文章简单学习一下，更多参见<a href="http://www.groovy-lang.org/index.html" target="_blank" rel="noopener">Groovy官方网站</a></p><h2 id="Gradle-User-Guide"><a href="#Gradle-User-Guide" class="headerlink" title="Gradle User Guide"></a><a href="https://docs.gradle.org/3.4.1/userguide/userguide.html" target="_blank" rel="noopener">Gradle User Guide</a></h2><p>很详细的用户指南，就是看起来比较累</p><h2 id="Gradle-API"><a href="#Gradle-API" class="headerlink" title="Gradle API"></a><a href="https://docs.gradle.org/3.4.1/javadoc/" target="_blank" rel="noopener">Gradle API</a></h2><p>Gradle的API手册</p><h2 id="Gradle-DSL"><a href="#Gradle-DSL" class="headerlink" title="Gradle DSL"></a><a href="https://docs.gradle.org/3.4.1/dsl/" target="_blank" rel="noopener">Gradle DSL</a></h2><p>Gradle的DSL，差不多脚本块里面会用到的东西都可以这里查</p><h2 id="Gradle-Android-DSL"><a href="#Gradle-Android-DSL" class="headerlink" title="Gradle Android DSL"></a><a href="http://google.github.io/android-gradle-dsl/current/index.html" target="_blank" rel="noopener">Gradle Android DSL</a></h2><p>Gradle Android插件的DSL</p><h2 id="一个模板脚本"><a href="#一个模板脚本" class="headerlink" title="一个模板脚本"></a>一个模板脚本</h2><p>提供了很多特性，可以参考和直接使用，参见<a href="https://developer.android.google.cn/studio/build/gradle-tips.html" target="_blank" rel="noopener">Gradle Tips and Recipes</a></p><pre><code>apply plugin: &apos;com.android.application&apos;//  配置阶段清空结果文件夹def init() {    def outputDir = new File(project.rootDir, &apos;output&apos;)    outputDir.listFiles().each {        it.delete()    }}init()//  只能写为顶层工程的属性rootProject.ext {    compileSdkVersion = 25}android {    //  访问工程范围的属性    compileSdkVersion rootProject.ext.compileSdkVersion    buildToolsVersion &quot;25.0.2&quot;    defaultConfig {        applicationId &quot;lakeshire.gitlab.com.myapplication&quot;        minSdkVersion 14        targetSdkVersion 25        //  manifest可以使用这些        def filesAuthorityValue = applicationId + &apos;.files&apos;        manifestPlaceholders = [ filesAuthority : filesAuthorityValue ]        //  标识版本        versionCode 1        //  用户可见的版本号        versionName &quot;1.0&quot;        testInstrumentationRunner &quot;android.support.test.runner.AndroidJUnitRunner&quot;    }    signingConfigs {        //  发布版的签名配置        release {            storeFile file(&quot;../my-release-key.jks&quot;)            storePassword &quot;password&quot;            keyAlias &quot;alias&quot;            keyPassword &quot;password&quot;        }    }    buildTypes {        release {            signingConfig signingConfigs.release            minifyEnabled false            proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos;        }    }    //  指定两个产品风味的维度    flavorDimensions &apos;mode&apos;, &apos;api&apos;    productFlavors {        free {            dimension &apos;mode&apos;            versionNameSuffix &apos;-free&apos;        }        pay {            dimension &apos;mode&apos;            versionNameSuffix &apos;-pay&apos;        }        minApi24 {            dimension &quot;api&quot;            minSdkVersion &apos;24&apos;            versionCode 30000 + android.defaultConfig.versionCode            versionNameSuffix &quot;-minApi24&quot;        }        minApi21 {            dimension &quot;api&quot;            minSdkVersion &apos;21&apos;            versionCode 10000  + android.defaultConfig.versionCode            versionNameSuffix &quot;-minApi21&quot;        }    }    sourceSets {        //  改变文件的位置        main {            java.srcDirs = [&apos;other/java&apos;]            //  不能包含冲突的文件            res.srcDirs = [&apos;src/other/res&apos;]            manifest.srcFile &apos;src/main/AndroidManifest.xml&apos;            //  最常见的Eclipse工程转化为AS工程SO文件在这里找            jniLibs.srcDirs = [&apos;libs&apos;]        }        androidTest {            setRoot &apos;src/tests&apos;        }    }    //  产生分离的apk 可用来减小安装包 对应的包只包含相关的资源什么的    splits {        density {            enable true            exclude &quot;ldpi&quot;, &quot;mdpi&quot;            //  默认是排除，也可以先清理再包括            //  reset()            //  include &quot;hdpi&quot;, &quot;xhdpi&quot;, &quot;xxhdpi&quot;, &quot;xxxhdpi&quot;            compatibleScreens &apos;normal&apos;, &apos;large&apos;, &apos;xlarge&apos;        }        abi {            enable true            //  默认所有ABI都包括，清理            reset()            include &quot;x86&quot;, &quot;armeabi-v7a&quot;, &quot;mips&quot;            //  需要生成一个包括所有ABI的APK            universalApk true        }    }    //  过滤变体    variantFilter { variant -&gt;        def names = variant.flavors*.name        if (names.contains(&quot;minApi21&quot;) || names.contains(&quot;free&quot;)) {            setIgnore(true)        }    }    dexOptions {        maxProcessCount 8        javaMaxHeapSize &quot;2g&quot;        preDexLibraries true    }}dependencies {    compile fileTree(include: [&apos;*.jar&apos;], dir: &apos;libs&apos;)    androidTestCompile(&apos;com.android.support.test.espresso:espresso-core:2.2.2&apos;, {        exclude group: &apos;com.android.support&apos;, module: &apos;support-annotations&apos;    })    //  仓库    compile &apos;com.android.support:appcompat-v7:25.1.1&apos;    compile &apos;com.android.support:design:25.1.1&apos;    testCompile &apos;junit:junit:4.12&apos;    //  本地模块    compile project(&apos;:mylibrary&apos;)    //  AAR    compile(name: &apos;play-services-7.8.87&apos;, ext: &apos;aar&apos;)}//  对每个变体 找出对应任务 在任务完成后拷贝安装包到最终目录afterEvaluate {    project.android.applicationVariants.each { variant -&gt;        def assembleTaskName = &quot;assemble${variant.name.capitalize()}&quot;        def assembleTask = project.tasks.findByName(assembleTaskName)        if (assembleTask != null) {            assembleTask.doLast {                copyApk(variant)            }        }    }}//  拷贝安装包 只拷贝release版本 并重命名def copyApk(def variant) {    variant.outputs.each { output -&gt;        if (output.outputFile.name.contains(&apos;release&apos;) &amp;&amp; output.outputFile.name.endsWith(&apos;apk&apos;)) {            println &apos;================ Copy Release APK ================&apos;            println output.outputFile.name            def time = new Date().format(&quot;yyyyMMddHHmmss&quot;)            def mainName = output.outputFile.name.split(&quot;\\.&quot;)[0]            def dstName =  mainName + &apos;-&apos; + output.versionCode + &apos;-&apos; + time + &apos;.apk&apos;            def src = output.outputFile            def dst = new File(&quot;${project.rootDir}/output&quot;, dstName)            dst.withOutputStream { os -&gt;                src.withOutputStream { is -&gt;                    os &lt;&lt; is                }            }        }    }}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文罗列一些Gradle的资料&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://lakeshire.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://lakeshire.github.io/tags/Android/"/>
    
      <category term="Gradle" scheme="http://lakeshire.github.io/tags/Gradle/"/>
    
  </entry>
  
  <entry>
    <title>Android性能优化典范</title>
    <link href="http://lakeshire.github.io/2017/03/13//archivers/android-performance/"/>
    <id>http://lakeshire.github.io/2017/03/13//archivers/android-performance/</id>
    <published>2017-03-13T02:00:00.000Z</published>
    <updated>2017-11-28T03:12:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍一些Android的性能优化技巧</p><a id="more"></a><h2 id="绘制"><a href="#绘制" class="headerlink" title="绘制"></a>绘制</h2><h3 id="分析工具"><a href="#分析工具" class="headerlink" title="分析工具"></a>分析工具</h3><h4 id="开发者选项-过度绘制"><a href="#开发者选项-过度绘制" class="headerlink" title="开发者选项-过度绘制"></a><a href="https://developer.android.google.cn/studio/profile/dev-options-overdraw.html" target="_blank" rel="noopener">开发者选项-过度绘制</a></h4><p>过度绘制描述的是屏幕上的某个像素在同一帧的时间内被绘制了多次。在多层次的UI结构里面，如果不可见的UI也在做绘制的操作，这就会导致某些像素区域被绘制了多次。这就浪费大量的CPU以及GPU资源。</p><h4 id="开发者选项-GPU渲染"><a href="#开发者选项-GPU渲染" class="headerlink" title="开发者选项-GPU渲染"></a><a href="https://developer.android.google.cn/studio/profile/dev-options-rendering.html" target="_blank" rel="noopener">开发者选项-GPU渲染</a></h4><p>我们需要确保每一帧花费的总时间都低于这条横线（16ms），这样才能够避免出现卡顿的问题。</p><h4 id="HierarchyViewer"><a href="#HierarchyViewer" class="headerlink" title="HierarchyViewer"></a><a href="https://developer.android.google.cn/studio/profile/optimize-ui.html" target="_blank" rel="noopener">HierarchyViewer</a></h4><p>调整布局，去除过深的布局</p><h3 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h3><h4 id="优化过度绘制"><a href="#优化过度绘制" class="headerlink" title="优化过度绘制"></a>优化过度绘制</h4><ul><li>移除<code>Window</code>默认的背景</li><li>移除XML布局文件中非必需的背景</li><li>按需显示占位背景图片</li></ul><h4 id="使用API优化"><a href="#使用API优化" class="headerlink" title="使用API优化"></a>使用API优化</h4><p>Android系统会通过避免绘制那些完全不可见的组件来尽量减少重绘，但对自定义View无效，因为他们重写了<code>onDraw()</code></p><p>可以通过<code>Canvas.clipRect()</code>来帮助系统识别那些可见的区域。这个方法可以指定一块矩形区域，只有在这个区域内才会被绘制，其他的区域会被忽视。这个API可以很好的帮助那些有多组重叠组件的自定义View来控制显示的区域。同时还可以帮助节约CPU与GPU资源，区域之外的绘制指令都不会被执行，那些部分内容在矩形区域内的组件，仍然会得到绘制。</p><p>还可以使用<code>Canvas.quickReject()</code>来判断是否没和某个矩形相交，从而跳过那些非矩形区域内的绘制操作。</p><h4 id="减少绘制区域"><a href="#减少绘制区域" class="headerlink" title="减少绘制区域"></a>减少绘制区域</h4><p>在Android里面一个相对操作比较繁重的事情是对Bitmap进行旋转，缩放，裁剪等等。例如在一个圆形的钟表图上，我们把时钟的指针抠出来当做单独的图片进行旋转会比旋转一张完整的圆形图的所形成的帧率要高56%。</p><p>尽量减少每次重绘的元素可以极大的提升性能，假如某个钟表界面上有很多需要显示的复杂组件，我们可以把这些组件做拆分处理，例如把背景图片单独拎出来设置为一个独立的View，通过<code>setLayerType()</code>方法使得这个View强制用硬件来进行渲染。至于界面上哪些元素需要做拆分，他们各自的更新频率是多少，需要有针对性的单独讨论。</p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="http://mrpeak.cn//android/2016/01/11/android-performance-ui/" target="_blank" rel="noopener">UI性能优化详解</a></p><h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><h3 id="分析工具-1"><a href="#分析工具-1" class="headerlink" title="分析工具"></a>分析工具</h3><h4 id="Memory-Monitor"><a href="#Memory-Monitor" class="headerlink" title="Memory Monitor"></a><a href="https://developer.android.google.cn/studio/profile/am-memory.html" target="_blank" rel="noopener">Memory Monitor</a></h4><p>查看整个应用所占用的内存，以及发生GC的时刻，短时间内发生大量的GC操作是一个危险的信号</p><h4 id="Allocation-Tracker"><a href="#Allocation-Tracker" class="headerlink" title="Allocation Tracker"></a><a href="https://developer.android.google.cn/studio/profile/am-allocation.html" target="_blank" rel="noopener">Allocation Tracker</a></h4><p>使用此工具来追踪内存的分配</p><h4 id="Heap-Tool"><a href="#Heap-Tool" class="headerlink" title="Heap Tool"></a><a href="https://developer.android.google.cn/studio/profile/am-hprof.html" target="_blank" rel="noopener">Heap Tool</a></h4><p>查看当前内存快照，便于对比分析哪些对象有可能是泄漏了的</p><h3 id="优化方案-1"><a href="#优化方案-1" class="headerlink" title="优化方案"></a>优化方案</h3><h4 id="对象池"><a href="#对象池" class="headerlink" title="对象池"></a>对象池</h4><p>在程序里面经常会遇到的一个问题是短时间内创建大量的对象，导致内存紧张，从而触发GC导致性能问题。对于这个问题，我们可以使用对象池技术来解决它。通常对象池中的对象可能是Bitmap，View，Paint等等。</p><p>使用对象池技术有很多好处，它可以避免内存抖动，提升性能，但是在使用的时候有一些内容是需要特别注意的。通常情况下，初始化的对象池里面都是空白的，当使用某个对象的时候先去对象池查询是否存在，如果不存在则创建这个对象然后加入对象池，但是我们也可以在程序刚启动的时候就事先为对象池填充一些即将要使用到的数据，这样可以在需要使用到这些对象的时候提供更快的首次加载速度，这种行为就叫做预分配。使用对象池也有不好的一面，程序员需要手动管理这些对象的分配与释放，所以我们需要慎重地使用这项技术，避免发生对象的内存泄漏。为了确保所有的对象能够正确被释放，我们需要保证加入对象池的对象和其他外部对象没有互相引用的关系。</p><h5 id="图片的对象池应用"><a href="#图片的对象池应用" class="headerlink" title="图片的对象池应用"></a>图片的对象池应用</h5><p>Android在解码图片的时候引进了<code>inBitmap</code>属性，使用<code>inBitmap</code>属性可以告知Bitmap解码器去尝试使用已经存在的内存区域，新解码的Bitmap会尝试去使用之前那张Bitmap在Heap中所占据的内存区域，而不是去问内存重新申请一块区域来存放Bitmap。利用这种特性，即使是上千张的图片，也只会仅仅只需要占用屏幕所能够显示的图片数量的内存大小。</p><p>用<code>inBitmap</code>需要注意几个限制条件：</p><ul><li>在SDK 11 -&gt; 18之间，重用的Bitmap大小必须是一致的，例如给<code>inBitmap</code>赋值的图片大小为100-100，那么新申请的Bitmap必须也为100-100才能够被重用。从SDK 19开始，新申请的Bitmap大小必须小于或者等于已经赋值过的Bitmap大小。<br>新申请的bitmap与旧的bitmap必须有相同的解码格式，例如大家都是8888的，如</li></ul><p>我们可以创建一个包含多种典型可重用Bitmap的对象池，这样后续的Bitmap创建都能够找到合适的“模板”去进行重用。</p><h2 id="电量"><a href="#电量" class="headerlink" title="电量"></a>电量</h2><h3 id="优化措施"><a href="#优化措施" class="headerlink" title="优化措施"></a>优化措施</h3><ul><li>我们应该尽量减少唤醒屏幕的次数与持续的时间，使用<code>WakeLock</code>来处理唤醒的问题，能够正确执行唤醒操作并根据设定及时关闭操作进入睡眠状态。</li><li>某些非必须马上执行的操作，例如上传歌曲，图片处理等，可以等到设备处于充电状态或者电量充足的时候才进行。</li><li>触发网络请求的操作，每次都会保持无线信号持续一段时间，我们可以把零散的网络请求打包进行一次操作，避免过多的无线信号引起的电量消耗。关于网络请求引起无线信号的电量消耗，参考<a href="http://hukai.me/android-training-course-in-chinese/connectivity/efficient-downloads/efficient-network-access.html" target="_blank" rel="noopener">优化下载以高效访问网络</a></li><li>如果发现我们的App有电量消耗过多的问题，我们可以使用<code>JobScheduler API</code>来对一些任务进行定时处理，例如我们可以把那些任务重的操作等到手机处于充电状态，或者是连接到WiFi的时候来处理，参见<a href="http://hukai.me/android-training-course-in-chinese/background-jobs/scheduling/index.html" target="_blank" rel="noopener">管理设备的唤醒状态</a></li></ul><p>Android 5.0开始发布了<code>Battery History Tool</code>，它可以查看程序被唤醒的频率，又谁唤醒的，持续了多长的时间，这些信息都可以获取到。</p><h3 id="Networking-Traffic-Tool"><a href="#Networking-Traffic-Tool" class="headerlink" title="Networking Traffic Tool"></a>Networking Traffic Tool</h3><p>Android DDMS包含了一个查看网络使用详情的栏目来允许跟踪App 的网络请求。使用这个工具，可以监测App 是在何时，如何传输数据的，从而进行代码的优化。</p><h2 id="编码技巧"><a href="#编码技巧" class="headerlink" title="编码技巧"></a>编码技巧</h2><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p>数据显示<code>for index</code>方式在Android上有着更好的效率，但是因为不同平台编译器优化各有差异，我们最好还是针对实际的方法做一下简单的测量比较好，拿到数据之后，再选择效率最高的那个方式。</p><h3 id="LRU缓存"><a href="#LRU缓存" class="headerlink" title="LRU缓存"></a>LRU缓存</h3><p>使用<code>LRU Cache</code>能够显著提升应用的性能，可是也需要注意LRU Cache中被淘汰对象的回收，否者会引起严重的内存泄露。</p><h3 id="透明区域的性能影响"><a href="#透明区域的性能影响" class="headerlink" title="透明区域的性能影响"></a>透明区域的性能影响</h3><p>通常来说，对于不透明的View，显示它只需要渲染一次即可，可是如果这个View设置了<code>alpha</code>值，会至少需要渲染两次。</p><p>大多数情况下，屏幕上的元素都是由后向前进行渲染的。如果后渲染的元素有设置<code>alpha</code>值，那么这个元素就会和屏幕上已经渲染好的元素做混色处理。很多时候，我们会给整个View设置alpha的来达到淡出的动画效果，如果我们dui做alpha逐渐减小的处理，我们可以看到列表上的组件会逐渐融合到背景色上。但是在这个过程中，我们无法观察到它其实已经触发了额外的绘制任务，我们的目标是让整个View逐渐透明，可是期间ListView在不停的做混色操作，这样会导致不少性能问题。</p><p>如何渲染才能够得到我们想要的效果呢？我们可以先按照通常的方式把View上的元素按照从后到前的方式绘制出来，但是不直接显示到屏幕上，而是使用GPU预处理之后，再又GPU渲染到屏幕上，GPU可以对界面上的原始数据直接做旋转，设置透明度等等操作。使用GPU进行渲染，虽然第一次操作相比起直接绘制到屏幕上更加耗时，可是一旦原始纹理数据生成之后，接下去的操作就比较省时省力。</p><p>如何才能够让GPU来渲染某个View呢？我们可以通过<code>setLayerType()</code>的方法来指定View应该如何进行渲染，从SDK 16开始，我们还可以使用<code>ViewPropertyAnimator.alpha().withLayer()</code>来指定。</p><h3 id="优化自定义View"><a href="#优化自定义View" class="headerlink" title="优化自定义View"></a>优化自定义View</h3><ul><li>我们知道调用<code>View.invalidate()</code>会触发View的重绘，有两个原则需要遵守，第一是仅仅在View的内容发生改变的时候才去触发invalidate方法，第二是尽量使用<code>clipRect</code>等方法来提高绘制的性能。</li><li>减少绘制时不必要的绘制元素，对于那些不可见的元素，我们需要尽量避免重绘。</li><li>对于不在屏幕上的元素，可以使用<code>Canvas.quickReject</code>把他们给剔除，避免浪费CPU资源。另外尽量使用GPU来进行UI的渲染，这样能够极大的提高程序的整体表现性能。</li></ul><h3 id="图像格式"><a href="#图像格式" class="headerlink" title="图像格式"></a>图像格式</h3><p>常见格式的图片在设置到UI上之前需要经过解码的过程，而解压时可以选择不同的解码率，不同的解码率对内存的占用是有很大差别的。在不影响到画质的前提下尽量减少内存的占用，这能够显著提升应用程序的性能。</p><p>Android的Heap空间是不会自动做兼容压缩的，意思就是如果Heap空间中的图片被收回之后，这块区域并不会和其他已经回收过的区域做重新排序合并处理，那么当一个更大的图片需要放到Heap之前，很可能找不到那么大的连续空闲区域，那么就会触发GC，使得Heap腾出一块足以放下这张图片的空闲区域，如果无法腾出，就会发生OOM。</p><p>所以为了避免加载一张超大的图片，需要尽量减少这张图片所占用的内存大小，Android为图片提供了4种解码格式.随着解码占用内存大小的降低，清晰度也会有损失。我们需要针对不同的应用场景做不同的处理，大图和小图可以采用不同的解码率。</p><h3 id="位图缩放"><a href="#位图缩放" class="headerlink" title="位图缩放"></a>位图缩放</h3><p>对Bitmap做缩放，这也是Android里面经常遇到的问题。对Bitmap做缩放的意义很明显，提示显示性能，避免分配不必要的内存。Android提供了现成的Bitmap缩放的API，叫做<code>createScaledBitmap()</code>，使用这个方法可以获取到一张经过缩放的图片，可是这个方法能够执行的前提是，原图片需要事先加载到内存中，如果原图片过大，很可能导致OOM。</p><p>可以使用<code>inSampleSize</code>，能够等比的缩放显示图片，同时还避免了需要先把原图加载进内存的缺点。另外，我们还可以使用<code>inScaled</code>，<code>inDensity</code>，<code>inTargetDensity</code>的属性来对解码图片做处理，还有一个经常使用到的技巧是<code>inJustDecodeBounds</code>，使用这个属性去尝试解码图片，可以事先获取到图片的大小而不至于占用什么内存。</p><h3 id="性能优化工作流"><a href="#性能优化工作流" class="headerlink" title="性能优化工作流"></a>性能优化工作流</h3><p>大多数开发者在没有发现严重性能问题之前是不会特别花精力去关注性能优化的，通常大家关注的都是功能是否实现。当性能问题真的出现的时候，请不要慌乱。我们通常采用下面三个步骤来解决性能问题。</p><h4 id="收集数据"><a href="#收集数据" class="headerlink" title="收集数据"></a>收集数据</h4><p>我们可以通过Android SDK里面提供的诸多工具来收集CPU，GPU，内存，电量等等性能数据。</p><h4 id="分析数据"><a href="#分析数据" class="headerlink" title="分析数据"></a>分析数据</h4><p>通过上面的步骤，我们获取到了大量的数据，下一步就是分析这些数据。工具帮我们生成了很多可读性强的表格，我们需要事先了解如何查看表格的数据，每一项代表的含义，这样才能够快速定位问题。如果分析数据之后还是没有找到问题，那么就只能不停的重新收集数据，再进行分析，如此循环。</p><h4 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h4><p>定位到问题之后，我们需要采取行动来解决问题。解决问题之前一定要先有个计划，评估这个解决方案是否可行，是否能够及时的解决问题。</p><h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><p>HashMap内部是使用一个默认容量为16的数组来存储数据，而数组中每一个元素却又是一个链表的头结点，所以，更准确的来说，HashMap内部存储结构是使用哈希表的拉链结构（数组+链表），这种存储数据的方法叫做拉链法。</p><p>每一个结点都是Entry类型，存储的内容有Key、Value、Hash值、和下一个Entry，通过计算元素Key的Hash值，然后对HashMap中数组长度取余得到该元素存储的位置，如果有多个元素Key的Hash值相同的话，后一个元素并不会覆盖上一个元素，而是采取链表的方式，把之后加进来的元素加入链表末尾，从而解决了Hash冲突的问题，由此我们知道HashMap中处理Hash冲突的方法是链地址法。</p><p>我们知道HashMap中默认的存储大小就是一个容量为16的数组，所以当我们创建出一个HashMap对象时，即使里面没有任何元素，也要分别一块内存空间给它，而且，我们再不断的向HashMap里添加数据时，当达到一定的容量限制时（满足这样的一个关系时候将会扩容：HashMap中的数据量&gt;容量*加载因子，而HashMap中默认的加载因子是0.75），HashMap的空间将会扩大，而且扩大后新的空间一定是原来的2倍。</p><p>假如我们有几十万、几百万条数据，那么HashMap要存储完这些数据将要不断的扩容，而且在此过程中也需要不断的做哈希运算，这将对我们的内存空间造成很大消耗和浪费，而且HashMap获取数据是通过遍历Entry[]数组来得到对应的元素，在数据量很大时候会比较慢，所以在Android中，HashMap是比较费内存的，我们在一些情况下可以使用SparseArray和ArrayMap来代替HashMap。</p><h4 id="SparseArray"><a href="#SparseArray" class="headerlink" title="SparseArray"></a>SparseArray</h4><p>SparseArray比HashMap更省内存，在某些条件下性能更好，主要是因为它避免了对Key的自动装箱，它内部则是通过两个数组来进行数据存储的，一个存储Key，另外一个存储Value，为了优化性能，它内部对数据还采取了压缩的方式来表示稀疏数组的数据，从而节约内存空间。</p><p>SparseArray只能存储Key为int类型的数据，同时，SparseArray在存储和读取数据时候，使用的是二分查找法。SparseArray存储的元素都是按元素的Key值从小到大排列好的。而在获取数据的时候，也是使用二分查找法判断元素的位置，所以，在获取数据的时候非常快，比HashMap快的多。</p><p>SparseArray还提供了两个特有方法，更方便数据的查询： </p><p>获取对应的Key：</p><pre><code>public int keyAt(int index)</code></pre><p>获取对应的Value：</p><pre><code>public E valueAt(int index)</code></pre><p>虽说SparseArray性能比较好，但是由于其添加、查找、删除数据都需要先进行一次二分查找，所以在数据量大的情况下性能并不明显，将降低至少50%。</p><p>满足下面两个条件我们可以使用SparseArray代替HashMap：</p><ul><li>数据量不大，最好在千级以内</li><li>Key必须为int类型，这中情况下的HashMap可以用SparseArray代替</li></ul><h4 id="ArrayMap"><a href="#ArrayMap" class="headerlink" title="ArrayMap"></a>ArrayMap</h4><p>ArrayMap是一个<key, value="">映射的数据结构，它设计上更多的是考虑内存的优化，内部是使用两个数组进行数据存储，一个数组记录Key的哈希值，另外一个数组记录Value值，它和SparseArray一样，也会对Key使用二分法进行从小到大排序，在添加、删除、查找数据的时候都是先使用二分查找法得到相应的index，然后通过index来进行添加、查找、删除等操作，所以，应用场景和SparseArray的一样，如果在数据量比较大的情况下，那么它的性能将退化至少50%。</key,></p><p>应用场景</p><ul><li>数据量不大，最好在千级以内</li><li>数据结构类型为Map类型</li></ul><h3 id="自动装箱"><a href="#自动装箱" class="headerlink" title="自动装箱"></a>自动装箱</h3><p>我们知道基础数据类型的大小：<code>boolean</code>(8 bits), <code>int</code>(32 bits), <code>float</code>(32 bits)，<code>long</code>(64 bits)，为了能够让这些基础数据类型在大多数Java容器中运作，会需要做一个AutoBoxing的操作，转换成<code>Boolean</code>，<code>Integer</code>，<code>Float</code>，<code>Long</code>等对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  基础类型</span></span><br><span class="line"><span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">    total += i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  下面的代码生成了很多新对象！</span></span><br><span class="line"><span class="comment">//  创建新对象，放进去值，加到total上</span></span><br><span class="line">Integer total = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">    total += i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AutoBoxing的行为还经常发生在类似HashMap这样的容器里面，对HashMap的增删改查操作都会发生了大量的AutoBoxing的行为。</p><p>Android提供了一些数据结构避免自动装箱行为：<code>SparseBoolMap</code>、<code>SparseIntMap</code>、<code>SparseLongMap</code>、<code>LongSparseMap</code></p><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>不要在Android中使用枚举，比起静态常量会有超出两倍的额外内存开销</p><h3 id="内存使用"><a href="#内存使用" class="headerlink" title="内存使用"></a>内存使用</h3><p>Android系统提供了一些回调来通知应用的内存使用情况，通常来说，当所有的<br>Background应用都被杀掉的时候，Forground应用会收到<code>onLowMemory()</code>的回调。在这种情况下，需要尽快释放当前应用的非必须内存资源，从而确保系统能够稳定继续运行。Android系统还提供了<code>onTrimMemory()</code>的回调，当系统内存达到某些条件的时候，所有正在运行的应用都会收到这个回调。</p><h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><p>通常来说，View会保持Activity的引用，Activity同时还和其他内部对象也有可能保持引用关系。当屏幕发生旋转的时候，Activity很容易发生泄漏，这样的话，里面的View也会发生泄漏。Activity以及View的泄漏是非常严重的，为了避免出现泄漏，请特别留意以下的规则：</p><ol><li>避免使用异步回调</li></ol><p>异步回调被执行的时间不确定，很有可能发生在Activity已经被销毁之后，这不仅仅很容易引起Crash，还很容易发生内存泄露。</p><ol><li>避免使用静态对象</li></ol><p>因为静态对象的生命周期过长，使用不当很可能导致泄漏，在Android中应该尽量避免使用静态对象。</p><ol><li>避免把View添加到没有清除机制的容器里面</li></ol><p>假如把View添加到WeakHashMap，如果没有执行清除操作，很可能会导致泄漏。</p><h3 id="定位与电量优化"><a href="#定位与电量优化" class="headerlink" title="定位与电量优化"></a>定位与电量优化</h3><p>开启定位功能是一个相对来说比较耗电的操作，一般通过<code>setInterval()</code>设置每隔多长的时间获取一次位置更新，时间相隔越短，自然花费的电量就越多，但是时间相隔太长，又无法及时获取到更新的位置信息。其中存在的一个优化点是，我们可以通过判断返回的位置信息是否相同，从而决定设置下次的更新间隔是否增加一倍，通过这种方式可以减少电量的消耗。</p><p>通过GPS定位服务相比起使用网络进行定位更加的耗电，但是也相对更加精准一些。为了提供不同精度的定位需求，同时屏蔽实现位置请求的细节，Android提供了下面4种不同精度与耗电量的参数给应用进行设置调用，应用只需要决定在适当的场景下使用对应的参数就好了，通过<code>LocationRequest.setPriority()</code>方法传递参数就好了。</p><h3 id="多重Layout"><a href="#多重Layout" class="headerlink" title="多重Layout"></a>多重Layout</h3><p><code>RelativeLayout</code>会发生两次<code>layout</code>，<code>LinearLayout</code>等在某些情况下也会触发两次<code>layout</code>，如果只是少量的重复布局本身并不会引起严重的性能问题，但是如果它们发生在布局的根节点，或者是列表里面的某个列表项，这样就会引起比较严重的性能问题。</p><p>我们可以使用<code>Systrace</code>来跟踪特定的某段操作，如果发现了疑似丢帧的现象，可能就是因为重复布局引起的。通常我们无法避免重复布局，在这种情况下，我们应该尽量保持View Hierarchy的层级比较浅，这样即使发生重复布局，也不会因为布局的层级比较深而增大了重复布局的倍数。另外还有一点需要特别注意，在任何时候都请避免调用<code>requestLayout()</code>的方法，因为一旦调用了requestLayout，会导致该布局的所有父节点都发生重新布局的操作。</p><h3 id="网络请求优化"><a href="#网络请求优化" class="headerlink" title="网络请求优化"></a>网络请求优化</h3><ul><li>使用回退机制来避免固定频繁的同步请求：在发现返回数据相同的情况下，推迟下次的请求时间</li><li>使用批处理的方式来集中发出请求，避免频繁的间隔请求</li><li>使用预取的技术提前把一些数据拿到，避免后面频繁再次发起网络请求</li><li>压缩传输数据</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍一些Android的性能优化技巧&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://lakeshire.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://lakeshire.github.io/tags/Android/"/>
    
      <category term="性能优化" scheme="http://lakeshire.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Android——测试</title>
    <link href="http://lakeshire.github.io/2017/03/01//archivers/android-test/"/>
    <id>http://lakeshire.github.io/2017/03/01//archivers/android-test/</id>
    <published>2017-03-01T06:30:00.000Z</published>
    <updated>2017-11-28T03:13:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍了Android应用的常用测试类型</p><a id="more"></a><h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><p>单元测试是编写测试代码，用来检测特定的、明确的、细颗粒的功能</p><p>单元测试不仅仅用来保证当前代码的正确性，更重要的是用来保证代码修复、改进或重构之后的正确性</p><p>一般来说，单元测试任务包括</p><ol><li>接口功能测试：用来保证接口功能的正确性</li><li><p>局部数据结构测试（不常用）：用来保证接口中的数据结构是正确的</p><ol><li>比如变量有无初始值</li><li>变量是否溢出</li></ol></li><li><p>边界条件测试</p><ol><li>变量没有赋值（即为NULL）</li><li><p>变量是数值（或字符)</p><ol><li>主要边界：最小值，最大值，无穷大（对于DOUBLE等）</li><li>溢出边界（期望异常或拒绝服务）：最小值-1，最大值+1</li><li>临近边界：最小值+1，最大值-1</li></ol></li><li><p>变量是字符串</p><ol><li>引用“字符变量”的边界</li><li>空字符串</li><li>对字符串长度应用“数值变量”的边界</li></ol></li><li><p>变量是集合</p><ol><li>空集合</li><li>对集合的大小应用“数值变量”的边界</li><li>调整次序：升序、降序</li></ol></li><li><p>变量有规律：比如对于Math.sqrt，给出n^2^-1和n^2^+1的边界</p></li></ol></li><li><p>所有独立执行通路测试：保证每一条代码，每个分支都经过测试，AndroidStudio中集成了<code>Jacoco</code>可以做覆盖率统计</p><ol><li>语句覆盖：保证每一个语句都执行到了</li><li>判定覆盖（分支覆盖）：保证每一个分支都执行到</li><li>条件覆盖：保证每一个条件都覆盖到true和false（即if、while中的条件语句）</li><li>路径覆盖：保证每一个路径都覆盖到</li><li>各条错误处理通路测试：保证每一个异常都经过测试</li></ol></li></ol><h3 id="JUnit"><a href="#JUnit" class="headerlink" title="JUnit"></a>JUnit</h3><p><code>JUnit4</code>通过注解来识别测试方法</p><ul><li><code>@BeforeClass</code> 全局执行一次，第一个运行</li><li><code>@Before</code> 测试方法运行前运行</li><li><code>@Test</code> 测试方法</li><li><code>@After</code> 测试方法运行后运行</li><li><code>@AfterClass</code> 全局执行一次，最后一个运行</li><li><code>@Ignore</code> 忽略</li></ul><h3 id="Mockito"><a href="#Mockito" class="headerlink" title="Mockito"></a><a href="http://site.mockito.org/" target="_blank" rel="noopener">Mockito</a></h3><p>Mock测试是单元测试的重要方法之一，就是对某些不容易构造或难以获取的对象，用一个虚拟的Mock对象创建以便测试的方法</p><p>最大的有点是可以解除单元测试的耦合，如果你的代码对另一个类或接口由依赖，能够模拟这些依赖，帮你验证调用的依赖行为</p><p>使用一个接口来描述这个对象 在产品代码中实现这个接口，在测试代码中实现这个接口 在被测试代码中只是通过接口来引用对象，所以它不知道这个引用的对象是真实对象，还是Mock对象</p><p><code>Mockito</code>是很强大的单元测试Mock框架</p><h4 id="验证行为"><a href="#验证行为" class="headerlink" title="验证行为"></a>验证行为</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.mockito.Mockito.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">//mock creation</span></span><br><span class="line">List mockedList = mock(List.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">//using mock object</span></span><br><span class="line">mockedList.add(<span class="string">"one"</span>);</span><br><span class="line">mockedList.clear();</span><br><span class="line"></span><br><span class="line"><span class="comment">//verification</span></span><br><span class="line">verify(mockedList).add(<span class="string">"one"</span>);</span><br><span class="line">verify(mockedList).clear();</span><br></pre></td></tr></table></figure><p>它会记得所有的交互，你可以验证</p><h4 id="打桩"><a href="#打桩" class="headerlink" title="打桩"></a>打桩</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LinkedList mockedList = mock(LinkedList.class);</span><br><span class="line">when(mockedList.get(<span class="number">0</span>)).thenReturn(<span class="string">"first"</span>);</span><br><span class="line">when(mockedList.get(<span class="number">1</span>)).thenThrow(<span class="keyword">new</span> RuntimeException());</span><br><span class="line">System.out.println(mockedList.get(<span class="number">0</span>));</span><br><span class="line">System.out.println(mockedList.get(<span class="number">1</span>));</span><br><span class="line">System.out.println(mockedList.get(<span class="number">999</span>));</span><br><span class="line">verify(mockedList).get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>可以为模拟的接口打桩，指定其行为，上面取第一个元素就会返回<code>first</code>，取第二个元素会抛出异常，取没有打桩的元素会返回<code>null</code></p><h4 id="参数匹配器"><a href="#参数匹配器" class="headerlink" title="参数匹配器"></a>参数匹配器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">when(mockedList.get(anyInt())).thenReturn(<span class="string">"element"</span>);</span><br><span class="line">when(mockedList.contains(argThat(isValid()))).thenReturn(<span class="string">"element"</span>);</span><br><span class="line">System.out.println(mockedList.get(<span class="number">999</span>));</span><br><span class="line">verify(mockedList).get(anyInt());</span><br></pre></td></tr></table></figure><p>用<code>anyInt()</code>匹配所有元素，用<code>argThat()</code>指定自定义参数匹配</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">verify(mock).someMethod(anyInt(), anyString(), eq(<span class="string">"third argument"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//  错误，所有的参数都应该由匹配器提供</span></span><br><span class="line">verify(mock).someMethod(anyInt(), anyString(), <span class="string">"third argument"</span>);</span><br></pre></td></tr></table></figure><h4 id="调用额外的调用数字"><a href="#调用额外的调用数字" class="headerlink" title="调用额外的调用数字"></a>调用额外的调用数字</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mockedList.add(<span class="string">"once"</span>);</span><br><span class="line"></span><br><span class="line">mockedList.add(<span class="string">"twice"</span>);</span><br><span class="line">mockedList.add(<span class="string">"twice"</span>);</span><br><span class="line"></span><br><span class="line">mockedList.add(<span class="string">"three times"</span>);</span><br><span class="line">mockedList.add(<span class="string">"three times"</span>);</span><br><span class="line">mockedList.add(<span class="string">"three times"</span>);</span><br><span class="line"></span><br><span class="line">verify(mockedList).add(<span class="string">"once"</span>);</span><br><span class="line">verify(mockedList, times(<span class="number">1</span>)).add(<span class="string">"once"</span>);</span><br><span class="line">verify(mockedList, times(<span class="number">2</span>)).add(<span class="string">"twice"</span>);</span><br><span class="line">verify(mockedList, times(<span class="number">3</span>)).add(<span class="string">"three times"</span>);</span><br><span class="line">verify(mockedList, never()).add(<span class="string">"never happened"</span>);</span><br><span class="line">verify(mockedList, atLeastOnce()).add(<span class="string">"three times"</span>);</span><br><span class="line">verify(mockedList, atLeast(<span class="number">2</span>)).add(<span class="string">"five times"</span>);</span><br><span class="line">verify(mockedList, atMost(<span class="number">5</span>)).add(<span class="string">"three times"</span>);</span><br></pre></td></tr></table></figure><h4 id="处理异常"><a href="#处理异常" class="headerlink" title="处理异常"></a>处理异常</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">doThrow(<span class="keyword">new</span> RuntimeException()).when(mockedList).clear();</span><br><span class="line">mockedList.clear();</span><br></pre></td></tr></table></figure><h4 id="有序验证"><a href="#有序验证" class="headerlink" title="有序验证"></a>有序验证</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">List singleMock = mock(List.class);</span><br><span class="line">singleMock.add(<span class="string">"was added first"</span>);</span><br><span class="line">singleMock.add(<span class="string">"was added second"</span>);</span><br><span class="line"></span><br><span class="line">InOrder inOrder = inOrder(singleMock);</span><br><span class="line"></span><br><span class="line">inOrder.verify(singleMock).add(<span class="string">"was added first"</span>);</span><br><span class="line">inOrder.verify(singleMock).add(<span class="string">"was added second"</span>);</span><br><span class="line"></span><br><span class="line">List firstMock = mock(List.class);</span><br><span class="line">List secondMock = mock(List.class);</span><br><span class="line"></span><br><span class="line">firstMock.add(<span class="string">"was called first"</span>);</span><br><span class="line">secondMock.add(<span class="string">"was called second"</span>);</span><br><span class="line"></span><br><span class="line">InOrder inOrder = inOrder(firstMock, secondMock);</span><br><span class="line"></span><br><span class="line">inOrder.verify(firstMock).add(<span class="string">"was called first"</span>);</span><br><span class="line">inOrder.verify(secondMock).add(<span class="string">"was called second"</span>);</span><br></pre></td></tr></table></figure><h4 id="确保不会发生交互"><a href="#确保不会发生交互" class="headerlink" title="确保不会发生交互"></a>确保不会发生交互</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mockOne.add(<span class="string">"one"</span>);</span><br><span class="line">verify(mockOne).add(<span class="string">"one"</span>);</span><br><span class="line">verify(mockOne, never()).add(<span class="string">"two"</span>);</span><br><span class="line">verifyZeroInteractions(mockTwo, mockThree);</span><br></pre></td></tr></table></figure><h4 id="寻找多余调用"><a href="#寻找多余调用" class="headerlink" title="寻找多余调用"></a>寻找多余调用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mockedList.add(<span class="string">"one"</span>);</span><br><span class="line">mockedList.add(<span class="string">"two"</span>);</span><br><span class="line">verify(mockedList).add(<span class="string">"one"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//  将会失败</span></span><br><span class="line">verifyNoMoreInteractions(mockedList);</span><br></pre></td></tr></table></figure><h4 id="一个列子"><a href="#一个列子" class="headerlink" title="一个列子"></a>一个列子</h4><p>Person.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(Integer id, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PersonDAO.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PersonDAO</span> </span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">fetchPerson</span><span class="params">(Integer id)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(Person person)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PersonService</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> PersonDAO personDAO;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PersonService</span><span class="params">(PersonDAO personDAO)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.personDAO = personDAO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">update</span><span class="params">(Integer id, String name)</span> </span>&#123;</span><br><span class="line">        Person person = personDAO.fetchPerson(id);</span><br><span class="line">        <span class="keyword">if</span> (person != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Person updatedPerson = <span class="keyword">new</span> Person(person.getId(), name);</span><br><span class="line">            personDAO.update(updatedPerson);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PersonServiceTest.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonServiceTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Mock</span> <span class="keyword">private</span> PersonDAO personDAO;</span><br><span class="line">    <span class="keyword">private</span> PersonService personService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//  初始化</span></span><br><span class="line">        MockitoAnnotations.initMocks(<span class="keyword">this</span>);</span><br><span class="line">        personService = <span class="keyword">new</span> PersonService(personDAO);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shouldUpdatePersonName</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person(<span class="number">1</span>, <span class="string">"Phillip"</span>);</span><br><span class="line">        <span class="comment">//  传入1时返回菲利普</span></span><br><span class="line">        when(personDAO.fetchPerson(<span class="number">1</span>)).thenReturn(person);</span><br><span class="line">        <span class="comment">//  测试update</span></span><br><span class="line">        <span class="keyword">boolean</span> updated = personService.update(<span class="number">1</span>, <span class="string">"David"</span>);</span><br><span class="line">        <span class="comment">//  判断是否更新成功(应该成功)</span></span><br><span class="line">        assertTrue(updated);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  验证是否调用fetchPerson</span></span><br><span class="line">        verify(personDAO).fetchPerson(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//  验证是否调用update</span></span><br><span class="line">        ArgumentCaptor&lt;Person&gt; personCaptor = ArgumentCaptor.forClass(Person.class);</span><br><span class="line">        verify(personDAO).update(personCaptor.capture());</span><br><span class="line">        Person updatedPerson = personCaptor.getValue();</span><br><span class="line">        <span class="comment">//  判断更新后的返回值</span></span><br><span class="line">        assertEquals(<span class="string">"David"</span>, updatedPerson.getName());</span><br><span class="line">        <span class="comment">//  判断是否有更多交互</span></span><br><span class="line">        verifyNoMoreInteractions(personDAO);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shouldNotUpdateIfPersonNotFound</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//  传入1时返回null</span></span><br><span class="line">        when(personDAO.fetchPerson(<span class="number">1</span>)).thenReturn(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">boolean</span> updated = personService.update(<span class="number">1</span>, <span class="string">"David"</span>);</span><br><span class="line">        <span class="comment">//  判断是否更新成功(应该失败)</span></span><br><span class="line">        assertFalse(updated);</span><br><span class="line">        <span class="comment">//  验证是否调用fetchPerson</span></span><br><span class="line">        verify(personDAO).fetchPerson(<span class="number">1</span>);</span><br><span class="line">        verifyZeroInteractions(personDAO);</span><br><span class="line">        verifyNoMoreInteractions(personDAO);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="仪器测试"><a href="#仪器测试" class="headerlink" title="仪器测试"></a>仪器测试</h2><h3 id="Espresso"><a href="#Espresso" class="headerlink" title="Espresso"></a><a href="https://developer.android.google.cn/studio/test/espresso-test-recorder.html" target="_blank" rel="noopener">Espresso</a></h3><p>测试登录页面跳转首页，判断是否登录成功</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(AndroidJUnit4.class)</span><br><span class="line"><span class="meta">@LargeTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Rule</span></span><br><span class="line">    <span class="keyword">public</span> ActivityTestRule&lt;LoginActivity&gt; mActivityRule = <span class="keyword">new</span> ActivityTestRule&lt;&gt;(LoginActivity.class);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loginWithWrongPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        onView(withId(R.id.et_username)).perform(replaceText(<span class="string">"android"</span>));</span><br><span class="line">        closeSoftKeyboard();</span><br><span class="line">        onView(withId(R.id.et_password)).perform(replaceText(<span class="string">"wrong"</span>));</span><br><span class="line">        closeSoftKeyboard();</span><br><span class="line">        onView(withId(R.id.btn_login)).perform(click());</span><br><span class="line">        onView(withId(R.id.tv_result)).check(matches(withText(<span class="string">"登录失败"</span>)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loginWithRightPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        onView(withId(R.id.et_username)).perform(replaceText(<span class="string">"android"</span>));</span><br><span class="line">        closeSoftKeyboard();</span><br><span class="line">        onView(withId(R.id.et_password)).perform(replaceText(<span class="string">"123456"</span>));</span><br><span class="line">        closeSoftKeyboard();</span><br><span class="line">        onView(withId(R.id.btn_login)).perform(click());</span><br><span class="line">        onView(withId(R.id.tv_result)).check(matches(withText(<span class="string">"登录成功"</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>不是原生输入法，<code>typeText()</code>可能导致输入不完整而测试失败，使用<code>replaceText()</code>立刻填充或换回原生输入法</p></blockquote><p><a href="https://google.github.io/android-testing-support-library/docs/espresso/index.html" target="_blank" rel="noopener">更多用法</a></p><h2 id="压力测试"><a href="#压力测试" class="headerlink" title="压力测试"></a>压力测试</h2><h3 id="Monkey"><a href="#Monkey" class="headerlink" title="Monkey"></a>Monkey</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍了Android应用的常用测试类型&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://lakeshire.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://lakeshire.github.io/tags/Android/"/>
    
      <category term="测试" scheme="http://lakeshire.github.io/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>AndroidStudio——Gradle小贴士</title>
    <link href="http://lakeshire.github.io/2017/02/24//archivers/android-studio-gradle-tips/"/>
    <id>http://lakeshire.github.io/2017/02/24//archivers/android-studio-gradle-tips/</id>
    <published>2017-02-24T06:30:00.000Z</published>
    <updated>2017-11-28T03:13:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>AndroidStudio里使用Gradle的一些小知识</p><a id="more"></a><h2 id="管理工程和资源"><a href="#管理工程和资源" class="headerlink" title="管理工程和资源"></a>管理工程和资源</h2><h3 id="改变默认源集"><a href="#改变默认源集" class="headerlink" title="改变默认源集"></a>改变默认源集</h3><p>修改<code>sourceSets</code>块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    sourceSets &#123;</span><br><span class="line">        main &#123;</span><br><span class="line">          java.srcDirs = [<span class="string">'other/java'</span>]</span><br><span class="line">          res.srcDirs = [<span class="string">'other/res1'</span>, <span class="string">'other/res2'</span>]</span><br><span class="line">          manifest.srcFile <span class="string">'other/AndroidManifest.xml'</span></span><br><span class="line">          ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        androidTest &#123;</span><br><span class="line">          setRoot <span class="string">'src/tests'</span></span><br><span class="line">          ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置工程范围的属性"><a href="#配置工程范围的属性" class="headerlink" title="配置工程范围的属性"></a>配置工程范围的属性</h3><p>在顶级<code>build.gradle</code>中添加<code>ext</code>块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;...&#125;</span><br><span class="line">allprojects &#123;...&#125;</span><br><span class="line"></span><br><span class="line">ext &#123;</span><br><span class="line">    compileSdkVersion = <span class="number">25</span></span><br><span class="line">    buildToolsVersion = <span class="string">"25.0.0"</span></span><br><span class="line">    supportLibVersion = <span class="string">"25.2.0"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>rootProject.ext.property_name</code>访问这些属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    compileSdkVersion rootProject.ext.compileSdkVersion</span><br><span class="line">    buildToolsVersion rootProject.ext.buildToolsVersion</span><br><span class="line">&#125;</span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile <span class="string">"com.android.support:appcompat-v7:$&#123;rootProject.ext.supportLibVersion&#125;"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="管理库和依赖"><a href="#管理库和依赖" class="headerlink" title="管理库和依赖"></a>管理库和依赖</h2><h3 id="使用依赖配置的特定目标构建"><a href="#使用依赖配置的特定目标构建" class="headerlink" title="使用依赖配置的特定目标构建"></a>使用依赖配置的特定目标构建</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">android &#123;...&#125;</span><br><span class="line"></span><br><span class="line">configurations &#123;</span><br><span class="line">  freeDebugApk &#123;&#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    freeCompile <span class="string">'com.google.firebase:firebase-ads:9.8.0'</span></span><br><span class="line">    <span class="function">freeDebugApk <span class="title">fileTree</span><span class="params">(dir: <span class="string">'libs'</span>, include: [<span class="string">'*.jar'</span>])</span></span></span><br><span class="line"><span class="function">    testCompile 'junit:junit:4.12'</span></span><br><span class="line"><span class="function">    androidTestCompile 'com.android.support.test.espresso:espresso-core:2.2.2'</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="发布库的非默认变体"><a href="#发布库的非默认变体" class="headerlink" title="发布库的非默认变体"></a>发布库的非默认变体</h3><p>改变默认构建变体</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    ...</span><br><span class="line">    defaultPublishConfig <span class="string">"demoDebug"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发布所有库的可用构建变体</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    publishNonDefault <span class="keyword">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置应用模块的构建变体，使他们只使用对应的库的构建变体</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">android &#123;...&#125;</span><br><span class="line"></span><br><span class="line">configurations &#123;</span><br><span class="line">    demoDebugCompile &#123;&#125;</span><br><span class="line">    fullReleaseCompile &#123;&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    <span class="function">demoDebugCompile <span class="title">project</span><span class="params">(path: <span class="string">':my-library-module'</span>, configuration: <span class="string">'demoDebug'</span>)</span></span></span><br><span class="line"><span class="function">    fullReleaseCompile <span class="title">project</span><span class="params">(path: <span class="string">':my-library-module'</span>, configuration: <span class="string">'fullRelease'</span>)</span></span></span><br><span class="line"><span class="function">    ...</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="创建应用的不同版本"><a href="#创建应用的不同版本" class="headerlink" title="创建应用的不同版本"></a>创建应用的不同版本</h2><h3 id="配置多APK支持"><a href="#配置多APK支持" class="headerlink" title="配置多APK支持"></a>配置多APK支持</h3><h4 id="配置每个分辨率一个单独APK"><a href="#配置每个分辨率一个单独APK" class="headerlink" title="配置每个分辨率一个单独APK"></a>配置每个分辨率一个单独APK</h4><p>添加<code>android.splits.density</code>块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    ...</span><br><span class="line">    splits &#123;</span><br><span class="line">        density &#123;</span><br><span class="line">            enable <span class="keyword">true</span></span><br><span class="line">            exclude <span class="string">"ldpi"</span>, <span class="string">"mdpi"</span></span><br><span class="line">            <span class="comment">//  清理并包括</span></span><br><span class="line">            <span class="comment">//  reset()</span></span><br><span class="line">            <span class="comment">//  include "hdpi", "xhdpi", "xxhdpi", "xxxhdpi"</span></span><br><span class="line">            compatibleScreens <span class="string">'normal'</span>, <span class="string">'large'</span>, <span class="string">'xlarge'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="配置每个ABI一个单独APK"><a href="#配置每个ABI一个单独APK" class="headerlink" title="配置每个ABI一个单独APK"></a>配置每个ABI一个单独APK</h4><p>添加<code>android.splits.abi</code>块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    ...</span><br><span class="line">    splits &#123;</span><br><span class="line">        abi &#123;</span><br><span class="line">            enable <span class="keyword">true</span></span><br><span class="line">            <span class="comment">//  默认所有ABI都包括，清理</span></span><br><span class="line">            reset()</span><br><span class="line">            include <span class="string">"x86"</span>, <span class="string">"armeabi-v7a"</span>, <span class="string">"mips"</span></span><br><span class="line">            <span class="comment">//  需要生成一个包括所有ABI的APK</span></span><br><span class="line">            universalApk <span class="keyword">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置动态版本号"><a href="#配置动态版本号" class="headerlink" title="配置动态版本号"></a>配置动态版本号</h3><p>默认每个APK都会有同样的版本信息，谷歌商店不支持同一个应用的不同APK有同样的版本信息，你需要确保每个APK有自己独特的<code>versionCode</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        ...</span><br><span class="line">        versionCode <span class="number">4</span></span><br><span class="line">    &#125;</span><br><span class="line">    splits &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Map for the version code that gives each ABI a value.</span></span><br><span class="line">ext.abiCodes = [<span class="string">'armeabi-v7a'</span>:<span class="number">1</span>, mips:<span class="number">2</span>, x86:<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// For per-density APKs, create a similar map like this:</span></span><br><span class="line"><span class="comment">// ext.densityCodes = ['hdpi': 1, 'xhdpi': 2, 'xxhdpi': 3, 'xxxhdpi': 4]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.android.build.OutputFile</span><br><span class="line"></span><br><span class="line"><span class="comment">// For each APK output variant, override versionCode with a combination of</span></span><br><span class="line"><span class="comment">// ext.abiCodes * 1000 + variant.versionCode. In this example, variant.versionCode</span></span><br><span class="line"><span class="comment">// is equal to defaultConfig.versionCode. If you configure product flavors that</span></span><br><span class="line"><span class="comment">// define their own versionCode, variant.versionCode uses that value instead.</span></span><br><span class="line">android.applicationVariants.all &#123; variant -&gt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Assigns a different version code for each output APK</span></span><br><span class="line">    <span class="comment">// other than the universal APK.</span></span><br><span class="line">    variant.outputs.each &#123; output -&gt;</span><br><span class="line">        <span class="comment">// Stores the value of ext.abiCodes that is associated with the ABI for this variant.</span></span><br><span class="line">        <span class="comment">// Determines the ABI for this variant and returns the mapped value.</span></span><br><span class="line">        def baseAbiVersionCode = project.ext.abiCodes.get(output.getFilter(OutputFile.ABI))</span><br><span class="line">        <span class="comment">// Because abiCodes.get() returns null for ABIs that are not mapped by ext.abiCodes,</span></span><br><span class="line">        <span class="comment">// the following code does not override the version code for universal APKs.</span></span><br><span class="line">        <span class="comment">// However, because we want universal APKs to have the lowest version code,</span></span><br><span class="line">        <span class="comment">// this outcome is desirable.</span></span><br><span class="line">        <span class="keyword">if</span> (baseAbiVersionCode != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">// Assigns the new version code to versionCodeOverride, which changes the version code</span></span><br><span class="line">          <span class="comment">// for only the output APK, not for the variant itself. Skipping this step simply</span></span><br><span class="line">          <span class="comment">// causes Gradle to use the value of variant.versionCode for the APK.</span></span><br><span class="line">          output.versionCodeOverride = baseAbiVersionCode * <span class="number">1000</span> + variant.versionCode</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置多个产品风味"><a href="#配置多个产品风味" class="headerlink" title="配置多个产品风味"></a>配置多个产品风味</h3><p>通过<code>flavorDimensions</code>来创建产品风味组，按优先级由高到低排列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    ...</span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        debug &#123;...&#125;</span><br><span class="line">        release &#123;...&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Specifies the flavor dimensions you want to use. The order in which you</span></span><br><span class="line">    <span class="comment">// list each dimension determines its priority, from highest to lowest,</span></span><br><span class="line">    <span class="comment">// when Gradle merges variant sources and configurations. You must assign</span></span><br><span class="line">    <span class="comment">// each product flavor you configure to one of the flavor dimensions.</span></span><br><span class="line">    flavorDimensions <span class="string">"api"</span>, <span class="string">"mode"</span></span><br><span class="line"></span><br><span class="line">    productFlavors &#123;</span><br><span class="line">        demo &#123;</span><br><span class="line">          <span class="comment">// Assigns this product flavor to the "mode" flavor dimension.</span></span><br><span class="line">          dimension <span class="string">"mode"</span></span><br><span class="line">          ...</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        full &#123;</span><br><span class="line">          dimension <span class="string">"mode"</span></span><br><span class="line">          ...</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// Configurations in the "api" product flavors override those in "mode"</span></span><br><span class="line">        <span class="comment">// flavors and the defaultConfig block. Gradle determines the priority</span></span><br><span class="line">        <span class="comment">// between flavor dimensions based on the order in which they appear next</span></span><br><span class="line">        <span class="comment">// to the flavorDimensions property above--the first dimension has a higher</span></span><br><span class="line">        <span class="comment">// priority than the second, and so on.</span></span><br><span class="line">        minApi24 &#123;</span><br><span class="line">          dimension <span class="string">"api"</span></span><br><span class="line">          minSdkVersion <span class="string">'24'</span></span><br><span class="line">          <span class="comment">// To ensure the target device receives the version of the app with</span></span><br><span class="line">          <span class="comment">// the highest compatible API level, assign version codes in increasing</span></span><br><span class="line">          <span class="comment">// value with API level. To learn more about assigning version codes to</span></span><br><span class="line">          <span class="comment">// support app updates and uploading to Google Play, read Multiple APK Support</span></span><br><span class="line">          versionCode <span class="number">30000</span> + android.defaultConfig.versionCode</span><br><span class="line">          versionNameSuffix <span class="string">"-minApi24"</span></span><br><span class="line">          ...</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        minApi23 &#123;</span><br><span class="line">          dimension <span class="string">"api"</span></span><br><span class="line">          minSdkVersion <span class="string">'23'</span></span><br><span class="line">          versionCode <span class="number">20000</span>  + android.defaultConfig.versionCode</span><br><span class="line">          versionNameSuffix <span class="string">"-minApi23"</span></span><br><span class="line">          ...</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        minApi21 &#123;</span><br><span class="line">          dimension <span class="string">"api"</span></span><br><span class="line">          minSdkVersion <span class="string">'21'</span></span><br><span class="line">          versionCode <span class="number">10000</span>  + android.defaultConfig.versionCode</span><br><span class="line">          versionNameSuffix <span class="string">"-minApi21"</span></span><br><span class="line">          ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h3><p>通过<code>variantFilter</code>配置不希望构建的变体</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    ...</span><br><span class="line">    buildTypes &#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    flavorDimensions <span class="string">"api"</span>, <span class="string">"mode"</span></span><br><span class="line">    productFlavors &#123;</span><br><span class="line">        demo &#123;...&#125;</span><br><span class="line">        full &#123;...&#125;</span><br><span class="line">        minApi24 &#123;...&#125;</span><br><span class="line">        minApi23 &#123;...&#125;</span><br><span class="line">        minApi21 &#123;...&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    variantFilter &#123; variant -&gt;</span><br><span class="line">        def names = variant.flavors*.name</span><br><span class="line">        <span class="comment">// To check for a build type instead, use variant.buildType.name == "buildType"</span></span><br><span class="line">        <span class="keyword">if</span> (names.contains(<span class="string">"minApi21"</span>) &amp;&amp; names.contains(<span class="string">"demo"</span>)) &#123;</span><br><span class="line">          <span class="comment">// Gradle ignores any variants that satisfy the conditions above.</span></span><br><span class="line">          setIgnore(<span class="keyword">true</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试应用"><a href="#测试应用" class="headerlink" title="测试应用"></a>测试应用</h2><h3 id="配置Lint"><a href="#配置Lint" class="headerlink" title="配置Lint"></a>配置Lint</h3><p>使用<code>lintOptions</code>配置<code>Lint</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    ...</span><br><span class="line">    lintOptions &#123;</span><br><span class="line">        <span class="comment">// Turns off checks for the issue IDs you specify.</span></span><br><span class="line">        disable <span class="string">'TypographyFractions'</span>,<span class="string">'TypographyQuotes'</span></span><br><span class="line">        <span class="comment">// Turns on checks for the issue IDs you specify. These checks are in</span></span><br><span class="line">        <span class="comment">// addition to the default lint checks.</span></span><br><span class="line">        enable <span class="string">'RtlHardcoded'</span>, <span class="string">'RtlCompat'</span>, <span class="string">'RtlEnabled'</span></span><br><span class="line">        <span class="comment">// To enable checks for only a subset of issue IDs and ignore all others,</span></span><br><span class="line">        <span class="comment">// list the issue IDs with the 'check' property instead. This property overrides</span></span><br><span class="line">        <span class="comment">// any issue IDs you enable or disable using the properties above.</span></span><br><span class="line">        check <span class="string">'NewApi'</span>, <span class="string">'InlinedApi'</span></span><br><span class="line">        <span class="comment">// If set to true, turns off analysis progress reporting by lint.</span></span><br><span class="line">        quiet <span class="keyword">true</span></span><br><span class="line">        <span class="comment">// if set to true (default), stops the build if errors are found.</span></span><br><span class="line">        abortOnError <span class="keyword">false</span></span><br><span class="line">        <span class="comment">// if true, only report errors.</span></span><br><span class="line">        ignoreWarnings <span class="keyword">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="配置测试manifest"><a href="#配置测试manifest" class="headerlink" title="配置测试manifest"></a>配置测试manifest</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Each product flavor you configure can override properties in the</span></span><br><span class="line">    <span class="comment">// defaultConfig block. To learn more, go to Configure Product Flavors.</span></span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// Specifies the application ID for the test APK.</span></span><br><span class="line">        testApplicationId <span class="string">"com.test.foo"</span></span><br><span class="line">        <span class="comment">// Specifies the fully-qualified class name of the test instrumentation runner.</span></span><br><span class="line">        testInstrumentationRunner <span class="string">"android.test.InstrumentationTestRunner"</span></span><br><span class="line">        <span class="comment">// If set to 'true', enables the instrumentation class to start and stop profiling.</span></span><br><span class="line">        <span class="comment">// If set to false (default), profiling occurs the entire time the instrumentation</span></span><br><span class="line">        <span class="comment">// class is running.</span></span><br><span class="line">        testHandleProfiling <span class="keyword">true</span></span><br><span class="line">        <span class="comment">// If set to 'true', indicates that the Android system should run the instrumentation</span></span><br><span class="line">        <span class="comment">// class as a functional test. The default value is 'false'</span></span><br><span class="line">        testFunctionalTest <span class="keyword">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="改变测试构建类型"><a href="#改变测试构建类型" class="headerlink" title="改变测试构建类型"></a>改变测试构建类型</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    ...</span><br><span class="line">    testBuildType <span class="string">"staging"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置Gradle测试选项"><a href="#配置Gradle测试选项" class="headerlink" title="配置Gradle测试选项"></a>配置Gradle测试选项</h3><p>通过<code>testOptions</code>配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Encapsulates options for running tests.</span></span><br><span class="line">    testOptions &#123;</span><br><span class="line">        <span class="comment">// Changes the directory where Gradle saves test reports. By default, Gradle saves test reports</span></span><br><span class="line">        <span class="comment">// in the path_to_your_project/module_name/build/outputs/reports/ directory.</span></span><br><span class="line">        <span class="comment">// '$rootDir' sets the path relative to the root directory of the current project.</span></span><br><span class="line">        reportDir <span class="string">"$rootDir/test-reports"</span></span><br><span class="line">        <span class="comment">// Changes the directory where Gradle saves test results. By default, Gradle saves test results</span></span><br><span class="line">        <span class="comment">// in the path_to_your_project/module_name/build/outputs/test-results/ directory.</span></span><br><span class="line">        <span class="comment">// '$rootDir' sets the path relative to the root directory of the current project.</span></span><br><span class="line">        resultsDir <span class="string">"$rootDir/test-results"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>testOptions.unitTests</code>块仅配置单元测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    ...</span><br><span class="line">    testOptions &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// Encapsulates options for unit tests.</span></span><br><span class="line">        unitTests &#123;</span><br><span class="line">            <span class="comment">// By default, unit tests throw an exception any time the code you are testing tries to access</span></span><br><span class="line">            <span class="comment">// Android platform APIs (unless you mock Android dependencies yourself or with a testing</span></span><br><span class="line">            <span class="comment">// framework like Mockito). However, you can enable the following property so that the test</span></span><br><span class="line">            <span class="comment">// returns either null or zero when accessing platform APIs, rather than throwing an exception.</span></span><br><span class="line">            returnDefaultValues <span class="keyword">true</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// Encapsulates options for controlling how Gradle executes unit tests. For a list</span></span><br><span class="line">            <span class="comment">// of all the options you can specify, read Gradle's reference documentation.</span></span><br><span class="line">            all &#123;</span><br><span class="line">                <span class="comment">// Sets JVM argument(s) for the test JVM(s).</span></span><br><span class="line">                jvmArgs <span class="string">'-XX:MaxPermSize=256m'</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">// You can also check the task name to apply options to only the tests you specify.</span></span><br><span class="line">                <span class="keyword">if</span> (it.name == <span class="string">'testDebug'</span>) &#123;</span><br><span class="line">                  systemProperty <span class="string">'debug'</span>, <span class="string">'true'</span></span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (it.name == <span class="string">'connectedDebugAndroidTest'</span>) &#123;</span><br><span class="line">                  ...</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优化构建"><a href="#优化构建" class="headerlink" title="优化构建"></a>优化构建</h2><h3 id="裁剪代码"><a href="#裁剪代码" class="headerlink" title="裁剪代码"></a>裁剪代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">          minifyEnabled <span class="keyword">true</span></span><br><span class="line">          <span class="function">proguardFiles <span class="title">getDefaultProguardFile</span><span class="params">(<span class="string">'proguard-android-optimize.txt'</span>)</span>, 'proguard-rules.pro'</span></span><br><span class="line"><span class="function">        &#125;</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function">    ...</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p>为不同的构建提供裁剪的`proguar</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    ...</span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">          minifyEnabled <span class="keyword">true</span></span><br><span class="line">          <span class="function">proguardFiles <span class="title">getDefaultProguardFile</span><span class="params">(<span class="string">'proguard-android.txt'</span>)</span>, 'proguard-rules.pro'</span></span><br><span class="line"><span class="function">        &#125;</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function">    productFlavors </span>&#123;</span><br><span class="line">        flavor1 &#123;</span><br><span class="line">          ...</span><br><span class="line">        &#125;</span><br><span class="line">        flavor2 &#123;</span><br><span class="line">          proguardFile <span class="string">'flavor2-rules.pro'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置DEX"><a href="#配置DEX" class="headerlink" title="配置DEX"></a>配置DEX</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    ...</span><br><span class="line">    dexOptions &#123;</span><br><span class="line">        <span class="comment">// Sets the maximum number of DEX processes</span></span><br><span class="line">        <span class="comment">// that can be started concurrently.</span></span><br><span class="line">        maxProcessCount <span class="number">8</span></span><br><span class="line">        <span class="comment">// Sets the maximum memory allocation pool size</span></span><br><span class="line">        <span class="comment">// for the dex operation.</span></span><br><span class="line">        javaMaxHeapSize <span class="string">"2g"</span></span><br><span class="line">        <span class="comment">// Enables Gradle to pre-dex library dependencies.</span></span><br><span class="line">        preDexLibraries <span class="keyword">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="发布应用"><a href="#发布应用" class="headerlink" title="发布应用"></a>发布应用</h2><h3 id="签名"><a href="#签名" class="headerlink" title="签名"></a>签名</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    ...</span><br><span class="line">    defaultConfig &#123; ... &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Encapsulates signing configurations.</span></span><br><span class="line">    signingConfigs &#123;</span><br><span class="line">        <span class="comment">// Creates a signing configuration called "release".</span></span><br><span class="line">        release &#123;</span><br><span class="line">            <span class="comment">// Specifies the path to your keystore file.</span></span><br><span class="line">            <span class="function">storeFile <span class="title">file</span><span class="params">(<span class="string">"my-release-key.jks"</span>)</span></span></span><br><span class="line"><span class="function">            <span class="comment">// Specifies the password for your keystore.</span></span></span><br><span class="line"><span class="function">            storePassword "password"</span></span><br><span class="line"><span class="function">            <span class="comment">// Specifies the identifying name for your key.</span></span></span><br><span class="line"><span class="function">            keyAlias "my-alias"</span></span><br><span class="line"><span class="function">            <span class="comment">// Specifies the password for your key.</span></span></span><br><span class="line"><span class="function">            keyPassword "password"</span></span><br><span class="line"><span class="function">        &#125;</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function">    buildTypes </span>&#123;</span><br><span class="line">        release &#123;</span><br><span class="line">          <span class="comment">// Adds the "release" signing configuration to the release build type.</span></span><br><span class="line">          signingConfig signingConfigs.release</span><br><span class="line">          ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="从工程中移除私人签名信息"><a href="#从工程中移除私人签名信息" class="headerlink" title="从工程中移除私人签名信息"></a>从工程中移除私人签名信息</h3><ol><li>创建<code>keystore.properties</code>目录</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">storePassword=[myStorePassword]</span><br><span class="line">keyPassword=[myKeyPassword]</span><br><span class="line">keyAlias=[myKeyAlias]</span><br><span class="line">storeFile=[myStoreFileLocation]</span><br></pre></td></tr></table></figure><ol><li>在<code>build.gradle</code>中加载<code>keystore.properties</code>文件</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Creates a variable called keystorePropertiesFile, and initializes it to the</span></span><br><span class="line"><span class="comment">// keystore.properties file.</span></span><br><span class="line">def keystorePropertiesFile = rootProject.file(<span class="string">"keystore.properties"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initializes a new Properties() object called keystoreProperties.</span></span><br><span class="line">def keystoreProperties = <span class="keyword">new</span> Properties()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Loads the keystore.properties file into the keystoreProperties object.</span></span><br><span class="line">keystoreProperties.load(<span class="keyword">new</span> FileInputStream(keystorePropertiesFile))</span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">    signingConfigs &#123;</span><br><span class="line">        config &#123;</span><br><span class="line">          keyAlias keystoreProperties[<span class="string">'keyAlias'</span>]</span><br><span class="line">          keyPassword keystoreProperties[<span class="string">'keyPassword'</span>]</span><br><span class="line">          <span class="function">storeFile <span class="title">file</span><span class="params">(keystoreProperties[<span class="string">'storeFile'</span>])</span></span></span><br><span class="line"><span class="function">          storePassword keystoreProperties['storePassword']</span></span><br><span class="line"><span class="function">        &#125;</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function">    ...</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="简化应用开发"><a href="#简化应用开发" class="headerlink" title="简化应用开发"></a>简化应用开发</h2><h3 id="与代码共享自定义域和资源值"><a href="#与代码共享自定义域和资源值" class="headerlink" title="与代码共享自定义域和资源值"></a>与代码共享自定义域和资源值</h3><p>编译时，生成<code>BuildConfig</code>类，所以代码可以获得当前构建的信息，可以在<code>buildConfigField()</code>方法中添加自定义域，在运行时访问，也可以通过<code>resValue()</code>添加资源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    ...</span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            <span class="comment">// These values are defined only for the release build, which</span></span><br><span class="line">            <span class="comment">// is typically used for full builds and continuous builds.</span></span><br><span class="line">            buildConfigField(<span class="string">"String"</span>, <span class="string">"BUILD_TIME"</span>, <span class="string">"\"$&#123;minutesSinceEpoch&#125;\""</span>)</span><br><span class="line">            resValue(<span class="string">"string"</span>, <span class="string">"build_time"</span>, <span class="string">"$&#123;minutesSinceEpoch&#125;"</span>)</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        debug &#123;</span><br><span class="line">            <span class="comment">// Use static values for incremental builds to ensure that</span></span><br><span class="line">            <span class="comment">// resource files and BuildConfig aren't rebuilt with each run.</span></span><br><span class="line">            <span class="comment">// If they were dynamic, they would prevent certain benefits of</span></span><br><span class="line">            <span class="comment">// Instant Run as well as Gradle UP-TO-DATE checks.</span></span><br><span class="line">            buildConfigField(<span class="string">"String"</span>, <span class="string">"BUILD_TIME"</span>, <span class="string">"\"0\""</span>)</span><br><span class="line">            resValue(<span class="string">"string"</span>, <span class="string">"build_time"</span>, <span class="string">"0"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以这样访问他们</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Log.i(TAG, BuildConfig.BUILD_TIME);</span><br><span class="line">Log.i(TAG, getString(R.string.build_time));</span><br></pre></td></tr></table></figure><h3 id="与Manifest共享属性"><a href="#与Manifest共享属性" class="headerlink" title="与Manifest共享属性"></a>与Manifest共享属性</h3><p>有时需要在代码和Manifest中声明同样的属性值，在<code>build.gradle</code>中定义一份多处使用最好</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    <span class="comment">// For settings specific to a product flavor, configure these properties</span></span><br><span class="line">    <span class="comment">// for each flavor in the productFlavors block.</span></span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        <span class="comment">// Creates a property for the FileProvider authority.</span></span><br><span class="line">        def filesAuthorityValue = applicationId + <span class="string">".files"</span></span><br><span class="line">        <span class="comment">// Creates a placeholder property to use in the manifest.</span></span><br><span class="line">        manifestPlaceholders =  [filesAuthority : filesAuthorityValue]</span><br><span class="line">        <span class="comment">// Adds a new field for the authority to the BuildConfig class.</span></span><br><span class="line">        buildConfigField(<span class="string">"String"</span>, <span class="string">"FILES_AUTHORITY"</span>, <span class="string">"\"$&#123;filesAuthorityValue&#125;\""</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Manifest中使用</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;manifest&gt;</span><br><span class="line">    ...</span><br><span class="line">    &lt;application&gt;</span><br><span class="line">        ...</span><br><span class="line">        &lt;provider</span><br><span class="line">          android:name=<span class="string">"android.support.v4.content.FileProvider"</span></span><br><span class="line">          android:authorities=<span class="string">"$&#123;filesAuthority&#125;"</span></span><br><span class="line">          android:exported=<span class="string">"false"</span></span><br><span class="line">          android:grantUriPermissions=<span class="string">"true"</span>&gt;</span><br><span class="line">          ...</span><br><span class="line">        &lt;/provider&gt;</span><br><span class="line">    &lt;/application&gt;</span><br><span class="line">&lt;/manifest&gt;</span><br></pre></td></tr></table></figure><p>代码中使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Uri contentUri = FileProvider.getUriForFile(getContext(), BuildConfig.FILES_AUTHORITY, myFile);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;AndroidStudio里使用Gradle的一些小知识&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://lakeshire.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://lakeshire.github.io/tags/Android/"/>
    
      <category term="Gradle" scheme="http://lakeshire.github.io/tags/Gradle/"/>
    
  </entry>
  
  <entry>
    <title>AndroidWear开发心得</title>
    <link href="http://lakeshire.github.io/2016/12/29//archivers/android-wear/"/>
    <id>http://lakeshire.github.io/2016/12/29//archivers/android-wear/</id>
    <published>2016-12-29T09:00:00.000Z</published>
    <updated>2017-11-28T03:15:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>Android Wear开发的踩坑史……</p><a id="more"></a><h2 id="AndroidWear开发"><a href="#AndroidWear开发" class="headerlink" title="AndroidWear开发"></a>AndroidWear开发</h2><p>需要SDKTools 23.0.0以上以及<code>API20</code>以上的SDK</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>下载AndroidWear手机应用，最好是国际版，我用的华为手表，开机之后会有引导，可以扫描二维码下载对应的国际版AndroidWear，然后扫描设备，配对，同步一段时间，手表就能开始运行了</p><blockquote><p>后来把手表刷到2.0做开发，这个AndroidWear就连不上了，要使用Google的开发者预览版</p></blockquote><p>在手表上开启开发者选项，就是在<code>设置</code>-&gt;<code>关于</code>里面，点击版本号七次，然后在开发者选项里面开启<code>ADB调试</code>，同时也开一下<code>通过蓝牙调试</code></p><p>进入手机的AndroidWear应用，右上角的<code>设置</code>里面，开启<code>通过蓝牙调试</code>,有两个连接，<code>主机</code>是电脑与手机的连接，<code>目标</code>是手机与手表的连接，在电脑的命令行输入命令进行连接，手表上确认后就可以调试了</p><pre><code>adbforward tcp:4444 localabstract:/adb-hubadb connect localhost:4444</code></pre><blockquote><p>有时候下面那条命令连不上，把<code>localhost</code>换成<code>127.0.0.1</code>试试</p></blockquote><h2 id="创建工程"><a href="#创建工程" class="headerlink" title="创建工程"></a>创建工程</h2><p>创建工程跟一般的Android工程差不多，注意除了<code>Phone and Tablet</code>之外多选一个<code>Wear</code>，这样你的工程就包含<code>mobile</code>和<code>wear</code>两个模块了，后者就是手表端的代码</p><p>很多代码都通用，理论上把手机端的应用直接装手表上也能跑起来，但是界面就不能看了，所以还是需要遵守一下手表端的交互规范，但是这东西很新而且一直也在更新，很多东西说过时就过时，也是不用太纠结</p><h3 id="GridViewPager"><a href="#GridViewPager" class="headerlink" title="GridViewPager"></a>GridViewPager</h3><p>多页的展示我用了这个，类似<code>ViewPager</code>，但是它是<code>2D</code>的更强大一点，然而我也没用到这个特性，配合<code>DotsPageIndicator</code>做指示器</p><p>三个页面，我希望初始显示第2页，那么就要用到<code>setCurrentItem(0,1)</code>，但是没有效果，后来发现手表毕竟性能比较弱，可能是还没初始化完这个<code>GridViewPager</code>就进行设置导致无效，所以用了这段代码就好了</p><pre><code>Runnable dirtyHack  = new Runnable() {    @Override    public void run() {        pager.setCurrentItem(0, 1);    }};</code></pre><h3 id="WearableListView"><a href="#WearableListView" class="headerlink" title="WearableListView"></a>WearableListView</h3><p>用于列表展示，然而并不是<code>ListView</code>的子类，而是<code>RecyclerView</code>的子类，这个类在<code>2.0</code>就废了</p><h4 id="显示列表头"><a href="#显示列表头" class="headerlink" title="显示列表头"></a>显示列表头</h4><p>跟手机上的列表显示不同，手表上会自己做处理，把列表的第一项显示在屏幕中心，体验会好一点，上面还有一半的空白还专门有个函数<code>onTopEmptyRegionClick()</code>来处理这里的点击，但是我没找到有方法可以获得这个区域，往里面填充点我想要的列表头什么的，又没有<code>ListView</code>的比较方便的<code>addHeaderView()</code>的方法，<code>RecyclerView</code>根据项类型不同改变布局的话，有需要自己调整列表的偏移，总体来说这个需求就比较恶心，我就直接用了几层布局，反正列表初始显示时上方是露出的，滑动时覆盖掉也是可以达到预期</p><h4 id="下拉刷新"><a href="#下拉刷新" class="headerlink" title="下拉刷新"></a>下拉刷新</h4><p>使用了<code>SwipeRefreshLayout</code>，试了其他的没成功，然后这个库好像刷新头就是那个旋转尖头，还能设置多种颜色挨着变，可定制性就不太高，不过对手表这种轻量的场合也就够了</p><h4 id="加载更多"><a href="#加载更多" class="headerlink" title="加载更多"></a>加载更多</h4><p>没有找到实现方法，按照网上流行的<code>RecyclerView</code>加载更多的实现方法，需要用到某个<code>LayoutManager</code>，<code>WearableListView</code>里面继承了这个并且设置为了<code>private</code>，导致那个判定某项是否是最后一项的方法调不到，不想多折腾，在列表里面加入一个判断项，用来显示<code>加载更多</code>好了</p><h4 id="列表项显示效果"><a href="#列表项显示效果" class="headerlink" title="列表项显示效果"></a>列表项显示效果</h4><p>圆形表盘引入的问题，一页显示三项，中间项较大，这样视觉效果会比较好，为此可以自定义一个布局，实现<code>WearableListView.OnCenterProximityListener</code>这个接口，在<code>onCenterPosition()</code>和<code>onNonCenterPosition()</code>两个函数里面做一下缩放的动画，类似冒泡的效果</p><blockquote><p>最初会有列表无法滑动的问题，可能是跟<code>GridViewPager</code>冲突了，用这句代码解决<code>listView.setGreedyTouchMode(true)</code>，也是很无语</p></blockquote><h3 id="WearableRecyclerView"><a href="#WearableRecyclerView" class="headerlink" title="WearableRecyclerView"></a>WearableRecyclerView</h3><p><code>2.0</code>推荐使用的列表，它可以显示一个弧状的列表，好处是可以显示更多的内容</p><h3 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h3><p><code>2.0</code>以前的手表一般是依赖手机工作的，因为其自身不支持网络，所有的数据都从手机获得，所以数据传输方面的API特别重要，也很坑</p><p>方法和类本身很简单，先连接到<code>GoogleApiClient</code>，注册<code>DataApi</code>和<code>MessageApi</code>的监听，就可以收发消息，也可以同步数据（相当于两端公用一个数据结构，一方的改动会推送到另一方）</p><p>但是，它是基于<code>GooglePlayService</code>的，在国内基本处于不可用状态，华为官网提供了一个可用的版本，应该是做过处理了，然而能不能通信还是有很多坑点</p><ol><li><code>wear</code>和<code>mobile</code>用的库版本需要是一样的</li><li>调试版本一般是可以通信的，发布版本有一定的要求</li><li>蓝牙要保持连接，<code>AndroidWear</code>也要保持运行</li><li>可以在没有<code>GooglePlayServiceFramework</code>的手机上工作（可能是华为的库做过处理）</li></ol><h2 id="打包发布"><a href="#打包发布" class="headerlink" title="打包发布"></a>打包发布</h2><p><code>2.0</code>以前<code>wear</code>的apk是附在<code>mobile</code>里面的，手机安装时推送到手表端，两种打包方式</p><h3 id="自动打包"><a href="#自动打包" class="headerlink" title="自动打包"></a>自动打包</h3><p><code>mobile</code>的<code>build.gradle</code>里加入</p><pre><code>dependencies {    wearApp project(&apos;:wear&apos;)}</code></pre><p>那个<code>:wear</code>就是手表的工程，然后<code>Build</code>-&gt;<code>Generate Signed APK</code>，这样的话就同时签名了</p><h3 id="手动打包"><a href="#手动打包" class="headerlink" title="手动打包"></a>手动打包</h3><p><code>mobile</code>的<code>AndroidMenifest.xml</code>要包含<code>wear</code>的全部权限</p><p>确保两个工程有同样的包名和版本号（可能都是不需要的，因为接下来需要提供一个描述文件，里面都有指定，没验证过）</p><p>把正式版<code>wear</code>的apk拷贝到<code>res/raw</code>目录，假设命名为<code>wearable_app.apk</code></p><p>创建<code>res/xml/wearable_app_desc.xml</code>文件</p><pre><code>&lt;wearableApp package=&quot;[包名]&quot;    &lt;versionCode&gt;1&lt;/versionCode&gt;     &lt;versionName&gt;1.0&lt;/versionName&gt;     &lt;rawPathResId&gt;wearable_app&lt;/rawPathResId&gt;&lt;/wearableApp&gt;</code></pre><p>在<code>mobile</code>的<code>AndroidMenifest.xml</code>里的<code>&lt;application&gt;</code>标签里添加</p><pre><code>&lt;meta-data android:name=&quot;com.google.android.wearable.beta.app&quot; android:resource=&quot;@xml/wearable_app_desc&quot; /&gt;</code></pre><p>构建正式版<code>mobile</code>应用</p><p><code>2.0</code>就可以独立安装手表的apk了，我的最终配置是下面这样然后能够工作（主要指通信部分）：</p><ol><li>两边的包名相同</li><li>两边的版本号不同</li><li><code>mobile</code>并没有做手动打包的3／4／5步</li></ol><h3 id="杂七杂八的配置"><a href="#杂七杂八的配置" class="headerlink" title="杂七杂八的配置"></a>杂七杂八的配置</h3><p>做的过程并没有记得很清楚，所以一些配置可能并不是必要的，但是如果遇到奇怪的无法通信的错误可以试试</p><p><code>AndroidMenifest.xml</code>中加入手表的特性</p><p>手机端</p><pre><code>&lt;uses-feature android:name=&quot;android.hardware.type.watch&quot; android:required=&quot;false&quot; /&gt;</code></pre><p>手表端</p><pre><code>&lt;uses-feature android:name=&quot;android.hardware.type.watch&quot; /&gt;</code></pre><p>可能<code>wear</code>编译缺少库时，在<code>&lt;appliaction&gt;</code>标签下加入</p><pre><code>&lt;uses-library android:name=&quot;com.google.android.wearable&quot; android:required=&quot;false&quot; /&gt;</code></pre><p>华为提供的库是个<code>aar</code>，需要在<code>build.gradle</code>中加入支持</p><pre><code>android {    ......    repositories {        flatDir {            dirs : &apos;libs&apos;        }    }    ......    }dependencies {    ......    compile(name : &apos;play-services-7.8.87&apos;, ext : &apos;aar&apos;)    ......}</code></pre><h2 id="刷机升级到2-0"><a href="#刷机升级到2-0" class="headerlink" title="刷机升级到2.0"></a>刷机升级到<code>2.0</code></h2><ol><li>进入开发者模式，打开<code>ADB调试</code></li><li><code>adb devices</code>可以看到设备，看不到是连接问题，也可能是驱动问题，用MAC吧，我的就是连不上Windows</li><li><code>adb reboot bootloader</code>进入BootLoader</li><li><code>fastboot oem unlock</code>解锁</li><li>在官网下载正确的镜像（华为的国内版镜像在最下面，请仔细）</li><li>解压，执行命令<code>flash-all.sh</code>，等待镜像刷好，重启就好了</li></ol><blockquote><p>关于第4步，我在集成友盟统计的时候，需要访问<code>/data</code>文件夹，但是一直提示没有权限，后来“奇迹般”的又好了，期间可能的操作就是我又进行了锁定操作<code>fastboot oem lock</code>，没有进一步验证过<br>刷机后，应用市场上的AndroidWear软件可能会在于手表端数据传输时出问题，应该用官网上提供的预览版软件</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Android Wear开发的踩坑史……&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://lakeshire.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://lakeshire.github.io/tags/Android/"/>
    
      <category term="Wear" scheme="http://lakeshire.github.io/tags/Wear/"/>
    
  </entry>
  
  <entry>
    <title>Android布局优化</title>
    <link href="http://lakeshire.github.io/2016/11/15//archivers/layout-optimize/"/>
    <id>http://lakeshire.github.io/2016/11/15//archivers/layout-optimize/</id>
    <published>2016-11-15T09:00:00.000Z</published>
    <updated>2017-11-28T03:03:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>收集一些布局优化技巧，持续更新……</p><a id="more"></a><h3 id="include标签"><a href="#include标签" class="headerlink" title="include标签"></a>include标签</h3><p>可以复用布局，统一修改管理，典型的比如标题栏，也可以在<code>&lt;include&gt;</code>标签中重新设置<code>layout</code>属性</p><h3 id="merge标签"><a href="#merge标签" class="headerlink" title="merge标签"></a>merge标签</h3><p>用来去除不必要的视图层级</p><p>如果仅仅是添加子视图到父视图进行显示，而不指定任何针对父视图的布局属性，可以使用</p><p>另外，假如需要在<code>LinearLayout</code>里面嵌入一个布局，而恰恰这个布局的根节点也是<code>LinearLayout</code>，这样就多了一层没有用的嵌套，无疑这样只会拖慢程序速度，也需要使用</p><p><code>&lt;merge&gt;</code>标签只能作为<code>xml</code>的根元素</p><h3 id="TextView同时显示文字与图片"><a href="#TextView同时显示文字与图片" class="headerlink" title="TextView同时显示文字与图片"></a>TextView同时显示文字与图片</h3><p>一般是一个<code>ImageView</code>加一个<code>TextView</code>，其实可以用<code>TextView</code>直接搞定</p><pre><code>public void setCompoundDrawables(@Nullable Drawable left, @Nullable Drawable top, @Nullable Drawable right, @Nullable Drawable bottom);</code></pre><p>设置四个方向的<code>drawable</code></p><pre><code>public void setCompoundDrawablePadding(int pad);</code></pre><p>设置图片和文字的距离</p><h3 id="利用TextView的行间距"><a href="#利用TextView的行间距" class="headerlink" title="利用TextView的行间距"></a>利用TextView的行间距</h3><p><code>android:lineSpaceingExtra</code>属性可以改变行间距，还有<code>android:lineSpacingMultiplier</code>设定行距倍数</p><p>遇到多行文本，行间有一定距离的场景，就不需要多个<code>TextView</code>了</p><h3 id="一个TextView中不同的样式"><a href="#一个TextView中不同的样式" class="headerlink" title="一个TextView中不同的样式"></a>一个TextView中不同的样式</h3><p>如果一段文字中有多种样式，一般就是分成几个<code>TextView</code>去做</p><p>但是也可以通过<code>Spannable</code>或<code>Html.fromHtml()</code>实现</p><pre><code>String text;SpannableStringBuilder style = new SpannableStringBuilder(text);</code></pre><p><code>SpannableStringBuilder.setSpan()</code></p><pre><code>public void setSpan(Object what, int start, int end, int flags);</code></pre><p>设置的东西都是<code>CharacterStyle</code>的子类，比如<code>AbsoluteSizeSpan</code>定义字体大小，<code>ForegroundColorSpan</code>定义字体颜色等等</p><p><code>CharacterStyle</code></p><ul><li><code>ForegroundColorSpan</code></li><li><code>MaskFilterSpan</code></li><li><code>SuggestionSpan</code></li><li><code>RasterizerSpan</code></li><li><code>BackgroundColorSpan</code></li><li><code>StrikethroughSpan</code></li><li><code>UnderlineSpan</code></li><li><code>ClickableSpan</code><ul><li><code>URLSpan</code></li></ul></li><li><code>MetricAffectingSpan</code><ul><li><code>SubscriptSpan</code></li><li><code>StyleSpan</code></li><li><code>AbsoluteSizeSpan</code></li><li><code>RelativeSizeSpan</code></li><li><code>TextAppearanceSpan</code></li><li><code>SuperscriptSpan</code></li><li><code>LocaleSpan</code></li><li><code>ScaleXSpan</code></li><li><code>TypefaceSpan</code></li><li><code>ReplacementSpan</code><ul><li><code>DynamicDrawableSpan</code></li></ul></li></ul></li></ul><p>最后设置给<code>TextView</code></p><pre><code>mTextView.setText(style);</code></pre><h3 id="ViewStub"><a href="#ViewStub" class="headerlink" title="ViewStub"></a>ViewStub</h3><p><code>ViewStub</code>是个轻量级的<code>View</code>，不占用布局位置，可以实现按需加载，比如网络请求失败的提示页面</p><p>一旦<code>ViewStub</code>可见或是被<code>inflate()</code>了，它就不存在了，被获得的<code>View</code>取代</p><h3 id="LinearLayout的分割线"><a href="#LinearLayout的分割线" class="headerlink" title="LinearLayout的分割线"></a>LinearLayout的分割线</h3><p>比如两个按钮之间的一道分割线，一般都是用一个<code>View</code>，也可以直接使用<code>LinearLayout</code>的<code>android:divider</code>属性，<code>android:showDividers</code>可以设置显示位置，<code>android:dividerPadding</code>可以设置内边距</p><h3 id="Space"><a href="#Space" class="headerlink" title="Space"></a>Space</h3><p>要为布局间添加间距，可以通过添加一个空的<code>View</code>，也可以通过设置<code>margin</code>，但前者影响性能，后者影响可读性，这时可以使用<code>Space</code>，它也很轻量</p><h3 id="移除不必要的背景"><a href="#移除不必要的背景" class="headerlink" title="移除不必要的背景"></a>移除不必要的背景</h3><p>过多的背景叠加会导致过度绘制，会影响性能</p><blockquote><p>假设我们的<code>Activity</code>背景是白色，<code>Activity</code>的布局最终会加入<code>DecorView</code>中，那么这个<code>View</code>中的背景就没必要了，通过下面的代码</p><pre><code>getWindow().setBackgroundDrawable(null);</code></pre></blockquote><h3 id="使用TextSwitcher和ImageSwitcher平滑过渡"><a href="#使用TextSwitcher和ImageSwitcher平滑过渡" class="headerlink" title="使用TextSwitcher和ImageSwitcher平滑过渡"></a>使用TextSwitcher和ImageSwitcher平滑过渡</h3><p>很多时候文字改变的时候希望不那么突兀，平滑一点，可以使用这些类</p><p>使用<code>TextSwitcher</code></p><ol><li>获得<code>TextSwitcher</code>对象</li><li>通过<code>setFactory()</code>设置<code>ViewFactory</code>，实现<code>makeView()</code>方法，返回实际的<code>TextView</code></li><li>通过<code>setInAnimation()</code>设置换入动画</li><li>通过<code>setOutAnimation()</code>设置换出动画</li></ol><p><code>ImageSwitcher</code>也是同样的用法</p><p>这两个控件的目的是使过度更自然，代码更易读，因此不要滥用它们</p><h3 id="在onCreate中获得视图的宽高"><a href="#在onCreate中获得视图的宽高" class="headerlink" title="在onCreate中获得视图的宽高"></a>在onCreate中获得视图的宽高</h3><p>在<code>onCreate()</code>中调用<code>getWidth()</code>和<code>getHeight()</code>获得的都是0，可以使用<code>post()</code>方法</p><pre><code>view.post(new Runnable() {    @Override    public void run() {        int height = view.getHeight();        int width = view.getWidth();    }});</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;收集一些布局优化技巧，持续更新……&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://lakeshire.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://lakeshire.github.io/tags/Android/"/>
    
      <category term="性能优化" scheme="http://lakeshire.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>AsyncTask源码初步分析</title>
    <link href="http://lakeshire.github.io/2016/11/15//archivers/asynctask/"/>
    <id>http://lakeshire.github.io/2016/11/15//archivers/asynctask/</id>
    <published>2016-11-15T04:00:00.000Z</published>
    <updated>2017-11-28T03:04:18.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>AsyncTask</code>源码看似比较独立和简单，分析一下</p><a id="more"></a><h2 id="AsyncTask"><a href="#AsyncTask" class="headerlink" title="AsyncTask"></a>AsyncTask</h2><pre><code>public AsyncTask() {    mWorker = new WorkerRunnable&lt;Params, Result&gt;() {        public Result call() throws Exception {            mTaskInvoked.set(true);            Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);            //  这里调用后台运行            Result result = doInBackground(mParams);            Binder.flushPendingCommands();            //  发送结果            return postResult(result);        }    };    mFuture = new FutureTask&lt;Result&gt;(mWorker) {        @Override        protected void done() {            try {                postResultIfNotInvoked(get());            } catch (InterruptedException e) {                android.util.Log.w(LOG_TAG, e);            } catch (ExecutionException e) {                throw new RuntimeException(&quot;An error occurred while executing doInBackground()&quot;,                        e.getCause());            } catch (CancellationException e) {                postResultIfNotInvoked(null);            }        }    };}</code></pre><p>构造函数，分别构造了一个<code>WorkerRunnable</code>和一个<code>FutureTask</code><br><code>WorkerRunnable</code>就是任务，里面保存了<code>Params</code>，在执行结束后返回<code>Result</code><br><code>FutureTask</code>包装了一下任务，实际调度的是它，它会运行那个<code>WorkerRunnable</code>，得到返回结果在<code>done()</code>中处理</p><pre><code>private static abstract class WorkerRunnable&lt;Params, Result&gt; implements Callable&lt;Result&gt; {        Params[] mParams;}</code></pre><h3 id="线程相关接口和类"><a href="#线程相关接口和类" class="headerlink" title="线程相关接口和类"></a>线程相关接口和类</h3><p><img src="http://7xt3ho.com1.z0.glb.clouddn.com/Runnable.jpg" alt=""></p><pre><code>//  可被执行的命令，不返回结果public interface Runnable {    public void run();}//  一个任务，能够返回结果，可能抛出异常public interface Callable&lt;V&gt; {    V call() throws Exception;}//  Future代表了一个异步任务的结果//  有方法检查任务是否完成、等待完成、获得任务结果//  结果只能当任务完成时通过get()获得，必要的话会阻塞直到就绪public interface Future&lt;V&gt; {    boolean cancel(boolean mayInterruptIfRunning);    boolean isCancelled();    boolean isDone();    V get() throws InterruptedException, ExecutionException;    V get(long timeout, TimeUnit unit)        throws InterruptedException, ExecutionException, TimeoutException;}//  一个可运行的Future//  run()的成功执行导致Future的完成，并且允许访问其结果public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt; {    void run();}//  一个可取消的异步任务//  可以用来包裹Runnable或Callable//  因为实现了Runnable，所以可以提交给一个Executor处理//  可以开始和结束任务，查看任务结果public class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt; {    public FutureTask(Callable&lt;V&gt; callable) {        ......    }    public FutureTask(Runnable runnable, V result) {        ......    }    ......}</code></pre><h3 id="工作流"><a href="#工作流" class="headerlink" title="工作流"></a>工作流</h3><p>通过<code>execute()</code>执行，返回任务的引用，调用者可以保持引用</p><pre><code>@MainThreadpublic final AsyncTask&lt;Params, Progress, Result&gt; execute(Params... params) {    return executeOnExecutor(sDefaultExecutor, params);}@MainThreadpublic final AsyncTask&lt;Params, Progress, Result&gt; executeOnExecutor(Executor exec, Params... params) {    if (mStatus != Status.PENDING) {        switch (mStatus) {            case RUNNING:                //  不能执行正在执行的任务                throw new IllegalStateException(&quot;Cannot execute task:&quot; + &quot; the task is already running.&quot;);            case FINISHED:                //  不能执行完成的任务                throw new IllegalStateException(&quot;Cannot execute task:&quot; + &quot; the task has already been executed &quot; + &quot;(a task can be executed only once)&quot;);        }    }    mStatus = Status.RUNNING;    //  准备执行，重写的方法    onPreExecute();    mWorker.mParams = params;    //  线程池执行    exec.execute(mFuture);    return this;}     </code></pre><p>线程池执行任务，<code>FutureTask.run()</code></p><pre><code>public void run() {    if (state != NEW || !U.compareAndSwapObject(this, RUNNER, null, Thread.currentThread()))        return;    try {        Callable&lt;V&gt; c = callable;        if (c != null &amp;&amp; state == NEW) {            V result;            boolean ran;            try {                //  执行                result = c.call();                ran = true;            } catch (Throwable ex) {                result = null;                ran = false;                setException(ex);            }            if (ran)                //  设置结果                set(result);        }    } finally {        runner = null;        int s = state;        if (s &gt;= INTERRUPTING)            handlePossibleCancellationInterrupt(s);    }}protected void set(V v) {    if (U.compareAndSwapInt(this, STATE, NEW, COMPLETING)) {        outcome = v;        U.putOrderedInt(this, STATE, NORMAL);        finishCompletion();    }}private void finishCompletion() {    for (WaitNode q; (q = waiters) != null;) {        if (U.compareAndSwapObject(this, WAITERS, q, null)) {            for (;;) {                Thread t = q.thread;                if (t != null) {                    q.thread = null;                    LockSupport.unpark(t);                }                WaitNode next = q.next;                if (next == null)                    break;                q.next = null;                q = next;            }            break;        }    }    //  这个done()就是匿名类中重写的方法，表示完成后的处理    done();    callable = null;}</code></pre><p>完成后会调用这个，发消息从后台执行前台动作</p><pre><code>private Result postResult(Result result) {    @SuppressWarnings(&quot;unchecked&quot;)    Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT, new AsyncTaskResult&lt;Result&gt;(this, result));    message.sendToTarget();    return result;}</code></pre><p>那么一定有消息处理器</p><pre><code>private static class InternalHandler extends Handler {    public InternalHandler() {        super(Looper.getMainLooper());    }    @SuppressWarnings({&quot;unchecked&quot;, &quot;RawUseOfParameterizedType&quot;})    @Override    public void handleMessage(Message msg) {        AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj;        switch (msg.what) {            case MESSAGE_POST_RESULT:                result.mTask.finish(result.mData[0]);                break;            case MESSAGE_POST_PROGRESS:                result.mTask.onProgressUpdate(result.mData);                break;        }    }}private void finish(Result result) {    if (isCancelled()) {        //  取消        onCancelled(result);    } else {        //  执行结束        onPostExecute(result);    }    mStatus = Status.FINISHED;}</code></pre><h3 id="线程注解"><a href="#线程注解" class="headerlink" title="线程注解"></a>线程注解</h3><p>如果你的方法只能在指定的线程类型中被调用，那么你就可以使用以下4个注解来标注它：</p><ul><li><code>@UiThread</code></li><li><code>@MainThread</code></li><li><code>@WorkerThread</code></li><li><code>@BinderThread</code></li></ul><p>如果一个类中的所有方法都有相同的线程需求，那么你可以注解类本身。比如<code>android.view.View</code>，就被用<code>@UiThread</code>标注。</p><p>关于线程注解使用的一个很好的例子就是<code>AsyncTask</code>：</p><p>如果你在重写的<code>doInBackground()</code>方法里尝试调用<code>onProgressUpdate()</code>方法或者<code>View</code>的任何方法，就会马上把它标记为一个错误</p><blockquote><p><code>@UiThread</code>还是<code>@MainThread</code>?<br>在进程里只有一个主线程。这个就是<code>@MainThread</code>。同时这个线程也是一个<code>@UiThread</code>。比如<code>Activity</code>的主要窗口就运行在这个线程上。然而它也有能力为应用创建其他线程。这很少见，一般具备这样功能的都是系统进程。通常是把和生命周期有关的用<code>@MainThread</code>标注，和<code>View</code>层级结构相关的用<code>@UiThread</code>标注。但是由于<code>@MainThread</code>本质上是一个<code>@UiThread</code>，而大部分情况下<code>@UiThread</code>又是一个<code>@MainThread</code>，所以你能在一个可以调用<code>@MainThread</code>方法的地方也能调用<code>@UiThread</code>方法，反之亦然。</p></blockquote><h3 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h3><pre><code>private static volatile Executor sDefaultExecutor = SERIAL_EXECUTOR;//  这个执行器是串行的public static final Executor SERIAL_EXECUTOR = new SerialExecutor();private static final int CORE_POOL_SIZE = CPU_COUNT + 1;private static final int MAXIMUM_POOL_SIZE = CPU_COUNT * 2 + 1;//  这个执行器是并行的public static final Executor THREAD_POOL_EXECUTOR = new ThreadPoolExecutor(CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE, TimeUnit.SECONDS, sPoolWorkQueue, sThreadFactory);private static class SerialExecutor implements Executor {    final ArrayDeque&lt;Runnable&gt; mTasks = new ArrayDeque&lt;Runnable&gt;();    Runnable mActive;    public synchronized void execute(final Runnable r) {        //  将任务加入队列        //  做了一下包装 任务在运行完成或异常后执行下一个 保证线性执行        mTasks.offer(new Runnable() {            public void run() {                try {                    r.run();                } finally {                    scheduleNext();                }            }        });        if (mActive == null) {            scheduleNext();        }    }    protected synchronized void scheduleNext() {        if ((mActive = mTasks.poll()) != null) {            THREAD_POOL_EXECUTOR.execute(mActive);        }    }}//  这个方法可以指定使用的执行器@MainThreadpublic final AsyncTask&lt;Params, Progress, Result&gt; executeOnExecutor(Executor exec, Params... params);</code></pre><p>最初的版本，<code>AsyncTask</code>在单个后台线程上顺序执行<br>从<code>API4(1.6)</code>开始，变成了允许多个任务并行进行的线程池<br>从<code>API11(3.0)</code>开始，任务在一个单一线程执行以避免并行操作引起的错误<br>如果你需要并行执行，可以使用<code>executeOnExecutor()</code>，传入<code>THREAD_POOL_EXECUTOR</code></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>AsyncTask</code>是一个简单的在工作线程处理任务的方式，通过线程池调度任务（默认或者指定），后台任务的执行结果通过<code>Handler</code>机制发消息给<code>UI线程</code>更新界面</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;AsyncTask&lt;/code&gt;源码看似比较独立和简单，分析一下&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://lakeshire.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://lakeshire.github.io/tags/Android/"/>
    
      <category term="AsyncTask" scheme="http://lakeshire.github.io/tags/AsyncTask/"/>
    
      <category term="线程通信" scheme="http://lakeshire.github.io/tags/%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1/"/>
    
  </entry>
  
</feed>
